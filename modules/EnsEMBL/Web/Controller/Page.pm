# $Id$

package EnsEMBL::Web::Controller::Page;

### Prints the main web page - header, footer, navigation etc, and non dynamically loaded content.
### Deals with Command modules if required.

use strict;

use base qw(EnsEMBL::Web::Controller);

sub request   { return 'page'; }
sub cacheable { return 1;      }

sub init {
  my $self    = shift;
  my $hub     = $self->hub;
  my $request = $self->request;
  
  $self->clear_cached_content;
  
  my $cached = $self->get_cached_content($request); # Page retrieved from cache
  
  if (!$cached) {
    return if $self->update_configuration_from_url;                                      # Configuration has been updated - will force a redirect
    return if $self->builder->create_objects($hub->factorytype, $request) eq 'redirect'; # Forcing a redirect - don't need to go any further
  }
  
  $self->update_user_history if $hub->user;
  
  return if $cached;
  
  $self->page->initialize; # Adds the components to be rendered to the page module
  $self->configure;
  $self->render_page;
}

sub render_page {
  my $self = shift;
  $self->SUPER::render_page if $self->access_ok && !$self->process_command;
}

sub clear_cached_content {
  ### Flush the cache if the user has hit ^R or F5.
  ### Removes content from Memcached based on the request's URL and the user's session id.
  
  my $self  = shift;
  my $cache = $self->cache;
  my $r     = $self->r;
  
  if ($cache && ($r->headers_in->{'Cache-Control'} eq 'max-age=0' || $r->headers_in->{'Pragma'} eq 'no-cache') && $r->method ne 'POST') {
    $cache->delete_by_tags($self->{'url_tag'}, $self->{'session_id'} ? "session_id[$self->{'session_id'}]" : ());
    
    warn "DYNAMIC CONTENT CACHE CLEAR: $self->{'url_tag'}, $self->{'session_id'}" if $self->{'cache_debug'};
  }
}

sub update_configuration_from_url {
  ### Checks for shared data and updated config settings from the URL parameters
  ### If either exist, returns 1 to force a redirect to the updated page
  ### This function is only called during main page (EnsEMBL::Web::Magic::stuff) requests
  
  my $self      = shift;
  my $r         = $self->r;
  my $input     = $self->input;
  my $hub       = $self->hub;
  my $session   = $hub->session;
  my @share_ref = $input->param('share_ref');
  my $url;
  
  if (@share_ref) {
    $session->receive_shared_data(@share_ref); # This should push a message onto the message queue
    $input->delete('share_ref');
    $url = join '?', $r->uri, $input->query_string;
  }
  
  my $view_config = $hub->viewconfig;
  my $new_url     = $view_config->update_from_config_strings($r); # This should push a message onto the message queue
  
  $url = $new_url if $new_url;
  
  if ($url) {
    my @t = split /\?/, $url;
    $t[1] =~ s/%3A/:/g; # Unescape : in query string generated by $input->query_string
    $url = join '?', @t;
    
    $input->redirect($url); # If something has changed then we redirect to the new page
    return 1;
  }
}

sub process_command {
  ### Handles Command modules and the Framework-based database frontend. 
  ### Once the command has been processed, a redirect to a Component page will occur.
  
  my $self    = shift;
  my $command = $self->command;
  my $action  = $self->action;
  
  return unless $command || $action eq 'Wizard';
  
  my $object  = $self->object;
  my $page    = $self->page;
  my $builder = $self->builder;
  my $hub     = $self->hub;
  my $node    = $self->node;
  
  if ($command eq 'db_frontend') {
    my $type     = $self->type;
    my $function = $self->function || 'Display';

    # Look for all possible modules for this URL, in order of specificity and likelihood
    my @classes = (
      "EnsEMBL::Web::Component::${type}::${action}::$function",
      "EnsEMBL::Web::Command::${type}::${action}::$function",
      "EnsEMBL::Web::Component::DbFrontend::$function",
      "EnsEMBL::Web::Command::DbFrontend::$function"
    );

    foreach my $class (@classes) {
      if ($self->dynamic_use($class)) {
        if ($class =~ /Command/) {
          my $command_module = $class->new({
            object => $object,
            hub    => $hub,
            page   => $page,
            node   => $node
          });
          
          my $rtn = $command_module->process;
          
          return defined $rtn ? $rtn : 1;
        } else {
          $self->SUPER::render_page;
        }
      }
    }
  } else {
    # Normal command module
    my $class = $action eq 'Wizard' ? 'EnsEMBL::Web::Command::Wizard' : $command;
    
    if ($class && $self->dynamic_use($class)) {
      my $command_module = $class->new({
        object => $object,
        hub    => $hub,
        page   => $page,
        node   => $node
      });
      
      my $rtn = $command_module->process;
      
      return defined $rtn ? $rtn : 1;
    }
  }
}

sub access_ok {
  ### Checks if the given Command module is allowed, and forces a redirect if it isn't
  
  my $self = shift;
  
  my $filter = $self->not_allowed($self->hub);
  
  if ($filter) {
    my $url = $filter->redirect_url;
    
    # Double-check that a filter name is being passed, since we have the option 
    # of using the default URL (current page) rather than setting it explicitly
    $url .= ($url =~ /\?/ ? ';' : '?') . 'filter_module=' . $filter->name       unless $url =~ /filter_module/;
    $url .= ($url =~ /\?/ ? ';' : '?') . 'filter_code='   . $filter->error_code unless $url =~ /filter_code/;
    
    $self->page->ajax_redirect($url);
    
    return 0;
  }
  
  return 1;
}

1;