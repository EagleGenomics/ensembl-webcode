# $Id$
#
# This GO module is maintained by Chris Mungall <cjm@fruitfly.org>
#
# see also - http://www.geneontology.org
#          - http://www.godatabase.org/dev
#
# You may distribute this module under the same terms as perl itself

=head1 NAME

  GO::Handlers::SexprOutHandler     - Lisp style S-Expression Output Handler

=head1 SYNOPSIS

  use GO::Handlers::SexprOutHandler;
  use GO::Parser;

  $handler = new GO::Handlers::SexprOutHandler;
  $parser = new GO::Parser;
  $parser->parse($file);

=cut

=head1 DESCRIPTION

takes nested events generated by the GO::Parser object and turns them
into list style s-expressions.

the output of this handler may change, particularly with regard to the
quoting of function names and args

% ontology files look this as s-exprs

(ontology

 (term
  (acc 'GO:0003673')
  (name 'Gene_Ontology')
  (is_root '1')
 )
 (term
  (acc 'GO:0003674')
  (name 'molecular_function')
  (rel
   (type 'partof')
   (obj 'GO:0003673')
  )
 )
 (term
  (acc 'GO:0015643')
  (name 'anti-toxin')
  (rel
   (type 'isa')
   (obj 'GO:0003674')
  )
 )
 (term
  (acc 'GO:0015644')
  (name 'lipoprotein anti-toxin')
  (rel
   (type 'isa')
   (obj 'GO:0015643')
  )
 )

)

% gene association files look like this:

(assocs
 (dbset
  (proddb 'FB')
  (prod
   (prodacc 'FBgn0015567')
   (prodsymbol '&agr;-Adaptin')
   (prodtype 'taxonID:7227')
   (prodsyn 'gene')
   (assoc
    (assocdate '')
    (termacc 'GO:0005886')
    (is_not '0')
    (evidence
     (evcode 'IDA')
     (ref 'FB:FBrf0093110')
     (ref 'PMID:9118220')
    )
   )
   (assoc
    (assocdate '')
    (termacc 'GO:0007269')
    (is_not '0')
    (evidence
     (evcode 'NAS')
     (ref 'FB:FBrf0108281')
    )
   )
   (assoc
    (assocdate '')
    (termacc 'GO:0030122')
    (is_not '0')
    (evidence
     (evcode 'NAS')
     (ref 'FB:FBrf0115359')
    )
   )
   (assoc
    (assocdate '')
    (termacc 'GO:0006901')
    (is_not '0')
    (evidence
     (evcode 'TAS')
     (ref 'FB:FBrf0108281')
    )
   )
   (assoc
    (assocdate '')
    (termacc 'GO:0008021')
    (is_not '0')
    (evidence
     (evcode 'TAS')
     (ref 'FB:FBrf0108281')
     (ref 'PMID:10218159')
    )
   )
   (assoc
    (assocdate '')
    (termacc 'GO:0016183')
    (is_not '0')
    (evidence
     (evcode 'TAS')
     (ref 'FB:FBrf0108281')
    )
   )
   (assoc
    (assocdate '')
    (termacc 'GO:0030135')
    (is_not '0')
    (evidence
     (evcode 'TAS')
     (ref 'FB:FBrf0108281')
     (ref 'PMID:10218159')
    )
   )
  )
  (prod
   (prodacc 'FBgn0010215')
   (prodsymbol '&agr;-Cat')
   (prodtype 'taxonID:7227')
   (prodsyn 'gene')
   (assoc
    (assocdate '')
    (termacc 'GO:0003779')
    (is_not '0')
    (evidence
     (evcode 'ISS')
     (ref 'FB:FBrf0132100')
    )
   )
   (assoc
    (assocdate '')
    (termacc 'GO:0007016')
    (is_not '0')
    (evidence
     (evcode 'ISS')
     (ref 'FB:FBrf0129868')
    )
   )
   (assoc
    (assocdate '')
    (termacc 'GO:0008092')
    (is_not '0')
    (evidence
     (evcode 'ISS')
     (ref 'FB:FBrf0132100')
    )
   )
   (assoc
    (assocdate '')
    (termacc 'GO:0016342')
    (is_not '0')
    (evidence
     (evcode 'ISS')
     (ref 'FB:FBrf0129868')
     (ref 'PMID:10908592')
    )
   )
   (assoc
    (assocdate '')
    (termacc 'GO:0016343')
    (is_not '0')
    (evidence
     (evcode 'ISS')
     (ref 'FB:FBrf0129868')
     (ref 'PMID:10908592')
    )
   )
   (assoc
    (assocdate '')
    (termacc 'GO:0005915')
    (is_not '0')
    (evidence
     (evcode 'NAS')
     (ref 'FB:FBrf0118633')
    )
   )
  )
 )
)

=head1 PUBLIC METHODS - 


=cut

package GO::Handlers::SexprOutHandler;
use base qw(GO::Handlers::DefHandler);

sub init {
    my $self = shift;
    $self->{i} = 0;
}

sub o {
    my $self = shift;
    print " " x $self->{i};
    print shift;
    print "\n";
}

sub start_event {
    my $self = shift;
    my $ev = shift;
    $self->o("($ev");
    $self->{i}++;
    return;
}

sub end_event {
    my $self = shift;
    my $ev = shift;
    $self->{i}--;
    $self->o(")");
    return;
}

sub evbody {
    my $self = shift;
    foreach my $arg (@_) {
        if (ref($arg)) {
#            map {$self->event($_)} @$arg;
            $self->event(@$arg);
        }
        else {
            $self->o(lispquote($arg));
        }
    }
}

sub event {
    my $self = shift;
    my $ev = shift;
    my @args = @_;
    my $arg = $args[0];
    if (!ref($arg) &&
        length($arg) < 40) {
        $self->o("($ev ".lispquote($arg).")");
    }
    else {
        $self->start_event($ev);
        $self->evbody(@args);
        $self->end_event($ev);
    }
}

sub lispquote {
    my $s = shift;
    $s =~ s/\'/\\\'/g;
    "'$s'";
}

1;
