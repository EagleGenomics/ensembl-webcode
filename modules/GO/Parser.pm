# $Id$
#
#
# see also - http://www.geneontology.org
#          - http://www.fruitfly.org/annot/go
#
# You may distribute this module under the same terms as perl itself

=head1 NAME

  GO::Parser     - parses all GO files formats and types

=head1 SYNOPSIS

  use GO::Parser;
  my $parser = new GO::Parser({handler=>'obj'})
  $parser->parse("function.ontology");
  $parser->parse("GO.defs");
  $parser->parse("ec2go");
  $parser->parse("gene-associations.sgd");
  # get GO::Model::Graph object
  my $graph = $parse->handler->graph;

=cut

=head1 DESCRIPTION

Module for parsing GO flat files; see
ftp://ftp.geneontology.org/pub/go for examples

=head1 FORMATS

This module is a front end wrapper for a number of different GO/OBO
formats - see the relevant module documentation below for details:

=over

=item GO Ontology

Files with suffix ".ontology"

These store the ontology DAGs

These are handled by the module GO::Parsers::GoOntParser

=item GO Defintions

Files with suffix ".defs"

These are handled by the module GO::Parsers::GoDefParser

=item GO Xrefs

External database references for GO terms

Files with suffix "2go" (eg ec2go, metacyc2go)

These are handled by the module GO::Parsers::GoXrefParser

=item GO Gene Association Files

Annotations of genes or gene products using GO

Files with prefix "gene-association."

These are handled by the module GO::Parsers::GoAssocParser

=item OBO-text

Files with suffix ".obo"

These are handled by the module GO::Parsers::OboTextParser

This is a new file format replacement for the existing GO flat file
formats. It handles ontologies, definitions and xrefs (but not
associations)

=head2 PARSING ARCHITECTURE

The parsers are B<event driven>; it works by reading the flat files and
firing off *nested events*

It uses the stag module for this - see L<Data::Stag> for more details,
or http://stag.sourceforge.net

=head2 NESTED EVENTS

nested events can be thought of as xml, without attributes; nested
events can easily be turned into xml

events have a start, a body and an end

event handlers can *catch* these events and do something with them.

for example, an XML handler can turn these events into XML

an object handler can turn the events into objects, centred around the
GO::Model::Graph object

other handlers can catch the events and convert them into other
formats, eg DAML+OIL

a database loading event handler can catch the events and turn them
into SQL statements, loading a MySQL or postgres database

the advantage of an event based parsing architecture is that it is
easy to build lightweight parsers, and heavy weight object models can
be bypassed if prefered.

=head2 EXAMPLES

To see examples of the events generated by the GO::Parser class, run
the script go2xml; for example

  go2xml function.ontology

on any GO-formatted flatfile

You can also use the script "stag-parse.pl" which comes with the
L<Data::Stag> distribution. for example

  stag-parse.pl -p GO::Parsers::GoAssocParser gene-association.fb

=head2 HANDLERS

see GO::Handlers::* for all the different handlers possible;
more can be added dynamically.

you can either create the handler object yourself, and pass it as an argument,
e.g.

  my $apph    = new GO::AppHandle(-db=>"go");
  my $handler = new GO::Handlers::DbStoreHandler({apph=>$apph});
  my $parser  = new GO::Parser({handler=>$handler});
  $parser->parse(@files);

or you can use one of the registered handlers:

  my $parser = new GO::Parser({handler=>'db',
                               handler_args=>{apph=>$apph}});

the registered handlers are as follows:

       default=>"GO::Handlers::DefHandler",
       xml=>"GO::Handlers::XmlOutHandler",
       obj=>"GO::Handlers::ObjHandler",
       triple=>"GO::Handlers::TripleHandler",
       n3=>"GO::Handlers::N3OutHandler",
       db=>"GO::Handlers::DbStoreHandler",
       oil=>"GO::Handlers::OilOutHandler",
       rdf=>"GO::Handlers::RdfOutHandler",
       damloil=>"GO::Handlers::DamlOilOutHandler",

see the individual pod docs for each of these for details

=head1 EXAMPLES OF DATATYPE TEXT FORMATS

These are parsed using the GO::Parsers::GoTextParser module

=head2 GO-TEXT FORMAT

eg format: go-text for storing graphs and metadata:

  !version: $Revision$
  !date: $Date$
  !editors: Michael Ashburner (FlyBase), Midori Harris (SGD), Judy Blake (MGD)
  $Gene_Ontology ; GO:0003673
   $cellular_component ; GO:0005575
    %extracellular ; GO:0005576
     <fibrinogen ; GO:0005577
      <fibrinogen alpha chain ; GO:0005972
      <fibrinogen beta chain ; GO:0005973

this is the following file parsed with events turned directly into XML:

<subgraph>
 <term>
  <acc>GO:0003673</acc>
  <name>Gene_Ontology</name>
  <is_root>1</is_root>
 </term>
 <term>
  <acc>GO:0005575</acc>
  <name>cellular_component</name>
  <rel>
   <type>isa</type>
   <obj>GO:0003673</obj>
  </rel>
 </term>
 <term>
  <acc>GO:0005576</acc>
  <name>extracellular</name>
  <rel>
   <type>isa</type>
   <obj>GO:0005575</obj>
  </rel>
 </term>
 <term>
  <acc>GO:0005577</acc>
  <name>fibrinogen</name>
  <rel>
   <type>partof</type>
   <obj>GO:0005576</obj>
  </rel>
 </term>
 <term>
  <acc>GO:0005972</acc>
  <name>fibrinogen alpha chain</name>
  <rel>
   <type>partof</type>
   <obj>GO:0005577</obj>
  </rel>
 </term>
 <term>
  <acc>GO:0005973</acc>
  <name>fibrinogen beta chain</name>
  <rel>
   <type>partof</type>
   <obj>GO:0005577</obj>
  </rel>
 </term>
</subgraph>

=head2 GO-DEFS format

eg format: go-defs for storing definitions:

  !Gene Ontology definitions
  !
  term: 'de novo' protein folding
  goid: GO:0006458
  definition: Processes that assist the folding of a nascent peptide chain into its correct tertiary structure.
  definition_reference: Sanger:mb

eg format: go-xrefs for storing xrefs:

  EC:1.-.-.- > GO:oxidoreductase ; GO:0016491
  EC:1.1.-.- > GO:1-phenylethanol dehydrogenase ; GO:0018449

eg format: go-assocs for storing gene-associations:

  SGD     S0004660        AAC1            GO:0005743      SGD:12031|PMID:2167309 TAS             C       ADP/ATP translocator    YMR056C gene    taxon:4932 20010118
  SGD     S0004660        AAC1            GO:0006854      SGD:12031|PMID:2167309 IDA             P       ADP/ATP translocator    YMR056C gene    taxon:4932 20010118


=cut

package GO::Parser;

use Exporter;
@ISA = qw(Exporter);

use Carp;
use GO::Model::Term;
use FileHandle;
use strict qw(subs vars refs);

# Exceptions


# Constructor


=head2 new

  Usage   - my $parser = GO::Parser->new()
  Returns - GO::Parser

creates a new parser

=cut

sub new {
    my $class = shift;
    my $init_h = $_[0] || {};
    if (!ref($init_h)) {
        $init_h = {@_};
    }
    my $fmt = lc($init_h->{format});
    $fmt = 'gotext' unless $fmt;
    my %lookup =
      (
       "rdf" => "GO::Parsers::RdfParser",
       "gotext" => "GO::Parsers::GoTextParser",
       "xml" => "GO::Parsers::GoEventXmlParser",
       "mesh" => "GO::Parsers::MeshParser",
       "obo" => "GO::Parsers::OboTextParser",
      );
    my $mod = $init_h->{module} || $lookup{$fmt};
    $class->load_module($mod);

    my $handler = $init_h->{handler} || "default";
    my %hh =
      (default=>"GO::Handlers::DefHandler",
       xml=>"GO::Handlers::XmlOutHandler",
       summary=>"GO::Handlers::SummaryHandler",
       test=>"GO::Handlers::TestDumpHandler",
       obj=>"GO::Handlers::ObjHandler",
       triple=>"GO::Handlers::TripleHandler",
       prolog=>"GO::Handlers::PrologOutHandler",
       lisp=>"GO::Handlers::LispOutHandler",
       sexpr=>"GO::Handlers::SexprOutHandler",
       n3=>"GO::Handlers::N3OutHandler",
       db=>"GO::Handlers::DbStoreHandler",
       oil=>"GO::Handlers::OilOutHandler",
       obo=>"GO::Handlers::OboOutHandler",
       rdf=>"GO::Handlers::RdfOutHandler",
       gotext=>"GO::Handlers::GoTextOutHandler",
       damloil=>"GO::Handlers::DamlOilOutHandler",
       schema=>"GO::Handlers::SchemaOutHandler",
       stag=>"GO::Handlers::StagOutHandler",
       chadoxml=>"GO::Handlers::ChadoXmlOutHandler",
      );
    if (UNIVERSAL::isa($handler, "GO::AppHandle")) {
        require "GO/Handlers/DbStoreHandler.pm";
        $handler = GO::Handlers::DbStoreHandler->new({apph=>$handler});
    }
    unless (ref($handler)) {
        my $class = $hh{$handler} or die $handler;
        my $mod = $class;
        $mod =~ s/::/\//g;
#        print "mod=$mod\n";
        require "$mod.pm";
        $handler = $class->new($init_h->{handler_args});
    }

    my $p = $mod->new($init_h);
    $p->handler($handler);

    delete $init_h->{parser};
    delete $init_h->{handler};
    if ($init_h) {
	map {$p->{$_} = $init_h->{$_}} keys %$init_h;
    }

    return $p;
}

sub load_module {

    my $self = shift;
    my $classname = shift;
    my $mod = $classname;
    $mod =~ s/::/\//g;

    if ($main::{"_<$mod.pm"}) {
    }
    else {
        require "$mod.pm";
    }
}

1;
