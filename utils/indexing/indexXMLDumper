#!/usr/local/bin/perl

#usage:
# ./indexXMLDumper --species aaa,bbb -indexes xxx,yyy > & index.log
# 'ALL' can be used as a value for both species and indexes

use strict;
package indexXMLDumper;

my $ENSEMBL_ROOT;

BEGIN {
  use FindBin qw($Bin);
  use File::Basename qw( dirname );
  $ENSEMBL_ROOT = dirname( $Bin );
  $ENSEMBL_ROOT =~ s/\/utils$//;
  unshift @INC, "$ENSEMBL_ROOT/conf";
  eval{ require SiteDefs };
  if ($@){ die "Can't use SiteDefs.pm - $@\n"; }
  map{ unshift @INC, $_ } @SiteDefs::ENSEMBL_LIB_DIRS;
}

use EnsEMBL::Web::SpeciesDefs;
use Data::Dumper;
use Getopt::Long;

use constant INC_SPECIES => 0;
use CGI;

our $SD = EnsEMBL::Web::SpeciesDefs->new();
our $release = $SD->ENSEMBL_VERSION;
our $nogzip = 1; #try setting to 0 for on the fly gzipping ?
our %cross_references;  #get a set of external_dbs so we can make sure we link to them all correctly
our %additional_fields; #summarise additional fields so we can make sure we treat each one correctly

my (@species,@indexes);
GetOptions('species=s' => \@species,
	   'indexes=s' => \@indexes,
	  );

(@species) = split ',',@species[0];
(@indexes) =  split ',',@indexes[0]; 

## HACK 1 - if the INDEX is set to all grab all dumper methods...
@indexes = map { /dump(\w+)/?$1:() } keys %indexXMLDumper:: if $indexes[0] eq 'ALL';

## HACK 2 - if the SPECIES is set to ALL grab stuff from config...
my %X = %{$SD->ENSEMBL_SPECIES_ALIASES};
if( $species[0] eq 'ALL' ) {
  @species = @{$SD->ENSEMBL_DATASETS}
} else {
  @species = grep {$_} map { $X{lc($_)} } @species;
}

# EnsEMBL::Web::IndexSupport takes path to conf, path to files, species
my $conf = {};
mkdir 'input', 0777 unless -e 'input';

my $total_c;
foreach my $index (@indexes) {
  $conf->{'directory'} = "input/ensembl_$index";
  mkdir $conf->{'directory'}, 0777 unless -e  $conf->{'directory'};
  foreach my $species ( @species ) {
    $conf->{'species'}   = $species;
    $conf->{'authority'} = $SD->get_config($species,'AUTHORITY');
    my %dbs = %{$SD->get_config($species,'databases')||{}};
    $conf->{'dbs'}       = { map { ($_,$dbs{$_}{NAME}) } keys %dbs };
    $conf->{'dbs'}{'DATABASE_COMPARA'} = 'ensembl_compara_'.$SD->ENSEMBL_VERSION;
    my $core = $dbs{'DATABASE_CORE'};
    $conf->{'dbh_compara'} = DBI->connect( "dbi:mysql:ensembl_compara_".$SD->ENSEMBL_VERSION.";host=ensdb-1-13;port=5307", $core->{'USER'}, $core->{'PASS'} );
    $conf->{'dbh'}         = DBI->connect( "dbi:mysql:$core->{'NAME'};host=$core->{'HOST'};port=$core->{'PORT'}", $core->{'USER'}, $core->{'PASS'} );
#    warn join ' ', $species, Data::Dumper::Dumper $conf;
    print "Starting: $index $species\n";
    my $function = "dump$index";
    no strict "refs";
    eval { $total_c += &$function( $conf ); };
    print $@ if $@;
  }
}

print "\nAdditional fields are:\n",Dumper(\%additional_fields);
print "\nCross references are:\n",Dumper(\%cross_references) if %cross_references;
print "\nDumped $total_c records in total\n";

exit;

## Now for all the dump functions...............................

########################################################################## Markers

sub dumpMarker {
  my $conf = shift;
  my $dbname    = $conf->{'dbs'}{'DATABASE_CORE'};
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/Marker_$dbname.xml";
  $file .= ".gz" unless $nogzip;
  my $start_time = time;
  my $db = 'core';
  my $fh;
  unless ($nogzip) {
    $fh = new IO::Zlib;
    $fh->open( "$file", "wb9" )
      || die("Can't open compressed stream to $file: $!");
  }
  else {
    open( FILE, ">$file" ) || die "Can't open $file: $!";
  }
  print "  Dumping $dbname to $file ... ", format_datetime($start_time), "\n";
  header( $dbname, $dbspecies, $db, $nogzip, $fh, $release );
  my $sth = $conf->{'dbh'}->prepare("
   SELECT m.marker_id, ms2.name, ms1.name
     FROM marker_synonym as ms1, marker as m
LEFT JOIN marker_synonym as ms2 on ms2.marker_synonym_id = m.display_marker_synonym_id
    WHERE ms1.marker_id = m.marker_id
 ORDER BY m.marker_id
  ");

  $sth->execute( );
  my $names  = [];
  my $old_ID = 0;
  my ($ID,$marker,$synonym);
  while( ($ID,$marker,$synonym) = $sth->fetchrow_array()){
    $marker = $synonym unless $marker;
    if($ID == $old_ID) {
      push @$names, $synonym;
    } else {
      if ($old_ID) {
	&p( markerLine( $dbspecies, $names, $counter ), $nogzip, $fh);
      }
      $names    = [ $synonym ];
      $old_ID  = $ID;
    }
  }
  &p( markerLine( $dbspecies, $names, $counter ), $nogzip, $fh);
  return footer( $counter->(),$nogzip,$fh);
}

sub markerLine {
  my( $species, $IDS, $counter ) = @_;
  $species =~ s/_/ /;
  my @synonyms = sort @$IDS;
  my $key = pop @synonyms;
  my $xml = qq(
<entry id="$key">
  <additional_fields>);
  foreach my $syn (@synonyms) {
    $xml .= qq(
    <field name="synonym">$syn</field>);
    $additional_fields{'synonym'}++;
  }
  $xml .= qq(
    <field name="species">$species</field>
    <field name="featuretype">Marker</field>
  </additional_fields>);
  $additional_fields{'species'}{$species}++;
  $additional_fields{'featuretype'}{'Marker'}++;
  $counter->();
  return $xml . '</entry>';
}


########################################################################## QTLs

sub dumpQTL {
  my $conf = shift;
  my $dbname    = $conf->{'dbs'}{'DATABASE_CORE'};
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/QTL_$dbname.xml";
  $file .= ".gz" unless $nogzip;
  my $start_time = time;
  my $db = 'core';
  my $fh;
  unless ($nogzip) {
    $fh = new IO::Zlib;
    $fh->open( "$file", "wb9" )
      || die("Can't open compressed stream to $file: $!");
  }
  else {
    open( FILE, ">$file" ) || die "Can't open $file: $!";
  }
  print "  Dumping $dbname to $file ... ", format_datetime($start_time), "\n";
  header( $dbname, $dbspecies, $db, $nogzip, $fh, $release );
  my $sth = $conf->{'dbh'}->prepare("
 select c.name as chr, qf.seq_region_start, qf.seq_region_end,
        a.logic_name as analysis, q.qtl_id,
        q.trait, qs.source_database, qs.source_primary_id,
        fms1.source as fm1_source, fms1.name as fm1_name,
        fms2.source as fm2_source, fms2.name as fm2_name,
        pms.source  as pm_source,  pms.name  as pm_name
   from ((((((seq_region as c, qtl_feature as qf, qtl_synonym as qs,
        analysis as a, qtl as q) left join marker as fm1 on
        fm1.marker_id = q.flank_marker_id_1) left join marker_synonym as fms1 on
        fm1.display_marker_synonym_id = fms1.marker_synonym_id) left join marker as fm2 on
        fm2.marker_id = q.flank_marker_id_2) left join marker_synonym as fms2 on
        fm2.display_marker_synonym_id = fms2.marker_synonym_id) left join marker as pm on
        pm.marker_id = q.peak_marker_id) left join marker_synonym as pms on
        pm.display_marker_synonym_id = pms.marker_synonym_id 
  where c.seq_region_id = qf.seq_region_id and qs.qtl_id = q.qtl_id and 
        qf.analysis_id = a.analysis_id and qf.qtl_id = q.qtl_id
  ");
  $sth->execute();
  my $desc    = '';
  my $old_qtl = 0;
  my $old_ID  = '';
  my $old_pos = '';
  my $IDS     = [];
  while( my $T = $sth->fetchrow_hashref() ){
    if($T->{qtl_id} eq $old_qtl) {
      push @$IDS, $T->{source_primary_id};
      $desc .= " $T->{source_database}:$T->{source_primary_id}";
    } else {
      if ($old_ID) {
	&p( QTLLine( $dbspecies, $old_ID, $old_pos, $IDS, $desc, $counter ), $nogzip, $fh);
      }
      $IDS = [ "$T->{trait} $T->{source_primary_id}" ];
      push @$IDS, $T->{fm1_name} if $T->{fm1_name};
      push @$IDS, $T->{fm2_name} if $T->{fm2_name};
      push @$IDS, $T->{pm_name}  if $T->{pm_name};
      $old_ID = $T->{pm_name};
      $old_pos = "$T->{chr}:".($T->{seq_region_start}-1e4).'-'.($T->{seq_region_end}+1e4);
      $desc       = "QTL exhibiting '$T->{trait}' has ";
      my $f2 = $T->{pm_name} ? 1 : 0;
      if( $T->{fm1_name} || $T->{fm2_name} ) {
        my $f1= ($T->{fm1_name}) && ($T->{fm2_name}) ? 1 : 0;
        $desc.='flanking marker'.($f1?'s ':' ').$T->{fm1_name}.($f1?' and ':'').$T->{fm2_name}.($f2?'; ':'');
      }
      if($f2) {
        $desc.= "peak marker $T->{pm_name};";
      }
      $desc.=" and names: $T->{source_database}:$T->{source_primary_id}";
      $old_qtl = $T->{qtl_id};
    }
  }
  &p( QTLLine( $dbspecies, $old_ID, $old_pos, $IDS, $desc, $counter ), $nogzip, $fh);
  return footer( $counter->(),$nogzip,$fh);

}

sub QTLLine {
  my ($species, $key, $pos, $IDS, $desc, $counter ) = @_;
  $species =~ s/_/ /;
  my $xml = qq(
<entry id="$key">
  <description>$desc</description>
  <additional_fields>);
  foreach my $id (@$IDS) {
    $xml .= qq(
    <field name="synonym">$id</field>);
    $additional_fields{'synonym'}++;
  }
  $xml .= qq(
    <field name="species">$species</field>
    <field name="featuretype">QTL</field>
    <field name="location">$pos</field>
  </additional_fields>);
  $additional_fields{'species'}{$species}++;
  $additional_fields{'featuretype'}{'QTL'}++;
  $additional_fields{'location'}++;
  $counter->();
  return $xml . '</entry>';
}


########################################################################## SNPs

sub dumpSNP {
  my $conf = shift;
  my $SNPDB = $conf->{'dbs'}->{'DATABASE_VARIATION'};
  return unless $SNPDB;
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/SNP_$SNPDB.xml";
  $file .= ".gz" unless $nogzip;
  my $start_time = time;
  my $db = 'variation';
  my $fh;
  unless ($nogzip) {
    $fh = new IO::Zlib;
    $fh->open( "$file", "wb9" )
      || die("Can't open compressed stream to $file: $!");
  }
  else {
    open( FILE, ">$file" ) || die "Can't open $file: $!";
  }
  print "  Dumping $SNPDB to $file ... ", format_datetime($start_time), "\n";
  header( $SNPDB, $dbspecies, 'variation', $nogzip, $fh, $release );

  `/usr/bin/mysql -h ensdb-1-13 -P5307 -uensro $SNPDB -e 'select variation_id,source_id,name from variation order by variation_id' > v.txt`;
  `/usr/bin/mysql -h ensdb-1-13 -P5307 -uensro $SNPDB -e 'select variation_id,source_id,name from variation_synonym order by variation_id' > vs.txt`;

  my %SNP_EXTRA = map { ($_->[0] => $_) }
    @{$conf->{'dbh'}->selectall_arrayref(
      "select va.variation_id,
              group_concat( distinct va.local_stable_id SEPARATOR '; ') as lsi,
              group_concat( distinct va.study           SEPARATOR '; ') as st,
              group_concat( distinct va.associated_gene SEPARATOR '; ') as gn,
              group_concat( distinct va.variation_names SEPARATOR '; ') as vars,
              group_concat( distinct 
                if(
                  isnull(p.name),
                  description,
                  concat( p.description,' (',p.name,')' )
                )
                SEPARATOR '; '
              ) as phen
         from $SNPDB.variation_annotation as va left join
              $SNPDB.phenotype as p on p.phenotype_id = va.phenotype_id
        group by va.variation_id
        order by va.variation_id"
    )};

  my $SOURCES = { map { @$_ } @{$conf->{'dbh'}->selectall_arrayref( "select source_id, name from $SNPDB.source" )} };

  open( my $fh1, 'v.txt' );
  open( my $fh2, 'vs.txt' );
  open( my $fh3, '>snps.txt' );
  my $shift = <$fh1>; # remove first line
  $shift = <$fh2>;
  my $F=1;
  my $snp1 = n($fh1,$SOURCES);
  my $snp2 = n($fh2,$SOURCES) || [0,0,''];
  while( $snp1 && $snp2 ) {
#   warn "$snp1->[0]-$snp2->[0]";
    if( $snp2->[0] ) {
      if( $snp1->[0] ) {
        if($snp2->[0]<$snp1->[0]) {
          warn "ARGH!! snp2_ID < snp1_ID panic!! @{$snp2}";
          $snp2 = n($fh2,$SOURCES)||[0,0,'']; # get next synonym
        } elsif($snp2->[0]>$snp1->[0]) {
          print $fh3 "@$snp1\n";
          $snp1 = n($fh1,$SOURCES); # get next snp...
        } else {
          push @{$snp1}, "$snp2->[1]:$snp2->[2]";
          $snp2 = n($fh2,$SOURCES)||[0,0,'']; # get next snp2
        }
      } else {
        warn "ARGH!!!! run out of snps";
      }
    } elsif( $snp1->[0] ) {
      print $fh3 "@$snp1\n";
      $snp1 = n($fh1,$SOURCES);
    } else {
      $F = 0;
    }
  }
  if($snp1) {
    print $fh3 "@$snp1\n";
  }

  unlink 'v.txt';
  unlink 'vs.txt';
  close $fh1;
  close $fh2;
  close $fh3;
  open I, 'snps.txt' ;
  while(<I>) {
    my($ID,$source,$name,@keywords) = split;
    my @K = map { (my $t=$_)=~ s/^\w+://;$t } @keywords;
    my $size = @keywords;
    my $extra = '';
    my $x = $SNP_EXTRA{$ID};
    if( $x ) {
      push @K, $x->[1], $x->[3],$x->[4];
      $extra = '; and is associated with following phenotypes:'. $x->[4];
      if( $x->[1] ) {
        $extra .= sprintf ', through %s', $x->[1];
      }
      if( $x->[2] ) {
        $extra .= sprintf ', through study(s): %s, and associated with following gene(s): %s', $x->[2], $x->[3];
      }
    }

    my $desc = sprintf( "A %s SNP %s%s",
			$source,
			$size > 1 ? "with $size synonyms: @keywords"
		      : $size     ? "with one synonym: @keywords"
		      :             "with no synonyms",
			$extra
		      );

    &p( SNPLine( $dbspecies, $name, \@K, $source, $desc, $counter ), $nogzip, $fh);
  }
  close I;
  return footer( $counter->(),$nogzip,$fh);
}

sub n {
  my( $fh, $sources ) = @_;
  my $L = <$fh>;
  my $snp;
  if( $L ) {
    chomp $L;
    my @L = split /\t/, $L;
    $snp = [ $L[0], $sources->{$L[1]}, $L[2]];
  }
  return $snp;
}

sub SNPLine {
  my ($species, $name, $IDS, $source, $desc, $counter ) = @_;
  $species =~ s/_/ /;
  my $xml = qq(
<entry id="$name">
  <description>$desc</description>
  <additional_fields>);
  foreach my $id (@$IDS) {
    $xml .= qq(
    <field name="synonym">$id</field>);
  }
  $additional_fields{'synonym'}++;
  $xml .= qq(
    <field name="species">$species</field>
    <field name="featuretype">SNP</field>
    <field name="source">$source</field>
  </additional_fields>);
  $additional_fields{'species'}{$species}++;
  $additional_fields{'featuretype'}{'SNP'}++;
  $additional_fields{'source'}{$source}++;
  $counter->();
  return $xml . '</entry>';
}

########################################################################## StructuralVariations

sub dumpStructuralVariations {
  my $conf = shift;
  my $SNPDB = $conf->{'dbs'}->{'DATABASE_VARIATION'};
  return unless $SNPDB;
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/StructuralVariations_$SNPDB.xml";
  $file .= ".gz" unless $nogzip;
  my $start_time = time;
  my $db = 'variation';
  my $fh;
  unless ($nogzip) {
    $fh = new IO::Zlib;
    $fh->open( "$file", "wb9" )
      || die("Can't open compressed stream to $file: $!");
  }
  else {
    open( FILE, ">$file" ) || die "Can't open $file: $!";
  }
  print "  Dumping $SNPDB to $file ... ", format_datetime($start_time), "\n";
  header( $SNPDB, $dbspecies, 'variation', $nogzip, $fh, $release );

  my $scale           = $SD->ENSEMBL_GENOME_SIZE || 1;
  my $max_length      = $scale *= 1e6;

  my $T = $conf->{'dbh'}->selectall_arrayref("
    select v.structural_variation_id,
           v.variation_name,
           s.name,
           s.description,
           r.name,
           v.seq_region_start,
           v.seq_region_end
      from $SNPDB.structural_variation as v, $SNPDB.source as s, $SNPDB.seq_region as r
     where s.source_id = v.source_id and r.seq_region_id = v.seq_region_id
     order by v.structural_variation_id"
  );
  foreach my $row ( @$T ) {
    my $id = $row->[1];
    my $location = $row->[4] .":" . $row->[5] ."-". $row->[6];
    my $length = $row->[6] - $row->[7];
    my $action = ($length >> $max_length) ? 'Overview' : 'View';
    my $view_config = ($length >> $max_length) ? 'cytoview=variation_feature_structural=normal;' : 'contigviewbottom=variation_feature_structural=normal;';
    my $desc = qq(A structural variation from $row->[2], identified by $row->[3]. This variation has been mapped to chromosome $row->[4], from $row->[5] to $row->[6]. );
    &p( StrucVarLine( $dbspecies, $id, $location, $desc, $action, $view_config, $counter ), $nogzip, $fh);
  }
  return footer( $counter->(),$nogzip,$fh);
}

sub StrucVarLine {
  my ($species, $id, $location, $desc, $action, $view_config, $counter ) = @_;
  $species =~ s/_/ /;
  my $xml = qq(
<entry id="$id">
  <description>$desc</description>
  <additional_fields>);
  $xml .= qq(
    <field name="species">$species</field>
    <field name="featuretype">StructuralVariation</field>
    <field name="location">$location</field>
    <field name="action">$action</field>
    <field name="view_config">$view_config</field>
  </additional_fields>);
  $additional_fields{'species'}{$species}++;
  $additional_fields{'feature_type'}{'StructuralVariation'}++;
  $additional_fields{'location'}++;
  $additional_fields{'action'}++;
  $additional_fields{'view_config'}++;
  $counter->();
  return $xml . '</entry>';
}


########################################################################## Similarity features

sub dumpGenomicAlignment {
  my $conf    = shift;
  my $counter = make_counter(0);
  my $species = $conf->{'species'};
  my $COREDB  = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $ESTDB   = $conf->{'dbs'}->{'DATABASE_OTHERFEATURES'};
  my $CDNADB  = $conf->{'dbs'}->{'DATABASE_CDNA'};
  my %dbs      = ( 'core' => $COREDB );
  $dbs{'otherfeatures'} =  $ESTDB  if $ESTDB;
  $dbs{'cdna'}          = $CDNADB if $CDNADB;
  my %tables = (
    'dna_align_feature'     => [ 'DnaAlignFeature',     'DNA alignment feature' ],
    'protein_align_feature' => [ 'ProteinAlignFeature', 'Protein alignment feature' ]
  );
  my $total_c;
  foreach my $db ( sort { $b cmp $a } keys %dbs) {
    my $dbname    = $dbs{$db};
    my $dbspecies = $conf->{'species'};
    my $file      = $conf->{'directory'}."/GenomicAlignment_$dbname.xml";
    $file .= ".gz" unless $nogzip;
    my $start_time = time;
    my $fh;
    unless ($nogzip) {
      $fh = new IO::Zlib;
      $fh->open( "$file", "wb9" ) || die("Can't open compressed stream to $file: $!");
    }
    else {
      open( FILE, ">$file" ) || die "Can't open $file: $!";
    }
    print "  Dumping $dbname to $file ... ", format_datetime($start_time), "\n";
    header( $dbname, $dbspecies, $db, $nogzip, $fh, $release );

    foreach my $table ( keys %tables ) {
      my $source = $tables{ $table }[0];
      $source .= ";db=$db" unless $db eq 'core';
      my $type   = $tables{ $table }[1];
      my $sth    = $conf->{'dbh'}->prepare(
	"select ad.display_label, t.hit_name, edb.db_name, count(*) as hits
                from (($dbname.analysis as a, $dbname.$table as t) left join
                     $dbname.analysis_description ad on a.analysis_id = ad.analysis_id) 
           left join $dbname.external_db edb on t.external_db_id = edb.external_db_id
               where a.analysis_id = t.analysis_id
               group by ad.display_label, t.hit_name");
      $sth->execute();
      my $c = 0;
      while( my( $label, $hid, $db_name, $count  ) = $sth->fetchrow_array ) {
	$c++;
	$label ||= '';
	my $desc = "$label $hid hits the genome in $count locations.";
	&p( GenomicAlignmentLine( $dbspecies, $hid, $desc, $db_name, $db, $table, $counter ), $nogzip, $fh);
      }
      print "     Dumped $c $table entries";
    }
    if ($db eq 'cdna') {
      my $sth    = $conf->{'dbh'}->prepare(
	"select ad.display_label, uo.identifier,  ur.summary_description, 'Unmapped feature'
           from $dbname.unmapped_object uo, $dbname.unmapped_reason ur, $dbname.analysis a 
                left join $dbname.analysis_description ad on a.analysis_id = ad.analysis_id
          where a.analysis_id = uo.analysis_id
            and uo.unmapped_reason_id = ur.unmapped_reason_id");
      $sth->execute();
      my $c++;
      while (my ($label, $hid, $reason, $type) = $sth->fetchrow_array ) {
	$c++;
	$label ||= '';
	my $desc = "$label $hid fails to map to the genome. Reason: $reason.";
	&p( GenomicAlignmentLine( $dbspecies, $hid, $desc, undef, $db, 'Unmapped feature', $counter ), $nogzip, $fh);
      }
      print "     Dumped $c Unmapped features";
    }
    $total_c += footer( $counter->(),$nogzip,$fh);
  }
  return $total_c;
}

sub GenomicAlignmentLine {
  my ($species, $id, $desc, $db_name, $db, $ftype, $counter ) = @_;
  $species =~ s/_/ /;
  my $xml = qq(
<entry id="$id">
  <description>$desc</description>);
  if ($db_name) {
    $xml .= qq(
  <cross_references>
    <ref dbname="$db_name" dbkey="$id"/>
  </cross_references>);
    $cross_references{$db_name}++;
  }
  $xml .= qq(
  <additional_fields>
    <field name="species">$species</field>
    <field name="featuretype">$ftype</field>
    <field name="db">$db</field>
  </additional_fields>);
  $additional_fields{'species'}{$species}++;
  $additional_fields{'featuretype'}{$ftype}++;
  $additional_fields{'db'}++;
  $counter->();
  return $xml . '</entry>';
}


########################################################################## OligoProbes

sub dumpOligoProbe {
  my $conf = shift;
  my $FUNCDB = $conf->{'dbs'}->{'DATABASE_FUNCGEN'};
  return unless $FUNCDB;
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/OligoProbe_$FUNCDB.xml";
  $file .= ".gz" unless $nogzip;
  my $start_time = time;
  my $db = 'fungen';
  my $fh;
  unless ($nogzip) {
    $fh = new IO::Zlib;
    $fh->open( "$file", "wb9" )
      || die("Can't open compressed stream to $file: $!");
  }
  else {
    open( FILE, ">$file" ) || die "Can't open $file: $!";
  }
  print "  Dumping $FUNCDB to $file ... ", format_datetime($start_time), "\n";
  header( $FUNCDB, $dbspecies, $db, $nogzip, $fh, $release );

  my $sth    = $conf->{'dbh'}->prepare(
    "select ps.name, count(distinct pf.probe_feature_id) as hits, a.vendor
        from $FUNCDB.probe_set ps, $FUNCDB.probe p, $FUNCDB.probe_feature pf, $FUNCDB.array_chip ac, $FUNCDB.array a, $FUNCDB.status s, $FUNCDB.status_name sn
      where sn.name='MART_DISPLAYABLE'
        and sn.status_name_id=s.status_name_id
        and s.table_name='array'
        and s.table_id=a.array_id
        and ps.probe_set_id = p.probe_set_id
        and p.probe_id = pf.probe_id
        and p.array_chip_id = ac.array_chip_id
        and ac.array_id = a.array_id
      group by ps.name, a.vendor"
  );
  $sth->execute();
  while( my( $hid, $count, $type ) = $sth->fetchrow_array ) {
    next unless $hid;
    my $desc =  qq($type probeset $hid hits the genome in $count locations.);
    &p( OligoProbeLine($dbspecies,$hid,$desc,'pset',$db,$counter ), $nogzip, $fh);
  }

  my $sth    = $conf->{'dbh'}->prepare(
    "select group_concat(distinct p.name), count(distinct pf.probe_feature_id) as hits, a.vendor
        from $FUNCDB.probe p, $FUNCDB.probe_feature pf, $FUNCDB.array_chip ac, $FUNCDB.array a, $FUNCDB.status s, $FUNCDB.status_name sn
      where sn.name='MART_DISPLAYABLE'
        and sn.status_name_id=s.status_name_id
        and s.table_name='array'
        and s.table_id=a.array_id
        and p.probe_set_id is NULL
        and p.probe_id = pf.probe_id
        and p.array_chip_id = ac.array_chip_id
        and ac.array_id = a.array_id
      group by p.probe_id, a.vendor"
  );
  $sth->execute();
  while( my( $hid, $count, $type ) = $sth->fetchrow_array ) {
    next unless $hid;
    my $desc = qq($type probe $hid hits the genome in $count locations.);
    &p( OligoProbeLine($dbspecies,$hid,$desc,'probe',$db,$counter ), $nogzip, $fh);
  }
  return footer( $counter->(),$nogzip,$fh);
}

sub OligoProbeLine {
  my ($species,$hid,$desc,$pset,$db,$counter) = @_;
  $species =~ s/_/ /;
  my $xml = qq(
<entry id="$hid">
  <description>$desc</description>);
  $xml .= qq(
  <additional_fields>
    <field name="species">$species</field>
    <field name="featuretype">ProbeFeature</field>
    <field name="db">$db</field>
    <field name="ptype">$pset</field>
  </additional_fields>);
  $additional_fields{'species'}{$species}++;
  $additional_fields{'featuretype'}{'ProbeFeature'}++;
  $additional_fields{'ptype'}++;
  $additional_fields{'db'}++;
  $counter->();
  return $xml . '</entry>';
}


########################################################################## Domains

sub dumpDomain {
  my $conf = shift;
  my $dbname    = $conf->{'dbs'}{'DATABASE_CORE'};
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/Domain_$dbname.xml";
  $file .= ".gz" unless $nogzip;
  my $start_time = time;
  my $db = 'core';
  my $fh;
  unless ($nogzip) {
    $fh = new IO::Zlib;
    $fh->open( "$file", "wb9" )
      || die("Can't open compressed stream to $file: $!");
  }
  else {
    open( FILE, ">$file" ) || die "Can't open $file: $!";
  }
  print "  Dumping $dbname to $file ... ", format_datetime($start_time), "\n";
  header( $dbname, $dbspecies, $db, $nogzip, $fh, $release );

  my $sth = $conf->{'dbh'}->prepare(
    "select x.dbprimary_acc, i.id, x.description
       from xref as x, interpro as i
      where x.dbprimary_acc = i.interpro_ac
      order by x.dbprimary_acc");
  $sth->execute();
  my $old_acc     = '';
  my $IDS         = [];
  my $description = '';
  my $count       = 0;
  my ($acc, $id, $desc, $old_desc );
  while( ($acc, $id, $desc ) = $sth->fetchrow_array()){
    if($acc eq $old_acc) {
      push @$IDS, $id;
      $count++;
    }
    else {
      if ($old_acc) {
	$description = "Interpro domain $old_acc [$old_desc] has";
	&p( DomainLine($dbspecies,$old_acc,$description,$IDS,$count,$counter ), $nogzip, $fh);
      }
      $IDS      = [ $id ];
      $old_acc  = $acc;
      $old_desc = $desc;
      $count    = 1;
    }
  }
  $description = "Interpro domain $old_acc [$old_desc] has";
  &p( DomainLine($dbspecies,$old_acc,$description,$IDS,$count,$counter ), $nogzip, $fh);
  return footer( $counter->(),$nogzip,$fh);
}

sub DomainLine {
  my($species, $acc, $desc, $IDS, $count, $counter) = @_;
  $species =~ s/_/ /;
  my $ids = join ',', @$IDS;
  my $description = "$desc $count associated external database identifiers: $ids";
  my $xml = qq(
<entry id="$acc">
  <description>$description</description>
  <additional_fields>);
  foreach my $id (@$IDS) {
    $xml .= qq(
    <field name="synonym">$id</field>);
    $additional_fields{'synonym'}++;
  }
  $xml .= qq(
    <field name="species">$species</field>
    <field name="featuretype">Domain</field>
  </additional_fields>);
  $additional_fields{'species'}{$species}++;
  $additional_fields{'featuretype'}{'Domain'}++;
  $counter->();
  return $xml . '</entry>';
}


########################################################################## Families

sub dumpFamily {
  my $conf   = shift;
  my $FAMDB  = $conf->{'dbs'}->{'DATABASE_COMPARA'};
  my $dbname = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $t_sth  = $conf->{'dbh'}->prepare("select meta_value from $dbname.meta where meta_key='species.taxonomy_id'");
  $t_sth->execute;
  my $taxon_id = ($t_sth->fetchrow);
  return unless $taxon_id;

  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/Family_$dbname.xml";
  $file .= ".gz" unless $nogzip;
  my $start_time = time;
  my $db = 'core';
  my $fh;
  unless ($nogzip) {
    $fh = new IO::Zlib;
    $fh->open( "$file", "wb9" )
      || die("Can't open compressed stream to $file: $!");
  }
  else {
    open( FILE, ">$file" ) || die "Can't open $file: $!";
  }
  print "  Dumping $dbname to $file ... ", format_datetime($start_time), "\n";
  header( $dbname, $dbspecies, $db, $nogzip, $fh, $release );

 ( my $species = $conf->{'species'} ) =~ s/_/ /g;

  my $sth = $conf->{'dbh_compara'}->prepare(qq(
    select f.stable_id,
           f.description,
           count(*) as N,
           sum( (source_name = 'ENSEMBLGENE') and (m.genome_db_id = gd.genome_db_id) ) as ensembl_genes_species,
           sum( (source_name = 'ENSEMBLPEP' ) and (m.genome_db_id = gd.genome_db_id) ) as ensembl_peptides_species,
           sum(  source_name = 'ENSEMBLGENE'                                         ) as ensembl_genes,
           sum(  source_name = 'ENSEMBLPEP'                                          ) as ensembl_peptides,
           sum( (source_name = 'Uniprot/SPTREMBL' ) and (m.taxon_id = gd.taxon_id)   ) as uniprot_sptrembl_species,
           sum( (source_name = 'Uniprot/SWISSPROT') and (m.taxon_id = gd.taxon_id)   ) as uniprot_swissprot_species,
           sum(  source_name = 'Uniprot/SPTREMBL'                                    ) as uniprot_sptrembl,
           sum(  source_name = 'Uniprot/SWISSPROT'                                   ) as uniprot_swissprot
      from family as f, family_member as fm, member as m, genome_db as gd
     where f.family_id=fm.family_id and fm.member_id=m.member_id and
           gd.name = '$species'
     group by f.family_id 
    having ensembl_genes_species > 0));
  $sth->execute();
  my $X = $conf->{'authority'} || 'Ensembl';
  while( my(
    $fid, $desc, $total,
    $ensembl_genes_species, $ensembl_peptides_species, $ensembl_genes, $ensembl_peptides,
    $uniprot_sptrembl_species, $uniprot_swissprot_species,
    $uniprot_sptrembl, $uniprot_swissprot
  ) = $sth->fetchrow_array()) {
    my $desc = qq(Ensembl protein family $fid [$desc] has $total members: $ensembl_genes $X genes ($ensembl_genes_species in $species); $ensembl_peptides $X proteins ($ensembl_peptides_species in $species); $uniprot_swissprot UniProtKB/Swiss-Prot proteins ($uniprot_swissprot_species in $species); $uniprot_sptrembl UniProtUK/TrEMBL proteins ($uniprot_sptrembl_species in $species).);
    &p( FamilyLine($dbspecies,$fid,$desc,$counter ), $nogzip, $fh);
  }
  return footer( $counter->(),$nogzip,$fh);
}

sub FamilyLine {
  my($species, $fid, $desc, $counter) = @_;
  $species =~ s/_/ /;
  my $xml = qq(
<entry id="$fid">
  <description>$desc</description>
  <additional_fields>);
  $xml .= qq(
  <additional_fields>
    <field name="species">$species</field>
    <field name="featuretype">Family</field>
  </additional_fields>);
  $additional_fields{'species'}{$species}++;
  $additional_fields{'featuretype'}{'Family'}++;
  $counter->();
  return $xml . '</entry>';
}

########################################################################## Sequences

sub dumpSequence {
  my $conf = shift;
  my $sanger = sanger_project_names( $conf );
  my @misc_feat_disallowed = (); #features that we know we don't want to dump if we ever decide to do this (not implemented)
  my @name_order = (qw(name well_name clone_name sanger_project synonym embl_acc)); #defines the order of attribute_type we use to get the name for misc_features (comes from B::E::G::_clone.pm)
  my $COREDB   = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $OTFEATDB = $conf->{'dbs'}->{'DATABASE_OTHERFEATURES'};
  my %dbs      = ( 'core' => $COREDB );
  $dbs{'otherfeatures'} =  $OTFEATDB if $OTFEATDB;

  my $total_c;
 DB:
  foreach my $db ( sort { $b cmp $a } keys %dbs) {
    my $dbname    = $dbs{$db};
    my $counter   = make_counter(0);
    my $dbspecies = $conf->{'species'};
    my $file = $conf->{'directory'}."/Sequence_$dbname.xml";
    $file .= ".gz" unless $nogzip;
    my $start_time = time;
    my $fh;
    unless ($nogzip) {
      $fh = new IO::Zlib;
      $fh->open( "$file", "wb9" )
	|| die("Can't open compressed stream to $file: $!");
    }
    else {
      open( FILE, ">$file" ) || die "Can't open $file: $!";
    }
    print "  Dumping $dbname to $file ... ", format_datetime($start_time), "\n";
    header( $dbname, $dbspecies, $db, $nogzip, $fh, $release );

    #get all types of misc features - used for 'type' label
    my $feat_types = $conf->{'dbh'}->selectall_hashref(qq(
		  SELECT ms.code, ms.misc_set_id, ma.value as type 
                    FROM $dbname.attrib_type at, $dbname.misc_attrib ma, $dbname.misc_feature_misc_set mfms, $dbname.misc_set ms
                   WHERE at.attrib_type_id = ma.attrib_type_id
                     AND ma.misc_feature_id = mfms.misc_feature_id 
                     AND mfms.misc_set_id = ms.misc_set_id 
                     AND at.code = 'type'
                   GROUP by ms.code, ma.value), 'misc_set_id');
    if (%$feat_types) {
      my $mapsets = join ',', keys %$feat_types;
      #get al misc_features
      my $sth = $conf->{'dbh'}->prepare(qq(
       SELECT mf.misc_feature_id, sr.name, cs.name, mf.seq_region_start, mf.seq_region_end,
              mf.seq_region_end-mf.seq_region_start+1 as len, ms.misc_set_id, at.code, ma.value
         FROM $dbname.misc_feature_misc_set as ms,
              $dbname.misc_feature as mf,
              seq_region as sr,
              coord_system as cs,
              $dbname.misc_attrib as ma,
              $dbname.attrib_type as at
        WHERE cs.coord_system_id = sr.coord_system_id
          AND sr.seq_region_id = mf.seq_region_id 
          AND mf.misc_feature_id = ms.misc_feature_id
          AND ms.misc_set_id in ($mapsets)
          AND mf.misc_feature_id = ma.misc_feature_id
          AND ma.attrib_type_id = at.attrib_type_id
        ORDER by mf.misc_feature_id, at.code));
      $sth->execute();
      my ($old_ID,$old_sr,$old_sr_type,$old_start,$old_end,$old_len,$NAMES,$ftype);
      while( my($ID,$sr,$sr_type,$start,$end,$len,$ms_id,$code,$val) = $sth->fetchrow_array() ) {
	if($ID == $old_ID) {
	  if (! $ftype && $code eq 'type') {
	    $ftype = $feat_types->{$ms_id}{'type'};
	    #some hacks for the display of the type
	    $ftype =~ s/_/ /;
	    $ftype =~ s/arrayclone/clone/;
	    $ftype = ucfirst($ftype);
	  }
	  if (grep {$code eq $_} @name_order) {
	    push @$NAMES, [$code,$val];
	  }
	}
	else {
	  if ($old_ID) {
	    my ($name, $synonyms) = &sort_mf_names($NAMES,\@name_order);
	    &p( SeqLine($dbspecies,$old_sr,$old_sr_type,$old_start,$old_end,$old_len,$name,$synonyms,$ftype,$sanger,$counter), $nogzip, $fh);
	    $NAMES = undef;
	    $ftype = undef;
	  }
	  if (! $ftype && $code eq 'type') {
	    $ftype = $feat_types->{$ms_id}{'type'};
	    $ftype =~ s/_/ /;
	    $ftype =~ s/arrayclone/clone/;
	    $ftype = ucfirst($ftype);
	  }
	  if (grep {$code eq $_} @name_order) {
	    push @$NAMES, [$code,$val];
	  }
	  ($old_ID,$old_sr,$old_sr_type,$old_start,$old_end,$old_len) = ($ID,$sr,$sr_type,$start,$end,$len);
	}
      }
      my ( $name, $synonyms) = sort_mf_names($NAMES,\@name_order);
      &p( SeqLine($dbspecies,$old_sr,$old_sr_type,$old_start,$old_end,$old_len,$name,$synonyms,$ftype,$sanger,$counter), $nogzip, $fh);

    }
    if ($db ne 'core') {
      $total_c += footer( $counter->(),$nogzip,$fh);
      next DB;
    };

    #identify current default top level
    (my $current_cs_id) = $conf->{'dbh'}->selectrow_array(qq(
       SELECT cs.coord_system_id
         FROM coord_system cs, meta m
        WHERE cs.version = m.meta_value
          AND cs.name = 'chromosome'
          AND m.meta_key = 'assembly.default'));

    #get mappings between toplevel assemblies
    my $sth = $conf->{'dbh'}->prepare(qq(
       SELECT distinct sr1.name, sr1.length, sr2.name, cs2.coord_system_id
         FROM coord_system cs1, seq_region sr1, assembly a, seq_region sr2, coord_system cs2
        WHERE cs1.coord_system_id = sr1.coord_system_id
          AND sr1.seq_region_id = a.asm_seq_region_id
          AND a.cmp_seq_region_id = sr2.seq_region_id
          AND sr2.coord_system_id = cs2.coord_system_id
          AND cs1.name = 'chromosome'
          AND cs2.name = 'chromosome'));
    my $mapped_ids;
    $sth->execute;
    while (my ($new_name,$new_length,$prev_name,$prev_coord_system_id) =  $sth->fetchrow_array() ) {
      $mapped_ids->{$prev_coord_system_id}{$prev_name}{'name'}   = $new_name;
      $mapped_ids->{$prev_coord_system_id}{$prev_name}{'length'} = $new_length;
    }

    #get all seq_regions
    $sth = $conf->{'dbh'}->prepare(qq(
       SELECT sr.name, sr.length, cs.name, cs.coord_system_id
         FROM seq_region as sr, coord_system as cs
        WHERE sr.coord_system_id = cs.coord_system_id));
    $sth->execute();
    while( my($name,$length,$type,$cs_id) = $sth->fetchrow_array() ) {
      my ($prev_name,$prev_length);
      if ($type eq 'chromosome' && $cs_id != $current_cs_id) {
	# if an old seq_region is mapped to a new one use it...
	if ($mapped_ids->{$cs_id}{$name}) {
	  $prev_name   = $mapped_ids->{$cs_id}{$name}{'name'};
	  $prev_length = $mapped_ids->{$cs_id}{$name}{'length'};
	  if ($prev_name ne $name) { #don't dump identically named regions
	    print "WARNING: dumping assembly mapped seq_region $prev_name instead of $name - please check this is correct since this we havn't come across this before";
	    $name = $prev_name;
	    $length = $prev_length;
	  }
	}
	else {
	  #...otherwise ignore
	  #	warn "not dumping $name on coord_system $cs_id since it's an old assembly with no mapping";
	  next;
	}
      }
      my ($prev_name,$extra_IDS);
      my $ids = $prev_name ? "$prev_name$extra_IDS" : "$name$extra_IDS";
      &p( SeqLine($dbspecies,$name,$type,1,$length,$length,$name,[],$type,$sanger,$counter), $nogzip, $fh);
    }
    $total_c += footer( $counter->(),$nogzip,$fh);
  }
  return $total_c;
}

#decide which of the possible many name entries we should be using, the rest will be synonyms
sub sort_mf_names {
  my ($all_names, $name_order) = @_;
  my $name_to_use;
  foreach my $name_type ( @$name_order ) {
    unless ($name_to_use) {
      foreach my $name (@$all_names) {
	if ($name->[0] eq $name_type) {
	  $name_to_use = $name->[1];
	}
      }
    }
  }
  my @synonyms = map {$_->[1]} grep { $_->[1] ne $name_to_use } @$all_names;
  return $name_to_use, \@synonyms ;
}

sub SeqLine {
  my($species,$sr,$sr_type,$start,$end,$len,$name,$synonyms,$type,$sanger,$counter) = @_;
  $species =~ s/_/ /;
  print "WARNING: no type set for $name" unless $type;
  my $action = $len > 0.5e6 ? 'Overview' : 'View';
  my $r = "$sr:$start-$end";
  my $desc = ($name eq $sr) ? "$type $name has a length of $len bp" : "$type $name (length $len bp) is mapped to $sr_type $sr.";
  my $extra_desc = '';

  #deal with any synonyms
  if (@$synonyms) {
    $extra_desc = " It has EMBL accessions / synonyms of " . join(',',@$synonyms) . ".";
  }

 #deal with with Sanger Projects
  my %extra;
  foreach my $n ($name, @$synonyms) {
    foreach( keys %{$sanger->{$n}||{}} ) {
      $extra{$_}=1;
    }
  }
  if (%extra) {
    foreach my $k (keys %extra) {
      push @$synonyms, $k unless grep {$_ eq $k} @$synonyms;
    }
    $extra_desc .= " It is mapped to the following Sanger projects: ".join( ', ',sort keys %extra ) . ".";
  }

  $desc .= $extra_desc;

  my $xml = qq(
<entry id="$name">
  <description>$desc</description>);
  $xml .= qq(
  <additional_fields>
    <field name="species">$species</field>
    <field name="featuretype">Sequence</field>
    <field name="location">$r</field>
    <field name="action">$action</field>);
  foreach my $syn (@$synonyms) {
    $xml .= qq(
    <field name="synonym">$syn</field>);
    $additional_fields{'synonym'}++;
  }
  $xml .= qq(
  </additional_fields>);
  $additional_fields{'species'}{$species}++;
  $additional_fields{'featuretype'}{'Sequence'}++;
  $additional_fields{'location'}++;
  $additional_fields{'action'}++;
  $counter->();
  return $xml . '</entry>';
}

sub sanger_project_names {
  my $conf = shift;
  my %SPECIES = qw(
    Homo_sapiens Human Mus_musculus Mouse Danio_rerio Zebrafish
    Drosophila_melanogaster Drosophila Rattus_norvegicus Rat
  );
  my $sanger_species_name = $SPECIES{$conf->{'species'}};
  return {} unless $sanger_species_name;
  my $clones = {};
  my $dbh = DBI->connect("DBI:mysql:host=otterlive;port=3301;database=submissions", 'ottro', undef, {RaiseError => 1});
  unless( $dbh ) {
    warn "Can't connect to submissions database as 'read_only' ", DBI::errstr();
    return $clones;
  }
  my $sth = $dbh->prepare(
    "SELECT distinct a.project_name, a.accession 
       FROM project_acc a, project_dump d,
            sequence s, species_chromosome c
      WHERE a.sanger_id = d.sanger_id AND d.seq_id = s.seq_id
        AND s.chromosome_id = c.chromosome_id 
        AND c.species_name = '$sanger_species_name' AND a.accession != 'UNKNOWN'"
  );
  $sth->execute(  );
  while( my ($proj, $acc) = $sth->fetchrow() ) {
    $clones->{$acc}{$proj}=1;
  }
  return $clones;
}


########################################################################## Genes

sub dumpGene {
  use Data::Dumper;
  my $conf = shift;
  my $COREDB = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $SANGDB = $conf->{'dbs'}->{'DATABASE_VEGA'};
  my $ESTGENEDB = $conf->{'dbs'}->{'DATABASE_OTHERFEATURES'};
  my %DBS = ( 'core' => $COREDB );
  $DBS{'vega'}          = $SANGDB    if $SANGDB;
  $DBS{'otherfeatures'} = $ESTGENEDB if $ESTGENEDB;
  open O, ">$conf->{'directory'}/Gene.txt";
  my $core_xrefs;
 DB:
  foreach my $DB ( sort keys %DBS ) {
    my $gene_count = 0;
    warn "STARTING... $DB";
    my $DBNAME = $DBS{$DB};
    my $extra = $DB ne 'core' ? ";db=$DB" : '';
    my %xrefs = ();
    my %xrefs_desc = ();
    foreach my $type( qw(Gene Transcript Translation) ) {
      my $T = $conf->{'dbh'}->selectall_arrayref(
        "select ox.ensembl_id,
                x.display_label, x.dbprimary_acc, ed.db_display_name, es.synonym, x.description
           from ($DBNAME.object_xref as ox, $DBNAME.xref as x, $DBNAME.external_db as ed) left join $DBNAME.external_synonym as es on es.xref_id = x.xref_id
          where ox.ensembl_object_type = '$type' and ox.xref_id = x.xref_id and x.external_db_id = ed.external_db_id"
      );
      foreach ( @$T ) {
        $xrefs{$type}{$_->[0]}{$_->[3]}{$_->[1]} =1 if $_->[1];
        $xrefs{$type}{$_->[0]}{$_->[3]}{$_->[2]} =1 if $_->[2];
        $xrefs{$type}{$_->[0]}{$_->[3]}{$_->[4]} =1 if $_->[4];
        $xrefs_desc{$type}{$_->[0]}{$_->[5]}      =1 if $_->[5];
      }
      warn "XREF $type query done";
    }
    my %exons = ();
    my $T = $conf->{'dbh'}->selectall_arrayref(
      "select distinct t.gene_id, esi.stable_id
         from $DBNAME.transcript as t, $DBNAME.exon_transcript as et, $DBNAME.exon_stable_id as esi
        where t.transcript_id = et.transcript_id and et.exon_id = esi.exon_id"
    );
    foreach( @$T ) {
      $exons{$_->[0]}{$_->[1]}=1;
    }
    my $gene_info = $conf->{'dbh'}->selectall_arrayref("
      select gsi.gene_id, tsi.transcript_id, trsi.translation_id,
             gsi.stable_id as gsid, tsi.stable_id as tsid, trsi.stable_id as trsid,
             g.description, ed.db_display_name, x.dbprimary_acc,x.display_label, ad.display_label, ad.description, g.source, g.status, g.biotype
        from (((( $DBNAME.gene_stable_id as gsi, $DBNAME.gene as g,
             $DBNAME.transcript_stable_id as tsi,
             $DBNAME.analysis_description as ad,
             $DBNAME.transcript as t) left join
             $DBNAME.translation as tr on t.transcript_id = tr.transcript_id) left join
             $DBNAME.translation_stable_id as trsi on tr.translation_id = trsi.translation_id) left join
             $DBNAME.xref as x on g.display_xref_id = x.xref_id) left join
             $DBNAME.external_db as ed on ed.external_db_id = x.external_db_id
       where t.gene_id = gsi.gene_id and t.transcript_id = tsi.transcript_id and t.gene_id = g.gene_id and g.analysis_id = ad.analysis_id
       order by gsi.stable_id, tsi.stable_id
    ");
    warn "Gene info query done";
    my $old;
    foreach my $row (@$gene_info) {
      my($g,$t,$tr,$gs,$ts,$trs,$d,$ddb,$dpa,$dn,$a,$ad,$s,$st,$bt) = @$row;
      if ($DB eq 'core') {
	$core_xrefs->{$dn}{'display_xref'} = $ddb;
      }
      if( $old->{'g'} != $g ) {
        if( $old->{'g'} ) {
          print O &geneLine( $conf->{'species'},
			     $old->{'ex'},
			     $old->{'s'}.' '.$old->{'bt'},
			     $old->{'gs'},
			     $old->{'alt'},
			     $extra,
			     join( ' ', grep{$_}keys %{$old->{'i'}}),
			     $old->{'t'},
			     $old->{'tr'},
			     $old->{'e'},
			     $old->{'d'} );
	  $gene_count++;
        }
        $old = {
          'g'   => $g,
          'gs'  => $gs,
          'd'   => $d,
          'tr'  => {$trs?($trs=>1):()},
          't'   => {$ts ?($ts=>1) :()},
          'ex'  => {},
          'e'   => {},
          'i'   => {$gs=>1,$ts=>1,$trs=>1}, 
          'alt' => ($DB ne 'vega' && $dn) ? "($ddb: $dn)" : $dn ? "($dn)" : "(novel gene)",
          'a'   => $a,
          'ad'  => $ad,
          's'   => ucfirst($s),
          'st'  => $st,
          'bt'  => $bt,
	  'dn'  => $dn,
        };
	if (   ($DB ne 'vega')
	    || ($core_xrefs->{$dn}{'display_xref'})
            || ($core_xrefs->{$dn}{'display_xref'} !~ /'Clone_based'/) ) {
	  $old->{'i'}->{$d}=1;
	  $old->{'i'}->{$dpa}=1;
	  $old->{'i'}->{$dn}=1;
	}
        $old->{'s'}=~s/base/Base/;
        $old->{'ex'} = $exons{$g};
        foreach my $K (keys %{$exons{$g}}) { $old->{'i'}{$K} = 1; }
        foreach my $db( keys %{$xrefs{'Gene'}{$g}||{}} ) {
          foreach my $K( keys %{$xrefs{'Gene'}{$g}{$db}} ) {
	    $old->{'e'}{$db}{$K}=1;	
	    &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xrefs');
	  }
        }
        foreach my $db( keys %{$xrefs{'Transcript'}{$t}||{}} ) {
          foreach my $K( keys %{$xrefs{'Transcript'}{$t}{$db}} ) {
	    $old->{'e'}{$db}{$K}=1;	
	    &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xrefs');
	  }
        }
        foreach my $db( keys %{$xrefs{'Translation'}{$tr}||{}} ) {
          foreach my $K( keys %{$xrefs{'Translation'}{$tr}{$db}} ) {
	    $old->{'e'}{$db}{$K}=1;	
	    &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xrefs');
	  }
        }
	foreach my $K( keys %{$xrefs_desc{'Translation'}{$tr}} ) {
	  &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xref_desc');
	}
	foreach my $K( keys %{$xrefs_desc{'Transcript' }{$t }} ) {
	  &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xref_desc');
	}
	foreach my $K( keys %{$xrefs_desc{'Gene'       }{$g }} ) {
	  &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xref_desc');
	}
      } else {
        $old->{'t'}{$ts}=1;
        $old->{'tr'}{$trs}=1;
        $old->{'i'}{$ts}=1;
        $old->{'i'}{$trs}=1;
	foreach my $db( keys %{$xrefs{'Transcript'}{$t}||{}} ) {
          foreach my $K( keys %{$xrefs{'Transcript'}{$t}{$db}} ) {
	    $old->{'e'}{$db}{$K}=1;	
	    &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xrefs');
	  }
        }
        foreach my $db( keys %{$xrefs{'Translation'}{$tr}||{}} ) {
          foreach my $K( keys %{$xrefs{'Translation'}{$tr}{$db}} ) {
	    $old->{'e'}{$db}{$K}=1;	
	    &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xrefs');
	  }
        }
	foreach my $K( keys %{$xrefs_desc{'Translation'}{$tr}} ) {
	  &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xref_desc');
	}
	foreach my $K( keys %{$xrefs_desc{'Transcript' }{$t }} ) {
	  &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xref_desc');
	}
      }
    }
    print O &geneLine( $conf->{'species'},
		       $old->{'ex'},
		       $old->{'s'}.' '.$old->{'bt'},
		       $old->{'gs'},
		       $old->{'alt'},
		       $extra,
		       join( ' ', grep{$_}keys %{$old->{'i'}}),
		       $old->{'t'},
		       $old->{'tr'},
		       $old->{'e'},
		       $old->{'d'} );
    $gene_count++;
    print STDOUT "$gene_count $DB genes indexed\n";
  }

#  warn Dumper($core_xrefs->{'ARSE'});
  my $other_count = 0;
  my %current_stable_ids =();
  foreach my $type (qw(gene transcript translation)) {
    $current_stable_ids{$type}  = {map {@$_} @{$conf->{'dbh'}->selectall_arrayref( "select stable_id,1 from $COREDB.".$type."_stable_id" )}};
  }
  my $species = $conf->{'species'};
  my $sth = $conf->{'dbh'}->prepare( qq(
    select sie.type, sie.old_stable_id, if(isnull(sie.new_stable_id),'NULL',sie.new_stable_id), ms.old_release*1.0 as X, ms.new_release*1.0 as Y
      from $COREDB.mapping_session as ms, $COREDB.stable_id_event as sie
     where ms.mapping_session_id = sie.mapping_session_id and ( old_stable_id != new_stable_id or isnull(new_stable_id) )
     order by Y desc, X desc
  ));

  $sth->execute();
  my %mapping = ();
  while( my($type,$osi,$nsi) = $sth->fetchrow_array() ) {
    next if $current_stable_ids{$type}{$osi}; ## Don't need to cope with current IDS already searchable...
    $mapping{$type}{$osi}{$nsi}=1;
    if($mapping{$type}{$nsi}) {
      foreach( keys %{$mapping{$type}{$nsi}} ) {
        $mapping{$type}{$osi}{$_}=1;
      }
    }
  }
  foreach my $type ( keys %mapping ) {
    my $url = $type eq 'gene' ? 'Gene/Idhistory?g'
	    : $type eq 'transcript' ? 'Transcript/Idhistory?t'
	    : 'Transcript/Idhistory/Protein?protein';
    foreach my $osi ( keys %{$mapping{$type}} ) {
      my @current_sis = ();
      my @deprecated_sis = ();
      foreach ( keys %{$mapping{$type}{$osi}} ) {
	next if $osi eq $_;
        if( $current_stable_ids{$_} ) {
          push @current_sis,$_;
        } elsif( $_ ne 'NULL' ) {
          push @deprecated_sis,$_;
        }
      }
      if( @current_sis ) {
	$other_count++;
        print O join( "\t",
          (INC_SPECIES?"$species\t":"").qq(Ensembl $type),
          qq($osi),
          qq(/$species/$url=$osi),
          join( ' ', $osi, @current_sis, @deprecated_sis ),
          qq($type $osi is no longer in the Ensembl database but it has been mapped to the following current identifiers: @current_sis).
          ( @deprecated_sis ? "; and the following deprecated identifiers: @deprecated_sis" : '').
          ".\n"
        );
      } elsif( @deprecated_sis ) {
	$other_count++;
        print O join( "\t",
          (INC_SPECIES?"$species\t":"").qq(Ensembl $type),
          qq($osi),
          qq(/$species/$url=$osi),
          join( ' ', $osi, @deprecated_sis ),
          qq($type $osi is no longer in the Ensembl database but it has been mapped to the following identifiers: @deprecated_sis\n)
        );
      } else {
	$other_count++;
        print O join( "\t",
          (INC_SPECIES?"$species\t":"").qq(Ensembl $type),
          qq($osi),
          qq(/$species/$url=$osi),
          qq($osi),
          qq($type $osi is no longer in the Ensembl database and it has not been mapped to any newer identifiers\n)
        );
      }
    }
  }
  print STDOUT "$other_count other stable IDS indexed\n";
  $other_count = 0;
  my %unmapped_queries = (
    'None' => qq(
      select a.logic_name, e.db_display_name,
             uo.identifier, ur.summary_description,
             'Not mapped'
        from $COREDB.analysis as a, $COREDB.external_db as e, $COREDB.unmapped_object as uo,
             $COREDB.unmapped_reason as ur
       where a.analysis_id = uo.analysis_id and 
             uo.external_db_id = e.external_db_id and
             uo.unmapped_reason_id = ur.unmapped_reason_id and
               uo.ensembl_id = 0
    ),
    'Transcript' => qq(
      select a.logic_name, e.db_display_name,
             uo.identifier, ur.summary_description,
             concat( 'Transcript: ', tsi.stable_id, '; Gene: ',gsi.stable_id )
        from $COREDB.analysis as a, $COREDB.external_db as e, $COREDB.unmapped_object as uo,
             $COREDB.unmapped_reason as ur, $COREDB.transcript_stable_id as tsi,
             $COREDB.transcript as t, $COREDB.gene_stable_id as gsi
       where a.analysis_id = uo.analysis_id and 
             uo.external_db_id = e.external_db_id and
             uo.unmapped_reason_id = ur.unmapped_reason_id and
             uo.ensembl_id = t.transcript_id and
             uo.ensembl_object_type = 'Transcript' and
             t.transcript_id = tsi.transcript_id and
             t.gene_id       = gsi.gene_id
    ),
    'Translation' => qq(
      select a.logic_name, e.db_display_name, uo.identifier, ur.summary_description,
             concat( 'Protein: ',trsi.stable_id,'; Transcript: ', tsi.stable_id, '; Gene: ',gsi.stable_id )
        from $COREDB.analysis as a, $COREDB.external_db as e, $COREDB.unmapped_object as uo,
             $COREDB.unmapped_reason as ur, $COREDB.transcript_stable_id as tsi,
             $COREDB.translation as tr, $COREDB.translation_stable_id as trsi,
             $COREDB.transcript as t, $COREDB.gene_stable_id as gsi
       where a.analysis_id = uo.analysis_id and 
             uo.external_db_id = e.external_db_id and
             uo.unmapped_reason_id = ur.unmapped_reason_id and
             uo.ensembl_id = tr.translation_id and 
             tr.transcript_id = t.transcript_id and
             trsi.translation_id = tr.translation_id and
             uo.ensembl_object_type = 'Translation' and
             t.transcript_id = tsi.transcript_id and
             t.gene_id       = gsi.gene_id
    )
  );

  %unmapped_queries = (); #don't do these for now

  foreach my $FLAG (keys %unmapped_queries) {
    my $SQL = $unmapped_queries{$FLAG};
    my $sth = $conf->{'dbh'}->prepare($SQL);
    $sth->execute;
    while( my $T = $sth->fetchrow_arrayref() ) {
      print O join "\t",
        (INC_SPECIES?"$conf->{'species'}\t":"").qq(Unmapped feature),
        "$T->[1] $T->[2]",
        "/$conf->{'species'}/Location/Genome?ftype=Gene;id=$T->[2]",
        "$T->[2] $T->[4]",
        "$T->[3]; $T->[4]\n";
    }
  }
  close O;
}


sub check_and_store {
  my ($DB,$dn,$K,$core_xrefs,$old,$rec_type) = @_;
  if ($DB eq 'core') {
    $old->{'i'}{$K}=1;
    push @{$core_xrefs->{$dn}{$rec_type}}, $K;
  }

#enable filtering here
  elsif (0) {
#  elsif ($DB eq 'vega' ) {
    if (   ($core_xrefs->{$dn}{'display_xref'} !~ /'Clone_based'/)
        || (! grep {$_ eq $K} @{$core_xrefs->{$dn}{$rec_type}})
        || ($K =~ /OTT|ENS/)) {
      $old->{'i'}{$K}=1;
    }
  }
  else { $old->{'i'}{$K}=1; }
}

sub geneLine {
  my ($species, $exons, $X, $gid, $altid, $extra, $IDX, $transcripts, $peptides, $external_identifiers, $description )=@_;
  return if $gid eq '';
  my $T = scalar (keys %$transcripts);
  my $P = scalar (keys %$peptides);
  my $E = scalar (keys %$exons);
  my $EX = scalar (keys %$external_identifiers);
  my $desc = $description ? "Description: $description" : '';
  $IDX =~ s/\n/ /g;
#  if ($gid =~ /ENSG00000157399|OTTHUMG00000137358/) {
#    warn "indexing $gid with ",Data::Dumper::Dumper($IDX);
#  }
#  $EX =~ s/\n/ /g;
  return join( "\t",
    (INC_SPECIES?"$species\t":"").qq($X Gene),
    qq($gid $altid),
    qq(/$species/Gene/Summary?g=$gid$extra),
    qq($IDX),
    qq(<br />$desc\n)
    );
}


########################################################################## Regulatory Features

sub dumpRegulatoryFeature {
  my $conf = shift;
  my $FDB = $conf->{'dbs'}->{'DATABASE_FUNCGEN'};
  return unless $FDB;
  my $species = $conf->{'species'};

  my $T = $conf->{'dbh'}->selectall_arrayref(
    "select fs.feature_set_id, fs.name as f_set, fs.display_label as set_label,
            fts.name as set_type, fts.class as set_class, fts.description as set_desc,
            a.logic_name, ad.display_label as anal_name, ad.description as anal_desc
       from ( ($FDB.feature_set as fs left join $FDB.feature_type as fts on fs.feature_type_id = fts.feature_type_id)
  left join $FDB.analysis as a on a.analysis_id = fs.analysis_id)
  left join $FDB.analysis_description as ad on ad.analysis_id = a.analysis_id" );
  my $feature_sets = {};
  foreach( @$T ) {
    $feature_sets->{ $_->[0] } = {
      'name'  => $_->[1],
      'label' => $_->[2],
      'type'  => $_->[3],
      'class' => $_->[4],
      'desc'  => $_->[5],
      'logic' => $_->[6],
      'a_name'=> $_->[7],
      'a_desc'=> $_->[8]
    };
  }
  $T = $conf->{'dbh'}->selectall_arrayref( "select * from $FDB.feature_type" );
  my $feature_types = {};
  foreach( @$T ) {
    $feature_types->{ $_->[0] } = {
      'name'  => $_->[1],
      'class' => $_->[2],
      'desc'  => $_->[3]
    };
  }


  open A, ">$conf->{'directory'}/RegulatoryFeature.txt" unless scalar @$T == 0;


  my $v = sprintf '%s_%s',
    $SD->ENSEMBL_VERSION,
    $SD->get_config( $species, 'SPECIES_RELEASE_VERSION' )
  ;
  my $a = $SD->get_config( $species, 'ASSEMBLY_NAME' );


## Regulatory features...

  my $prefix = 'ENSR';
  if ($species =~/Mus/) {$prefix = 'ENSMUSR';}
  my $d = $conf->{'dbh'}->selectall_arrayref( 
    "select concat('$prefix', lpad(rf.stable_id, 11, 0)),
            sr.name, rf.bound_seq_region_start, rf.bound_seq_region_end, ft.name
       from $FDB.regulatory_feature rf, $FDB.seq_region sr, $FDB.coord_system cs,
            $FDB.feature_type ft, $FDB.feature_set fs
      where fs.name='RegulatoryFeatures' and fs.feature_set_id=rf.feature_set_id and
            rf.feature_type_id=ft.feature_type_id and rf.seq_region_id=sr.seq_region_id and
            sr.coord_system_id=cs.coord_system_id and cs.is_current=1
   group by rf.regulatory_feature_id"
  );

  foreach my $row ( @$d ) {
    my $r = $row->[1] .":".$row->[2] . "-" . $row->[3];
    print A join "\t", (INC_SPECIES?"$species\t":"")."Ensembl Regulatory Feature",
    $row->[0], "/$species/Regulation/Details?rf=$row->[0];r=$r;",
    $row->[0], qq($row->[4] regulatory feature.\n);
  }

## External Features...


  my $e = $conf->{'dbh'}->selectall_arrayref(
  "select ef.display_label, group_concat(distinct ft.name), count(distinct ef.external_feature_id),
          ft.description, ft.class, fs.name, sr.name, ef.seq_region_start, ef.seq_region_end,
          ef.seq_region_strand
    from  $FDB.feature_type ft, $FDB.external_feature ef, $FDB.feature_set fs, $FDB.seq_region sr,
          $FDB.coord_system cs,$FDB.status s, $FDB.status_name sn
    where ft.feature_type_id=ef.feature_type_id and fs.feature_set_id=ef.feature_set_id and
          fs.type='external' and ef.seq_region_id=sr.seq_region_id  and sr.coord_system_id=cs.coord_system_id
          and cs.is_current=1 and  s.table_name='feature_set' and s.table_id=fs.feature_set_id and
          s.status_name_id=sn.status_name_id and sn.name='MART_DISPLAYABLE'
 group by ef.display_label"
  );

  foreach my $f ( @$e) {
    my ($display_label, $f_name, $count, $f_desc, $f_class, $fs_name, $seq_region, $start, $end, $strand) = @$f;
    my ($description, $link);
    my $ids = $display_label;
    $ids .= ' '.$f_name unless $display_label eq $f_name;
    if ($count >> 1) {
     $link = "/$species/Location/Genome?ftype=RegulatoryFactor;id=$display_label;name=$f_name;";
    } else {
      # link miranda features to gene reg view other feats to region in detail
      if ( $f_class eq 'RNA'){
          my ($trans_id, $feat) = split(/:/,$display_label);
          $link = "/$species/Gene/Regulation?t=$trans_id;hid=$display_label";
      } else {
        $start = $start -=100;
        $end = $end +=100;
        my $region  =$seq_region .':' . $start . "-" . $end;
        my $renderer;
        if ($f_class =~/Search/){ $renderer = 'regulatory_regions_funcgen_search';}
        else {$renderer = 'regulatory_regions_funcgen_feature_set';}
        $link = "/$species/Location/View?r=$region;hid=$display_label;contigviewbottom=$renderer=normal";
      }
    }
     $description = "$display_label is a $f_class from $fs_name which hits the genome in $count locations\n";
    print A join "\t", (INC_SPECIES?"$species\t":""). $f_class,
    $display_label, $link, $ids, $description;
  }

  close A if scalar @$T >= 1;
}

sub make_counter {
  my $start = shift;
  return sub { $start++ }
}

sub header {
  my ( $dbname, $dbspecies, $dbtype, $nogzip, $fh, $release ) = @_;
  $dbspecies =~ s/_/ /;
  p("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>",$nogzip,$fh);
  p("<!DOCTYPE database [ <!ENTITY auml \"&#228;\">]>",$nogzip,$fh);
  p("<database>",$nogzip,$fh);
  p("<name>$dbname</name>",$nogzip,$fh);
  p("<description>Ensembl $dbspecies $dbtype database</description>",$nogzip,$fh);
  p("<release>$release</release>",$nogzip,$fh);
  p("",$nogzip,$fh);
  p("<entries>",$nogzip,$fh);
}

sub footer {
  my ($ecount,$nogzip, $fh, $release) = @_;
  p("</entries>",$nogzip,$fh);
  p("<entry_count>$ecount</entry_count>",$nogzip,$fh);
  p("</database>",$nogzip,$fh);
  print "  ...Dumped $ecount entries\n";
  if ($nogzip) {
    close(FILE) or die $!;
  }
  else {
    $fh->close();
  }
  return $ecount;
}

sub p {
  my ($str,$nogzip,$fh) = @_;

#  warn "string = $str";
#  warn "warn nogzip = $nogzip";
#  warn "fh = ".Data::Dumper::Dumper($fh);

  # TODO - encoding
  $str .= "\n";
  if ($nogzip) {
    print FILE $str or die "Can't write to file ", $!;
  }
  else {
    use Carp qw(cluck);
    cluck 'erre';
    print $fh $str or die "Can't write string: $str";
  }
}

sub format_datetime {
  my $t = shift;
  my ( $y, $m, $d, $ss, $mm, $hh ) = ( localtime($t) )[ 5, 4, 3, 0, 1, 2 ];
  $y += 1900;
  $d = "0" . $d if ( $d < 10 );
  my $ms = text_month($m);
  return sprintf "$d-$ms-$y %02d:%02d:%02d", $hh, $mm, $ss;
}

sub text_month {
  my $m = shift;
  my @months = qw[JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC];
  return $months[$m];
}
