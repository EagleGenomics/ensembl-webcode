#!/usr/local/bin/perl

#usage:
# ./indexXMLDumper --species=aaa,bbb --index=xxx,yyy (--debug) --log index.log
# 'ALL' can be used for both species and indexes
# The script will retry five times if it loses database connections, unless
# --debug is specified in which case it will exit.
# --dry_run|n does everything apart from actually write the xml [note that this
# option will delete any preexisting file]
# In the abscence of --debug option, STDOUT and STDERR are sent to a log file
# (dumping_log.log by default). If you run with --debug then output is sent to STDOUT:

# ./indexXMLDumper --species=ALL --index=ALL --debug                        #all output to STDOUT
# ./indexXMLDumper --species=ALL --index=ALL --debug -log all_debug_log.log #all output to all_debug_log.log
# ./indexXMLDumper --species=ALL --index=ALL                                #all output to dumping.log
# ./indexXMLDumper --species=ALL --index=ALL -log all_log.log               #all output to all_log.log

use strict;
package indexXMLDumper;

my $ENSEMBL_ROOT;

BEGIN {
  use FindBin qw($Bin);
  use File::Basename qw( dirname );
  $ENSEMBL_ROOT = dirname( $Bin );
  $ENSEMBL_ROOT =~ s/\/utils$//;
  unshift @INC, "$ENSEMBL_ROOT/conf";
  eval{ require SiteDefs };
  if ($@){ die "Can't use SiteDefs.pm - $@\n"; }
  map{ unshift @INC, $_ } @SiteDefs::ENSEMBL_LIB_DIRS;
}

use EnsEMBL::Web::SpeciesDefs;
use Data::Dumper;
use Getopt::Long;
use POSIX qw(strftime);

use constant INC_SPECIES => 0;
use CGI;

$| = 1;

my (@species,@indexes,$debug,$dry_run,$log);
GetOptions('species=s' => \@species,
	   'index=s'   => \@indexes,
	   'debug'     => \$debug,
	   'dry_run|n' => \$dry_run,
	   'log=s'     => \$log,
	 );

(@species) = split ',',@species[0];
(@indexes) = split ',',@indexes[0];

#redirect STDOUT and maybe STDERR to a file
$log ||= $debug ? '>-' : 'dumping_log.log';
open (LOG,    ">$log") or die "Can't open $log: $!";
unless ($debug) {
  open (STDERR, ">&LOG") or die "Can't open $log: $!";
}

our $SD = EnsEMBL::Web::SpeciesDefs->new();
our $release = $SD->ENSEMBL_VERSION;
our $nogzip = 1;    #try setting to 0 for on the fly gzipping (not tested)?
our %cross_references;  #get a set of external_dbs so we can make sure we link to them all correctly if we ever need to

## HACK 1 - if the INDEX is set to all grab all dumper methods...
@indexes = map { /dump(\w+)/?$1:() } keys %indexXMLDumper:: if $indexes[0] eq 'ALL';

## HACK 2 - if the SPECIES is set to ALL grab stuff from config...
my %X = %{$SD->ENSEMBL_SPECIES_ALIASES};
my $input_c =  @species;
if( $species[0] eq 'ALL' ) {
  @species = @{$SD->ENSEMBL_DATASETS}
} else {
  @species = grep {$_} map { $X{lc($_)} } @species;
  if (@species ne $input_c) {
    print LOG "WARNING - one or more of your species names is not recognised, please check your spelling\n";
    exit;
  }
}

# EnsEMBL::Web::IndexSupport takes path to conf, path to files, species
my $conf = {};
my $dir = $debug ? 'input' : "/nfs/eureka/data/ensembl_$release";
mkdir $dir, 0777 unless -e 'input';

my $start_time = time;
my $total_c;
foreach my $index (@indexes) {
  my $start = time;
  $conf->{'directory'} = "$dir/ensembl_$index";
  mkdir $conf->{'directory'}, 0777 unless -e  $conf->{'directory'};
  foreach my $species ( @species ) {
    $conf->{'species'}   = $species;
    $conf->{'authority'} = $SD->get_config($species,'AUTHORITY');
    my %dbs = %{$SD->get_config($species,'databases')||{}};
    $conf->{'dbs'}       = { map { ($_,$dbs{$_}{NAME}) } keys %dbs };
    $conf->{'dbs'}{'DATABASE_COMPARA'} = 'ensembl_compara_'.$SD->ENSEMBL_VERSION;
    my $core = $dbs{'DATABASE_CORE'};
    my $no_success = 1;
    my $c;
    print LOG "Starting: $index $species\n";
    while ($no_success) {
      $c++;
      $conf->{'dbh'} = DBI->connect( "dbi:mysql:$core->{'NAME'};host=$core->{'HOST'};port=$core->{'PORT'}", $core->{'USER'}, $core->{'PASS'}, { PrintError => 0, RaiseError => 0} );
      if ($index eq 'Family') {
	$conf->{'dbh_compara'} = DBI->connect( "dbi:mysql:ensembl_compara_".$SD->ENSEMBL_VERSION.";host=ensdb-1-13;port=5307", $core->{'USER'}, $core->{'PASS'} );
      }
      my $function = "dump$index";
      no strict "refs";
      eval {
	$total_c += &$function( $conf );
      };
      if ($@) {
	unless ($debug) {
	  if ($c < 6) {
	    print LOG "WARNING: Error when dumping, will retry in 5 minutes (mysql error is ".$conf->{'dbh'}->errstr().", other errors are $@)\n";
	    sleep (5*60);}
	  else {
	    print LOG "WARNING: Error when dumping. I've retried five times and am moving on, you need to retry this later (error is ".$conf->{'dbh'}->errstr().")\n";
	    $no_success = 0;
	  }
	}
	else {
	   print LOG "WARNING: Error when dumping. Exiting since in debug mode (mysql error is ".$conf->{'dbh'}->errstr().", other errors are $@)\n";
	   exit;
	 }
      }
      else {
	$no_success = 0;
      }
    }
  }
  print LOG "\nTime for $index is " . &elapsed_time($start) . "\n";
}

print LOG "\nCross references are:\n",Dumper(\%cross_references) if %cross_references;
print LOG "\nDumped $total_c records in total\n";
print LOG "\nTotal time for dumping " . &elapsed_time($start_time) . "\n";
exit;

## Now for all the dump functions...............................

########################################################################## Markers

sub dumpMarker {
  my $conf = shift;
  my $dbname    = $conf->{'dbs'}{'DATABASE_CORE'};
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${dbname}_Marker.xml";
  $file .= ".gz" unless $nogzip;
  my $start_time = time;
  my $db = 'core';
  my $fh;
  unless ($nogzip) {
    $fh = new IO::Zlib;
    $fh->open( "$file", "wb9" )
      or die("Can't open compressed stream to $file: $!");
  }
  else {
    open( FILE, ">$file" ) or die "Can't open $file: $!";
  }
  print LOG "  Dumping $dbname to $file ... ", format_datetime($start_time), "\n";
  header( $dbname, $dbspecies, $db, $nogzip, $fh, $release );
  my $sth = $conf->{'dbh'}->prepare("
   SELECT m.marker_id, ms2.name, ms1.name
     FROM marker_synonym as ms1, marker as m
LEFT JOIN marker_synonym as ms2 on ms2.marker_synonym_id = m.display_marker_synonym_id
    WHERE ms1.marker_id = m.marker_id
 ORDER BY m.marker_id
  ");

  $sth->execute( );
  my $names  = [];
  my $old_ID = 0;
  my ($ID,$marker,$synonym);
  my $params = { contigviewbottom => 'marker_core_marker=normal'}; #used to switch on track by default
  while( ($ID,$marker,$synonym) = $sth->fetchrow_array()){
    $marker = $synonym unless $marker;
    if($ID == $old_ID) {
      push @$names, $synonym;
    } else {
      if ($old_ID) {
	&p( markerLine( $dbspecies, $names, $params, $counter ), $nogzip, $fh);
      }
      $names    = [ $synonym ];
      $old_ID  = $ID;
    }
  }
  &p( markerLine( $dbspecies, $names, $params, $counter ), $nogzip, $fh);
  return footer( $counter->(),$nogzip,$fh);
}

sub markerLine {
  my( $species, $IDS, $params, $counter ) = @_;
  $species =~ s/_/ /;
  my @synonyms = sort @$IDS;
  my $key = pop @synonyms;
  my $desc = 'A marker with '.@synonyms.' synonym';
  $desc .= 's' if (@synonyms > 1);
  $desc .= 's' unless (@synonyms);
  return '' unless $key;
  my $xml = qq(
<entry id="$key">
  <description>$desc</description>
  <additional_fields>);
  foreach my $syn (@synonyms) {
    $xml .= qq(
    <field name="synonym">$syn</field>);
  }
  $xml .= qq(
    <field name="species">$species</field>
    <field name="featuretype">Marker</field>
);
  while (my ($param,$value) = each %$params) {
    $xml .= qq(
    <field name="$param">$value</field>);
  }
  $xml .= qq(
  </additional_fields>);
  $counter->();
  return $xml . '</entry>';
}


########################################################################## QTLs

sub dumpQTL {
  my $conf = shift;
  my $dbname    = $conf->{'dbs'}{'DATABASE_CORE'};
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${dbname}_QTL.xml";
  $file .= ".gz" unless $nogzip;
  my $start_time = time;
  my $db = 'core';
  my $fh;
  unless ($nogzip) {
    $fh = new IO::Zlib;
    $fh->open( "$file", "wb9" )
      or die("Can't open compressed stream to $file: $!");
  }
  else {
    open( FILE, ">$file" ) or die "Can't open $file: $!";
  }
  print LOG "  Dumping $dbname to $file ... ", format_datetime($start_time), "\n";
  header( $dbname, $dbspecies, $db, $nogzip, $fh, $release );
  my $sth = $conf->{'dbh'}->prepare("
 select c.name as chr, qf.seq_region_start, qf.seq_region_end,
        a.logic_name as analysis, q.qtl_id,
        q.trait, qs.source_database, qs.source_primary_id,
        fms1.source as fm1_source, fms1.name as fm1_name,
        fms2.source as fm2_source, fms2.name as fm2_name,
        pms.source  as pm_source,  pms.name  as pm_name
   from ((((((seq_region as c, qtl_feature as qf, qtl_synonym as qs,
        analysis as a, qtl as q) left join marker as fm1 on
        fm1.marker_id = q.flank_marker_id_1) left join marker_synonym as fms1 on
        fm1.display_marker_synonym_id = fms1.marker_synonym_id) left join marker as fm2 on
        fm2.marker_id = q.flank_marker_id_2) left join marker_synonym as fms2 on
        fm2.display_marker_synonym_id = fms2.marker_synonym_id) left join marker as pm on
        pm.marker_id = q.peak_marker_id) left join marker_synonym as pms on
        pm.display_marker_synonym_id = pms.marker_synonym_id 
  where c.seq_region_id = qf.seq_region_id and qs.qtl_id = q.qtl_id and 
        qf.analysis_id = a.analysis_id and qf.qtl_id = q.qtl_id
  ");
  $sth->execute();
  my $desc    = '';
  my $old_qtl = 0;
  my $old_ID  = '';
  my $old_pos = '';
  my $old_action;
  my $IDS     = []; 
  my $scale           = $SD->ENSEMBL_GENOME_SIZE || 1;
  my $max_length = $scale *= 1e6;
  while( my $T = $sth->fetchrow_hashref() ){
    if($T->{qtl_id} eq $old_qtl) {
      push @$IDS, $T->{source_primary_id};
      $desc .= " $T->{source_database}:$T->{source_primary_id}";
    } else {
      if ($old_ID) {
	&p( QTLLine( $dbspecies, $old_ID, $old_pos, $old_action, $IDS, $desc, $counter ), $nogzip, $fh);
      }
      $IDS = [ "$T->{trait} $T->{source_primary_id}" ];
      push @$IDS, $T->{fm1_name} if $T->{fm1_name};
      push @$IDS, $T->{fm2_name} if $T->{fm2_name};
      push @$IDS, $T->{pm_name}  if $T->{pm_name};
      $old_ID = $T->{pm_name};
      $old_pos = "$T->{chr}:".($T->{seq_region_start}-1e4).'-'.($T->{seq_region_end}+1e4);
      $old_action = $T->{seq_region_end}-$T->{seq_region_start} > $max_length ? 'Overview' : 'View';
      $desc       = "QTL exhibiting '$T->{trait}' has ";
      my $f2 = $T->{pm_name} ? 1 : 0;
      if( $T->{fm1_name} || $T->{fm2_name} ) {
        my $f1= ($T->{fm1_name}) && ($T->{fm2_name}) ? 1 : 0;
        $desc.='flanking marker'.($f1?'s ':' ').$T->{fm1_name}.($f1?' and ':'').$T->{fm2_name}.($f2?'; ':'');
      }
      if($f2) {
        $desc.= "peak marker $T->{pm_name};";
      }
      $desc.=" and names: $T->{source_database}:$T->{source_primary_id}";
      $old_qtl = $T->{qtl_id};
    }
  }
  &p( QTLLine( $dbspecies, $old_ID, $old_pos, $IDS, $desc, $counter ), $nogzip, $fh);
  return footer( $counter->(),$nogzip,$fh);

}

sub QTLLine {
  my ($species, $key, $pos, $action, $IDS, $desc, $counter ) = @_;
  return '' unless $key;
  $species =~ s/_/ /;
  my $xml = qq(
<entry id="$key">
  <description>$desc</description>
  <additional_fields>);
  foreach my $id (@$IDS) {
    $xml .= qq(
    <field name="synonym">$id</field>);
  }
  $xml .= qq(
    <field name="action">$action</field>
    <field name="species">$species</field>
    <field name="featuretype">QTL</field>
    <field name="location">$pos</field>
  </additional_fields>);
  $counter->();
  return $xml . '</entry>';
}


########################################################################## SNP Phenotypes

sub dumpSNPPhenotype {
  my $conf = shift;
  my $SNPDB = $conf->{'dbs'}->{'DATABASE_VARIATION'};
  return unless $SNPDB;
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${SNPDB}_SNPPhenotype.xml";
  $file .= ".gz" unless $nogzip;
  my $start_time = time;
  my $db = 'variation';
  my $fh;
  unless ($nogzip) {
    $fh = new IO::Zlib;
    $fh->open( "$file", "wb9" )
      or die("Can't open compressed stream to $file: $!");
  }
  else {
    open( FILE, ">$file" ) or die "Can't open $file: $!";
  }
  print LOG "  Dumping $SNPDB Phenotype info to $file ... ", format_datetime($start_time), "\n";
  header( $SNPDB, $dbspecies, 'variation', $nogzip, $fh, $release );

  #phenotype info
  my $phenotype_info = $conf->{'dbh'}->selectall_hashref("select description, phenotype_id from $SNPDB.phenotype",'description');
  foreach my $phen (keys %$phenotype_info) {
    &p( SNPPhenLine( $dbspecies, $phen, $phenotype_info->{$phen}{'phenotype_id'}, $counter ), $nogzip, $fh);
  }

  return footer( $counter->(),$nogzip,$fh);
}

sub SNPPhenLine {
  my ($species, $name, $id, $counter ) = @_;
  $species =~ s/_/ /;
  my $xml = qq(
<entry id="$id">
  <description>$name</description>
  <additional_fields>);
  $xml .= qq(
    <field name="species">$species</field>
    <field name="featuretype">Phenotype</field>
  </additional_fields>);
  $counter->();
  return $xml . '</entry>';
}

########################################################################## SNPs

sub dumpSNP {
  my $conf = shift;
  my $SNPDB = $conf->{'dbs'}->{'DATABASE_VARIATION'};
  return unless $SNPDB;
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${SNPDB}_SNP.xml";
  $file .= ".gz" unless $nogzip;
  my $start_time = time;
  my $db = 'variation';
  my $fh;
  unless ($nogzip) {
    $fh = new IO::Zlib;
    $fh->open( "$file", "wb9" )
      or die("Can't open compressed stream to $file: $!");
  }
  else {
    open( FILE, ">$file" ) or die "Can't open $file: $!";
  }
  print LOG "  Dumping $SNPDB SNPs to $file ... ", format_datetime($start_time), "\n";
  header( $SNPDB, $dbspecies, 'variation', $nogzip, $fh, $release );

  #SNPs
  my $sources = { map { @$_ } @{$conf->{'dbh'}->selectall_arrayref( "select source_id, name from $SNPDB.source" )} };
  my %snp_extra = map { ($_->[0] => $_) }
    @{$conf->{'dbh'}->selectall_arrayref(
      "select va.variation_id,
              group_concat( distinct va.local_stable_id SEPARATOR '; ') as lsi,
              group_concat( distinct va.study           SEPARATOR '; ') as st,
              group_concat( distinct va.associated_gene SEPARATOR '; ') as gn,
              group_concat( distinct va.variation_names SEPARATOR '; ') as vars,
              group_concat( distinct
                if(
                  isnull(p.name),
                  description,
                  concat( p.description,' (',p.name,')' )
                )
                SEPARATOR '; '
              ) as phen
         from $SNPDB.variation_annotation as va left join
              $SNPDB.phenotype as p on p.phenotype_id = va.phenotype_id
        group by va.variation_id
        order by va.variation_id"
    )};

  my $sth = $conf->{'dbh'}->prepare(
    "SELECT vf.variation_id, vf.variation_name, vf.source_id, group_concat(vs.source_id, ' ',vs.name), vf.consequence_type
       FROM $SNPDB.variation_feature vf left join $SNPDB.variation_synonym vs on vf.variation_id = vs.variation_id group by vf.variation_id"
  );
  $sth->execute() or die "Error:", $DBI::errstr;
  while ( my $rowcache = $sth->fetchall_arrayref( undef, 10_000 ) ) {
    while ( my $row = shift( @{$rowcache} ) ) {
      my $vf_id = $row->[0];
      my $name  = $row->[1];
      my %synonyms;
      my $syn_c = 0;
      foreach my $syn (split /,/, @$row->[3]) {
	my ($id,$sname) = split / /,$syn;
	$synonyms{$sname} = $sources->{$id};
	$syn_c++;
      }
      my (@K, $synonym_text);
      foreach my $syn (keys %synonyms) {
	push @K, $syn;
	$synonym_text .= $synonyms{$syn}.':'.$syn.' ';
      }

      my $snp_source = $sources->{ $row->[2] };
      my $extra      = '';
      my $x = $snp_extra{$vf_id};
      if( $x ) {
	push @K,$x->[1],$x->[3],$x->[4];
	$extra = '; and is associated with following phenotypes:'. $x->[4].','.$x->[6];
	if( $x->[1] ) {
	  $extra .= sprintf ', through %s', $x->[1];
	}
	if( $x->[2] ) {
	  $extra .= sprintf ', through study(s): %s, and associated with following gene(s): %s', $x->[2], $x->[3];
	}
      }
      my $desc = sprintf( "A %s SNP %s%s",
			  $snp_source,
			  $syn_c > 1 ? "with $syn_c synonyms: $synonym_text"
			: $syn_c     ? "with one synonym: $synonym_text"
		        :             "with no synonyms",
			  $extra
			);
      &p( SNPLine( $dbspecies, $name, \@K, $snp_source, $desc, $counter ), $nogzip, $fh);

    }
  }
  return footer( $counter->(),$nogzip,$fh);
}

sub SNPLine {
  my ($species, $name, $IDS, $source, $desc, $counter ) = @_;
  $species =~ s/_/ /;
  my $xml = qq(
<entry id="$name">
  <description>$desc</description>
  <additional_fields>);
  foreach my $id (@$IDS) {
    $xml .= qq(
    <field name="synonym">$id</field>);
  }
  $xml .= qq(
    <field name="species">$species</field>
    <field name="featuretype">SNP</field>
    <field name="source">$source</field>
  </additional_fields>);
  $counter->();
  return $xml . '</entry>';
}

########################################################################## StructuralVariations

sub dumpStructuralVariations {
  my $conf = shift;
  my $SNPDB = $conf->{'dbs'}->{'DATABASE_VARIATION'};
  return unless $SNPDB;
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${SNPDB}_StructuralVariations.xml";
  $file .= ".gz" unless $nogzip;
  my $start_time = time;
  my $db = 'variation';
  my $fh;
  unless ($nogzip) {
    $fh = new IO::Zlib;
    $fh->open( "$file", "wb9" )
      or die("Can't open compressed stream to $file: $!");
  }
  else {
    open( FILE, ">$file" ) or die "Can't open $file: $!";
  }
  print LOG "  Dumping $SNPDB to $file ... ", format_datetime($start_time), "\n";
  header( $SNPDB, $dbspecies, 'variation', $nogzip, $fh, $release );

  my $scale           = $SD->ENSEMBL_GENOME_SIZE || 1;
  my $max_length      = $scale *= 1e6;

  my $T = $conf->{'dbh'}->selectall_arrayref("
    select v.structural_variation_id,
           v.variation_name,
           s.name,
           s.description,
           r.name,
           v.seq_region_start,
           v.seq_region_end
      from $SNPDB.structural_variation as v, $SNPDB.source as s, $SNPDB.seq_region as r
     where s.source_id = v.source_id and r.seq_region_id = v.seq_region_id
     order by v.structural_variation_id"
  );
  foreach my $row ( @$T ) {
    my $id = $row->[1];
    my $location = $row->[4] .":" . $row->[5] ."-". $row->[6];
    my $length = $row->[6] - $row->[7];
    my $action = ($length >> $max_length) ? 'Overview' : 'View';
    my $params = ($length >> $max_length) ? { 'cytoview' => 'variation_feature_structural=normal' }
                                          : { 'contigviewbottom' => 'variation_feature_structural=normal' };
    my $desc = qq(A structural variation from $row->[2], identified by $row->[3]. This variation has been mapped to chromosome $row->[4], from $row->[5] to $row->[6]. );
    &p( StrucVarLine( $dbspecies, $id, $location, $desc, $action, $params, $counter ), $nogzip, $fh);
  }
  return footer( $counter->(),$nogzip,$fh);
}

sub StrucVarLine {
  my ($species, $id, $location, $desc, $action, $params, $counter ) = @_;
  $species =~ s/_/ /;
  my $xml = qq(
<entry id="$id">
  <description>$desc</description>
  <additional_fields>);
  $xml .= qq(
    <field name="species">$species</field>
    <field name="featuretype">StructuralVariation</field>
    <field name="location">$location</field>
    <field name="action">$action</field>);
  while (my ($param,$value) = each %$params) {
    $xml .= qq(
    <field name="$param">$value</field>);
  }
  $xml .= qq(
  </additional_fields>);
  $counter->();
  return $xml . '</entry>';
}


########################################################################## Similarity features

sub dumpGenomicAlignment {
  my $conf    = shift;
  my $dbspecies = $conf->{'species'};
  my $COREDB  = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $ESTDB   = $conf->{'dbs'}->{'DATABASE_OTHERFEATURES'};
  my $CDNADB  = $conf->{'dbs'}->{'DATABASE_CDNA'};
  my %dbs      = ( 'core' => $COREDB );
  $dbs{'otherfeatures'} = $ESTDB  if $ESTDB;
  $dbs{'cdna'}          = $CDNADB if $CDNADB;
  my %tables = (
    'dna_align_feature'     => [ 'DnaAlignFeature',     'DNA alignment feature' ],
    'protein_align_feature' => [ 'ProteinAlignFeature', 'Protein alignment feature' ]
  );
  my $total_af_c;
  foreach my $db ( sort { $b cmp $a } keys %dbs) {
    my $counter    = make_counter(0);
    my $dbname     = $dbs{$db};
    my $file       = $conf->{'directory'}."/${dbname}_GenomicAlignment.xml";
    $file         .= ".gz" unless $nogzip;
    my $start_time = time;
    my $fh;
    unless ($nogzip) {
      $fh = new IO::Zlib;
      $fh->open( "$file", "wb9" ) or die("Can't open compressed stream to $file: $!");
    }
    else {
      open( FILE, ">$file" ) or die "Can't open $file: $!";
    }
    print LOG "  Dumping $dbname to $file ... ", format_datetime($start_time), "\n";
    header( $dbname, $dbspecies, $db, $nogzip, $fh, $release );

    foreach my $table ( keys %tables ) {
      my $source = $tables{ $table }[0];
      $source .= ";db=$db" unless $db eq 'core';
      my $type   = $tables{ $table }[1];
      my $sth    = $conf->{'dbh'}->prepare(
	"select ad.display_label, a.logic_name, ad.displayable, t.hit_name, ad.web_data, edb.db_name, count(*) as hits
                from (($dbname.analysis as a, $dbname.$table as t) left join
                     $dbname.analysis_description ad on a.analysis_id = ad.analysis_id) 
           left join $dbname.external_db edb on t.external_db_id = edb.external_db_id
               where a.analysis_id = t.analysis_id
                 and ad.displayable = 1
               group by ad.display_label, t.hit_name");
      $sth->execute();
      my $c = 0;
      while( my( $label, $logic_name, $displayable, $hid, $webdata, $db_name, $count  ) = $sth->fetchrow_array ) {
	my $wd = eval($webdata);
	next if $wd->{$table}{'do_not_display'};
	next unless $displayable;
	$c++;
	$label ||= '';
	my $desc = "$label $hid hits the genome in $count locations.";
	(my $track_name = $table) =~ s/feature//;
	my $renderer = $track_name . $db . '_' . lc($logic_name) . '=stack' ;
	my $params = { 'contigviewbottom' => $renderer };
	&p( GenomicAlignmentLine( $dbspecies, $hid, $desc, $db_name, $db, $tables{$table}->[0], $params, $counter ), $nogzip, $fh);
      }
      print LOG "  ...Dumped $c $table entries\n";
    }
    if ($db eq 'cdna') {
      my $sth    = $conf->{'dbh'}->prepare(
	"select ad.display_label, uo.identifier,  ur.summary_description, 'Unmapped feature'
           from $dbname.unmapped_object uo, $dbname.unmapped_reason ur, $dbname.analysis a 
                left join $dbname.analysis_description ad on a.analysis_id = ad.analysis_id
          where a.analysis_id = uo.analysis_id
            and uo.unmapped_reason_id = ur.unmapped_reason_id");
      $sth->execute();
      my $c++;
      while (my ($label, $hid, $reason, $type) = $sth->fetchrow_array ) {
	$c++;
	$label ||= '';
	my $desc = "$label $hid fails to map to the genome. Reason: $reason.";
	&p( GenomicAlignmentLine( $dbspecies, $hid, $desc, undef, $db, 'Unmapped feature', {}, $counter ), $nogzip, $fh);
      }
      print LOG "  ...Dumped $c Unmapped features\n";
    }
    $total_af_c += footer( $counter->(),$nogzip,$fh);
  }
  return $total_af_c;
}

sub GenomicAlignmentLine {
  my ($species, $id, $desc, $db_name, $db, $ftype, $params, $counter ) = @_;
  $species =~ s/_/ /;
  my $xml = qq(
<entry id="$id">
  <description>$desc</description>);
  if ($db_name) {
    $xml .= qq(
  <cross_references>
    <ref dbname="$db_name" dbkey="$id"/>
  </cross_references>);
    $cross_references{$db_name}++;
  }
  $xml .= qq(
  <additional_fields>
    <field name="species">$species</field>
    <field name="featuretype">$ftype</field>);
  unless ($db eq 'core') {
    $xml .= qq(
    <field name="db">$db</field>);
  }
  while (my ($param,$value) = each %$params) {
    $xml .= qq(
    <field name="$param">$value</field>);
  }
  $xml .= qq(
  </additional_fields>);
  $counter->();
  return $xml . '</entry>';
}


########################################################################## OligoProbes

sub dumpOligoProbe {
  my $conf = shift;
  my $FUNCDB = $conf->{'dbs'}->{'DATABASE_FUNCGEN'};
  return unless $FUNCDB;
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${FUNCDB}_OligoProbe.xml";
  $file .= ".gz" unless $nogzip;
  my $start_time = time;
  my $db = 'funcgen';
  my $fh;
  unless ($nogzip) {
    $fh = new IO::Zlib;
    $fh->open( "$file", "wb9" )
      or die("Can't open compressed stream to $file: $!");
  }
  else {
    open( FILE, ">$file" ) or die "Can't open $file: $!";
  }
  print LOG "  Dumping $FUNCDB to $file ... ", format_datetime($start_time), "\n";
  header( $FUNCDB, $dbspecies, $db, $nogzip, $fh, $release );

  my $sth    = $conf->{'dbh'}->prepare(
    "select ps.name, count(distinct pf.probe_feature_id) as hits, a.vendor
        from $FUNCDB.probe_set ps, $FUNCDB.probe p, $FUNCDB.probe_feature pf, $FUNCDB.array_chip ac, $FUNCDB.array a, $FUNCDB.status s, $FUNCDB.status_name sn
      where sn.name='MART_DISPLAYABLE'
        and sn.status_name_id=s.status_name_id
        and s.table_name='array'
        and s.table_id=a.array_id
        and ps.probe_set_id = p.probe_set_id
        and p.probe_id = pf.probe_id
        and p.array_chip_id = ac.array_chip_id
        and ac.array_id = a.array_id
      group by ps.name, a.vendor"
  );
  $sth->execute();
  while( my( $hid, $count, $type ) = $sth->fetchrow_array ) {
    next unless $hid;
    my $desc =  qq($type probeset $hid hits the genome in $count locations.);
    &p( OligoProbeLine($dbspecies,$hid,$desc,'pset',$db,$counter ), $nogzip, $fh);
  }

  my $sth    = $conf->{'dbh'}->prepare(
    "select group_concat(distinct p.name), count(distinct pf.probe_feature_id) as hits, a.vendor
        from $FUNCDB.probe p, $FUNCDB.probe_feature pf, $FUNCDB.array_chip ac, $FUNCDB.array a, $FUNCDB.status s, $FUNCDB.status_name sn
      where sn.name='MART_DISPLAYABLE'
        and sn.status_name_id=s.status_name_id
        and s.table_name='array'
        and s.table_id=a.array_id
        and p.probe_set_id is NULL
        and p.probe_id = pf.probe_id
        and p.array_chip_id = ac.array_chip_id
        and ac.array_id = a.array_id
      group by p.probe_id, a.vendor"
  );
  $sth->execute();
  while( my( $hid, $count, $type ) = $sth->fetchrow_array ) {
    next unless $hid;
    my $desc = qq($type probe $hid hits the genome in $count locations.);
    &p( OligoProbeLine($dbspecies,$hid,$desc,'probe',$db,$counter ), $nogzip, $fh);
  }
  return footer( $counter->(),$nogzip,$fh);
}

sub OligoProbeLine {
  my ($species,$hid,$desc,$pset,$db,$counter) = @_;
  $species =~ s/_/ /;
  my $xml = qq(
<entry id="$hid">
  <description>$desc</description>);
  $xml .= qq(
  <additional_fields>
    <field name="species">$species</field>
    <field name="featuretype">ProbeFeature</field>
    <field name="db">$db</field>
    <field name="ptype">$pset</field>
  </additional_fields>);
  $counter->();
  return $xml . '</entry>';
}


########################################################################## Domains

sub dumpDomain {
  my $conf = shift;
  my $dbname    = $conf->{'dbs'}{'DATABASE_CORE'};
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${dbname}_Domain.xml";
  $file .= ".gz" unless $nogzip;
  my $start_time = time;
  my $db = 'core';
  my $fh;
  unless ($nogzip) {
    $fh = new IO::Zlib;
    $fh->open( "$file", "wb9" )
      or die("Can't open compressed stream to $file: $!");
  }
  else {
    open( FILE, ">$file" ) or die "Can't open $file: $!";
  }
  print LOG "  Dumping $dbname to $file ... ", format_datetime($start_time), "\n";
  header( $dbname, $dbspecies, $db, $nogzip, $fh, $release );

  my $sth = $conf->{'dbh'}->prepare(
    "select x.dbprimary_acc, i.id, x.description
       from xref as x, interpro as i
      where x.dbprimary_acc = i.interpro_ac
      order by x.dbprimary_acc");
  $sth->execute();
  my $old_acc     = '';
  my $IDS         = [];
  my $description = '';
  my $count       = 0;
  my ($acc, $id, $desc, $old_desc );
  while( ($acc, $id, $desc ) = $sth->fetchrow_array()){
    if($acc eq $old_acc) {
      push @$IDS, $id;
      $count++;
    }
    else {
      if ($old_acc) {
	$description = "Interpro domain $old_acc [$old_desc] has";
	&p( DomainLine($dbspecies,$old_acc,$description,$IDS,$count,$counter ), $nogzip, $fh);
      }
      $IDS      = [ $id ];
      $old_acc  = $acc;
      $old_desc = $desc;
      $count    = 1;
    }
  }
  $description = "Interpro domain $old_acc [$old_desc] has";
  &p( DomainLine($dbspecies,$old_acc,$description,$IDS,$count,$counter ), $nogzip, $fh);
  return footer( $counter->(),$nogzip,$fh);
}

sub DomainLine {
  my($species, $acc, $desc, $IDS, $count, $counter) = @_;
  $species =~ s/_/ /;
  my $ids = join ',', @$IDS;
  my $description = "$desc $count associated external database identifiers: $ids";
  my $xml = qq(
<entry id="$acc">
  <description>$description</description>
  <additional_fields>);
  foreach my $id (@$IDS) {
    $xml .= qq(
    <field name="synonym">$id</field>);
  }
  $xml .= qq(
    <field name="species">$species</field>
    <field name="featuretype">Domain</field>
  </additional_fields>);
  $counter->();
  return $xml . '</entry>';
}


########################################################################## Families

sub dumpFamily {
  my $conf   = shift;
  my $FAMDB  = $conf->{'dbs'}->{'DATABASE_COMPARA'};
  my $dbname = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $t_sth  = $conf->{'dbh'}->prepare("select meta_value from $dbname.meta where meta_key='species.taxonomy_id'");
  $t_sth->execute;
  my $taxon_id = ($t_sth->fetchrow);
  return unless $taxon_id;

  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${dbname}_Family.xml";
  $file .= ".gz" unless $nogzip;
  my $start_time = time;
  my $db = 'core';
  my $fh;
  unless ($nogzip) {
    $fh = new IO::Zlib;
    $fh->open( "$file", "wb9" )
      or die("Can't open compressed stream to $file: $!");
  }
  else {
    open( FILE, ">$file" ) or die "Can't open $file: $!";
  }
  print LOG "  Dumping $dbname to $file ... ", format_datetime($start_time), "\n";
  header( $dbname, $dbspecies, $db, $nogzip, $fh, $release );

 ( my $species = $conf->{'species'} ) =~ s/_/ /g;

  my $sth = $conf->{'dbh_compara'}->prepare(qq(
    select f.stable_id,
           f.description,
           count(*) as N,
           sum( (source_name = 'ENSEMBLGENE') and (m.genome_db_id = gd.genome_db_id) ) as ensembl_genes_species,
           sum( (source_name = 'ENSEMBLPEP' ) and (m.genome_db_id = gd.genome_db_id) ) as ensembl_peptides_species,
           sum(  source_name = 'ENSEMBLGENE'                                         ) as ensembl_genes,
           sum(  source_name = 'ENSEMBLPEP'                                          ) as ensembl_peptides,
           sum( (source_name = 'Uniprot/SPTREMBL' ) and (m.taxon_id = gd.taxon_id)   ) as uniprot_sptrembl_species,
           sum( (source_name = 'Uniprot/SWISSPROT') and (m.taxon_id = gd.taxon_id)   ) as uniprot_swissprot_species,
           sum(  source_name = 'Uniprot/SPTREMBL'                                    ) as uniprot_sptrembl,
           sum(  source_name = 'Uniprot/SWISSPROT'                                   ) as uniprot_swissprot
      from family as f, family_member as fm, member as m, genome_db as gd
     where f.family_id=fm.family_id and fm.member_id=m.member_id and
           gd.name = '$species'
     group by f.family_id 
    having ensembl_genes_species > 0));
  $sth->execute();
  my $X = $conf->{'authority'} || 'Ensembl';
  while( my(
    $fid, $desc, $total,
    $ensembl_genes_species, $ensembl_peptides_species, $ensembl_genes, $ensembl_peptides,
    $uniprot_sptrembl_species, $uniprot_swissprot_species,
    $uniprot_sptrembl, $uniprot_swissprot
  ) = $sth->fetchrow_array()) {
    my $desc = qq(Ensembl protein family $fid [$desc] has $total members: $ensembl_genes $X genes ($ensembl_genes_species in $species); $ensembl_peptides $X proteins ($ensembl_peptides_species in $species); $uniprot_swissprot UniProtKB/Swiss-Prot proteins ($uniprot_swissprot_species in $species); $uniprot_sptrembl UniProtUK/TrEMBL proteins ($uniprot_sptrembl_species in $species).);
    &p( FamilyLine($dbspecies,$fid,$desc,$counter ), $nogzip, $fh);
  }
  return footer( $counter->(),$nogzip,$fh);
}

sub FamilyLine {
  my($species, $fid, $desc, $counter) = @_;
  $species =~ s/_/ /;
  my $xml = qq(
<entry id="$fid">
  <description>$desc</description>);
  $xml .= qq(
  <additional_fields>
    <field name="species">$species</field>
    <field name="featuretype">Family</field>
  </additional_fields>);
  $counter->();
  return $xml . '</entry>';
}

########################################################################## Sequences

sub dumpSequence {
  my $conf = shift;
  my $sanger = sanger_project_names( $conf );
  my @misc_feat_disallowed = (); #features that we know we don't want to dump if we ever decide to do this (not implemented)
  my @name_order = (qw(name well_name clone_name sanger_project synonym embl_acc)); #defines the order of attribute_type we use to get the name for misc_features (comes from B::E::G::_clone.pm)
  my $COREDB   = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $OTFEATDB = $conf->{'dbs'}->{'DATABASE_OTHERFEATURES'};
  my %dbs      = ( 'core' => $COREDB );
  $dbs{'otherfeatures'} =  $OTFEATDB if $OTFEATDB;

  my $total_c;
 DB:
  foreach my $db ( sort { $b cmp $a } keys %dbs) {
    my $dbname    = $dbs{$db};
    my $counter   = make_counter(0);
    my $dbspecies = $conf->{'species'};
    my $file = $conf->{'directory'}."/${dbname}_Sequence.xml";
    $file .= ".gz" unless $nogzip;
    my $start_time = time;
    my $fh;
    unless ($nogzip) {
      $fh = new IO::Zlib;
      $fh->open( "$file", "wb9" )
	or die("Can't open compressed stream to $file: $!");
    }
    else {
      open( FILE, ">$file" ) or die "Can't open $file: $!";
    }
    print LOG "  Dumping $dbname to $file ... ", format_datetime($start_time), "\n";
    header( $dbname, $dbspecies, $db, $nogzip, $fh, $release );

    #get all types of misc features - used for 'type' label
    my $feat_types = $conf->{'dbh'}->selectall_hashref(qq(
		  SELECT ms.code, ms.misc_set_id, ma.value as type 
                    FROM $dbname.attrib_type at, $dbname.misc_attrib ma, $dbname.misc_feature_misc_set mfms, $dbname.misc_set ms
                   WHERE at.attrib_type_id = ma.attrib_type_id
                     AND ma.misc_feature_id = mfms.misc_feature_id 
                     AND mfms.misc_set_id = ms.misc_set_id 
                     AND at.code = 'type'
                   GROUP by ms.code, ma.value), 'misc_set_id');
    if (%$feat_types) {
      my $mapsets = join ',', keys %$feat_types;
      #get al misc_features
      my $sth = $conf->{'dbh'}->prepare(qq(
       SELECT mf.misc_feature_id, sr.name, cs.name, mf.seq_region_start, mf.seq_region_end,
              mf.seq_region_end-mf.seq_region_start+1 as len, ms.misc_set_id, at.code, ma.value
         FROM $dbname.misc_feature_misc_set as ms,
              $dbname.misc_feature as mf,
              seq_region as sr,
              coord_system as cs,
              $dbname.misc_attrib as ma,
              $dbname.attrib_type as at
        WHERE cs.coord_system_id = sr.coord_system_id
          AND sr.seq_region_id = mf.seq_region_id 
          AND mf.misc_feature_id = ms.misc_feature_id
          AND ms.misc_set_id in ($mapsets)
          AND mf.misc_feature_id = ma.misc_feature_id
          AND ma.attrib_type_id = at.attrib_type_id
        ORDER by mf.misc_feature_id, at.code));
      $sth->execute();
      my ($old_ID,$old_sr,$old_sr_type,$old_start,$old_end,$old_len,$NAMES,$ftype);
      while( my($ID,$sr,$sr_type,$start,$end,$len,$ms_id,$code,$val) = $sth->fetchrow_array() ) {
	if($ID == $old_ID) {
	  if (! $ftype && $code eq 'type') {
	    $ftype = $feat_types->{$ms_id}{'type'};
	    #some hacks for the display of the type
	    $ftype =~ s/_/ /;
	    $ftype =~ s/arrayclone/clone/;
	    $ftype = ucfirst($ftype);
	  }
	  if (grep {$code eq $_} @name_order) {
	    push @$NAMES, [$code,$val];
	  }
	}
	else {
	  if ($old_ID) {
	    my ($name, $synonyms) = &sort_mf_names($NAMES,\@name_order);
	    &p( SeqLine($dbspecies,$old_sr,$old_sr_type,$old_start,$old_end,$old_len,$name,$synonyms,$ftype,$sanger,$counter), $nogzip, $fh);
	    $NAMES = undef;
	    $ftype = undef;
	  }
	  if (! $ftype && $code eq 'type') {
	    $ftype = $feat_types->{$ms_id}{'type'};
	    $ftype =~ s/_/ /;
	    $ftype =~ s/arrayclone/clone/;
	    $ftype = ucfirst($ftype);
	  }
	  if (grep {$code eq $_} @name_order) {
	    push @$NAMES, [$code,$val];
	  }
	  ($old_ID,$old_sr,$old_sr_type,$old_start,$old_end,$old_len) = ($ID,$sr,$sr_type,$start,$end,$len);
	}
      }
      my ( $name, $synonyms) = sort_mf_names($NAMES,\@name_order);
      &p( SeqLine($dbspecies,$old_sr,$old_sr_type,$old_start,$old_end,$old_len,$name,$synonyms,$ftype,$sanger,$counter), $nogzip, $fh);

    }
    if ($db ne 'core') {
      $total_c += footer( $counter->(),$nogzip,$fh);
      next DB;
    };

    #identify current default top level
    (my $current_cs_id) = $conf->{'dbh'}->selectrow_array(qq(
       SELECT cs.coord_system_id
         FROM coord_system cs, meta m
        WHERE cs.version = m.meta_value
          AND cs.name = 'chromosome'
          AND m.meta_key = 'assembly.default'));

    #get mappings between toplevel assemblies - used to check there are no name changes on the different assemblies
    my $sth = $conf->{'dbh'}->prepare(qq(
       SELECT distinct sr1.name, sr1.length, sr2.name, cs2.coord_system_id
         FROM coord_system cs1, seq_region sr1, assembly a, seq_region sr2, coord_system cs2
        WHERE cs1.coord_system_id = sr1.coord_system_id
          AND sr1.seq_region_id = a.asm_seq_region_id
          AND a.cmp_seq_region_id = sr2.seq_region_id
          AND sr2.coord_system_id = cs2.coord_system_id
          AND cs1.name = 'chromosome'
          AND cs2.name = 'chromosome'));
    my $mapped_ids;
    $sth->execute;
    while (my ($new_name,$new_length,$prev_name,$prev_coord_system_id) =  $sth->fetchrow_array() ) {
      $mapped_ids->{$prev_coord_system_id}{$prev_name}{'name'}   = $new_name;
      $mapped_ids->{$prev_coord_system_id}{$prev_name}{'length'} = $new_length;
    }

    #get all seq_regions
    $sth = $conf->{'dbh'}->prepare(qq(
       SELECT sr.name, sr.length, cs.name, cs.coord_system_id
         FROM seq_region as sr, coord_system as cs
        WHERE sr.coord_system_id = cs.coord_system_id));
    $sth->execute();
    while( my($name,$length,$type,$cs_id) = $sth->fetchrow_array() ) {
      my ($prev_name,$prev_length,$mapping_text);
      if ($type eq 'chromosome' && $cs_id != $current_cs_id) {
	# if this is an old seq_region mapped to a new one of the same name then skip it
	if ($mapped_ids->{$cs_id}{$name}) {
	  $prev_name   = $mapped_ids->{$cs_id}{$name}{'name'};
	  if ($prev_name ne $name) {
	    print LOG "WARNING: found assembly mapped seq_region $prev_name instead of $name - please check this is correct since this we haven't come across this before\n";
	  }
	  next;
	}
	else {
	  print LOG "WARNING: not dumping $name on coord_system $cs_id since it's an old assembly with no mapping - investigate what this means!\n";
	  next;
	}
      }
      &p( SeqLine($dbspecies,$name,$type,1,$length,$length,$name,[],$type,$sanger,$counter), $nogzip, $fh);
    }
    $total_c += footer( $counter->(),$nogzip,$fh);
  }
  return $total_c;
}

#decide which of the possible many name entries we should be using, the rest will be synonyms
sub sort_mf_names {
  my ($all_names, $name_order) = @_;
  my $name_to_use;
  foreach my $name_type ( @$name_order ) {
    unless ($name_to_use) {
      foreach my $name (@$all_names) {
	if ($name->[0] eq $name_type) {
	  $name_to_use = $name->[1];
	}
      }
    }
  }
  my @synonyms = map {$_->[1]} grep { $_->[1] ne $name_to_use } @$all_names;
  return $name_to_use, \@synonyms ;
}

sub SeqLine {
  my($species,$sr,$sr_type,$start,$end,$len,$name,$synonyms,$type,$sanger,$counter) = @_;
  $species =~ s/_/ /;
  print LOG "WARNING: no type set for $name" unless $type;
  my $action = $len > 0.5e6 ? 'Overview' : 'View';
  my $r = "$sr:$start-$end";
  my $desc = ($name eq $sr) ? "$type $name has a length of $len bp" : "$type $name (length $len bp) is mapped to $sr_type $sr.";
  my $extra_desc = '';

  #deal with any synonyms
  if (@$synonyms) {
    $extra_desc = " It has EMBL accessions / synonyms of " . join(',',@$synonyms) . ".";
  }

 #deal with with Sanger Projects
  my %extra;
  foreach my $n ($name, @$synonyms) {
    foreach( keys %{$sanger->{$n}||{}} ) {
      $extra{$_}=1;
    }
  }
  if (%extra) {
    foreach my $k (keys %extra) {
      push @$synonyms, $k unless grep {$_ eq $k} @$synonyms;
    }
    $extra_desc .= " It is mapped to the following Sanger projects: ".join( ', ',sort keys %extra ) . ".";
  }

  $desc .= $extra_desc;

  my $xml = qq(
<entry id="$name">
  <description>$desc</description>);
  $xml .= qq(
  <additional_fields>
    <field name="species">$species</field>
    <field name="featuretype">Sequence</field>
    <field name="location">$r</field>
    <field name="action">$action</field>);
  foreach my $syn (@$synonyms) {
    $xml .= qq(
    <field name="synonym">$syn</field>);
  }
  $xml .= qq(
  </additional_fields>);
  $counter->();
  return $xml . '</entry>';
}

#retrieve sanger project name details
sub sanger_project_names {
  my $conf = shift;
  my %SPECIES = qw(
    Homo_sapiens Human Mus_musculus Mouse Danio_rerio Zebrafish
    Drosophila_melanogaster Drosophila Rattus_norvegicus Rat
  );
  my $sanger_species_name = $SPECIES{$conf->{'species'}};
  return {} unless $sanger_species_name;
  my $clones = {};
  my $dbh = DBI->connect("DBI:mysql:host=otterlive;port=3301;database=submissions", 'ottro', undef, {RaiseError => 1});
  unless( $dbh ) {
    warn "Can't connect to submissions database as 'read_only' ", DBI::errstr();
    return $clones;
  }
  my $sth = $dbh->prepare(
    "SELECT distinct a.project_name, a.accession 
       FROM project_acc a, project_dump d,
            sequence s, species_chromosome c
      WHERE a.sanger_id = d.sanger_id AND d.seq_id = s.seq_id
        AND s.chromosome_id = c.chromosome_id 
        AND c.species_name = '$sanger_species_name' AND a.accession != 'UNKNOWN'"
  );
  $sth->execute(  );
  while( my ($proj, $acc) = $sth->fetchrow() ) {
    $clones->{$acc}{$proj}=1;
  }
  return $clones;
}


########################################################################## Genes

sub dumpGene {
#  print LOG "Initial memory usage = ".&date_and_mem()."\n";
  my $conf      = shift;
  my $dbspecies = $conf->{'species'};
  my $COREDB    = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $SANGDB    = $conf->{'dbs'}->{'DATABASE_VEGA'};
  my $ESTGENEDB = $conf->{'dbs'}->{'DATABASE_OTHERFEATURES'};
  my %dbs = ( 'core' => $COREDB );
  $dbs{'vega'}          = $SANGDB    if $SANGDB;
  $dbs{'otherfeatures'} = $ESTGENEDB if $ESTGENEDB;

  my $total_c;
 DB:
  foreach my $db ( sort { $b cmp $a } keys %dbs) {
    my $dbname    = $dbs{$db};
    my $counter   = make_counter(0);
    my $file = $conf->{'directory'}."/${dbname}_Gene.xml";
    $file .= ".gz" unless $nogzip;
    my $start_time = time;
    my $fh;
    unless ($nogzip) {
      $fh = new IO::Zlib;
      $fh->open( "$file", "wb9" )
	or die("Can't open compressed stream to $file: $!");
    }
    else {
      open( FILE, ">$file" ) or die "Can't open $file: $!";
    }
    print LOG "  Dumping $dbname to $file ... ".&date_and_mem()."\n";
    header( $dbname, $dbspecies, $db, $nogzip, $fh, $release );

    my $external_dbs = $conf->{'dbh'}->selectall_hashref(
      'select external_db_id, db_name, db_display_name
         from external_db', 'external_db_id'
       );
    my $external_synonyms;
    my $es = $conf->{'dbh'}->selectall_arrayref(qq(select xref_id, synonym from external_synonym));
    foreach (@$es) {
      $external_synonyms->{$_->[0]}{$_->[1]} = 1;
    }
    my %xrefs = ();
    foreach my $type( qw(Gene Transcript Translation) ) {
#      print LOG "starting memory usage for type $type = ".&date_and_mem()."\n";
      my $sql = qq(
         SELECT ox.ensembl_id, x.display_label, x.dbprimary_acc,
                x.description, x.external_db_id, x.xref_id
           FROM $dbname.object_xref as ox, $dbname.xref as x
          WHERE ox.ensembl_object_type = '$type'
            AND ox.xref_id = x.xref_id );
      my $T = $conf->{'dbh'}->selectall_arrayref($sql);
      foreach (@$T) {
	$xrefs{$type}{$_->[0]}{$external_dbs->{$_->[4]}{'db_display_name'}} = {
	  'description'     => $_->[3],
	  'db_acc'          => $_->[2],
	  'label'           => $_->[1],
	  'external_db_id'  => $_->[4],
	  'xref_id'         => $_->[5],
	};
      }
      print LOG "    $type xref query done ".&date_and_mem()."\n";
    }
#    warn Dumper(\%xrefs);

    my %exons = ();
    my $sql = qq(
       SELECT distinct t.gene_id, esi.stable_id
         FROM $dbname.transcript as t, $dbname.exon_transcript as et, $dbname.exon_stable_id as esi
        WHERE t.transcript_id = et.transcript_id
          AND et.exon_id = esi.exon_id);
    my $sth = $conf->{'dbh'}->prepare($sql);
    $sth->execute;
    while (my $r = $sth->fetchrow_arrayref()) {
      $exons{$r->[0]}{$r->[1]}=1;
    }
    $sth->finish;
    print LOG "    Exon query done ".&date_and_mem()."\n";

    my $sql = qq(
      SELECT gsi.gene_id, tsi.transcript_id, trsi.translation_id,
             gsi.stable_id as gsid, tsi.stable_id as tsid, trsi.stable_id as trsid,
             g.description, x.display_label, ad.display_label, ad.web_data, ad.displayable, g.status, g.biotype
        FROM ((( $dbname.gene_stable_id as gsi, $dbname.gene as g,
             $dbname.transcript_stable_id as tsi,
             $dbname.analysis_description as ad,
             $dbname.transcript as t) left join
             $dbname.translation as tr on t.transcript_id = tr.transcript_id) left join
             $dbname.translation_stable_id as trsi on tr.translation_id = trsi.translation_id) left join
             $dbname.xref as x on g.display_xref_id = x.xref_id
       WHERE t.gene_id = gsi.gene_id 
         AND t.transcript_id = tsi.transcript_id
         AND t.gene_id = g.gene_id
         AND g.analysis_id = ad.analysis_id
         AND ad.displayable = 1
       ORDER by gsi.stable_id, tsi.stable_id);
    $sth = $conf->{'dbh'}->prepare($sql);
    $sth->execute(); 

    my $old;
    my ($gid,$tid,$tlid,$gsid,$tsid,$tlsid,$desc,$disp_xref,$ad_dl,$webdata,$displayable,$status,$biotype);
    while (my $r = $sth->fetchrow_arrayref()) {
      ($gid,$tid,$tlid,$gsid,$tsid,$tlsid,$desc,$disp_xref,$ad_dl,$webdata,$displayable,$status,$biotype) = @$r;
      my $wd = eval($webdata);
      next if $wd->{'gene'}{'do_not_display'};
      next unless $displayable;
      if( $old->{'gid'} != $gid ) {
        if( $old->{'gid'} ) {
	  my $type = $old->{'biotype'}.' '.$old->{'ad_dl'};
	  &p( GeneLine($dbspecies,
		       $old->{'gsid'},
		       $old->{'tsids'},
		       $old->{'tlsids'},
		       $old->{'exons'},
		       $old->{'biotype'},
		       $old->{'ad_dl'},
		       $old->{'disp_xref'},
		       $old->{'desc'},
		       $old->{'xrefs'},
		       $db,
		       $counter),
	      $nogzip, $fh);
	}
	
	#only use status for vega#
	
        $old = {
          'gid'       => $gid,
          'gsid'      => $gsid,
	  'tlsids'    => {$tlsid?($tlsid=>1):()},
          'tsids'     => {$tsid ?($tsid=>1) :()}, 
	  'desc'      => $desc,
          'exons'     => {},
	  'biotype'   => $biotype,
	  'ad_dl'     => $ad_dl,
          'xrefs'     => [],
          'disp_xref' => $disp_xref ? " $disp_xref" : "novel gene",
          'status'    => $status,
          'biotype'   => $biotype,
	  'ad_dl'     => $ad_dl,
        };

        $old->{'exons'}  = $exons{$gid};
        $old->{'source'} = ~s/base/Base/;

	#add xref details
	while (my ($xref_id,$dets) = each %{$xrefs{'Gene'}{$gid}}) {
	  $dets->{'db_name'} = $external_dbs->{$dets->{'external_db_id'}}{'db_name'};
	  $dets->{'db_display_name'} = $external_dbs->{$dets->{'external_db_id'}}{'db_display_name'};
	  foreach my $k (keys %{$external_synonyms->{$xref_id}}) {
	    push @{$dets->{'synonyms'}},$external_synonyms->{$xref_id}{$k};
	  }			 
	  push @{$old->{'xrefs'}}, $dets;
	}
	while (my ($xref_id,$dets) = each %{$xrefs{'Transcript'}{$tid}}) {
	  $dets->{'db_name'} = $external_dbs->{$dets->{'external_db_id'}}{'db_name'};
	  $dets->{'db_display_name'} = $external_dbs->{$dets->{'external_db_id'}}{'db_display_name'};
	  foreach my $k (keys %{$external_synonyms->{$xref_id}}) {
	    push @{$dets->{'synonyms'}},$external_synonyms->{$xref_id}{$k};
	  }			 
	  push @{$old->{'xrefs'}}, $dets;
        }
	while (my ($xref_id,$dets) = each %{$xrefs{'Translation'}{$tlid}}) {
	  $dets->{'db_name'} = $external_dbs->{$dets->{'external_db_id'}}{'db_name'};
	  $dets->{'db_display_name'} = $external_dbs->{$dets->{'external_db_id'}}{'db_display_name'};
	  foreach my $k (keys %{$external_synonyms->{$xref_id}}) {
	    push @{$dets->{'synonyms'}},$external_synonyms->{$xref_id}{$k};
	  }			 
	  push @{$old->{'xrefs'}}, $dets;
        }
      }
      else {

        $old->{'tsids' }{$tsid }=1;
        $old->{'tlsids'}{$tlsid}=1 if $tlsid;

	while (my ($xref_id,$dets) = each %{$xrefs{'Gene'}{$gid}}) {
	  $dets->{'db_name'} = $external_dbs->{$dets->{'external_db_id'}}{'db_name'};
	  $dets->{'db_display_name'} = $external_dbs->{$dets->{'external_db_id'}}{'db_display_name'};
	  foreach my $k (keys %{$external_synonyms->{$xref_id}}) {
	    push @{$dets->{'synonyms'}},$external_synonyms->{$xref_id}{$k};
	  }			 
	  push @{$old->{'xrefs'}}, $dets;
	}
	while (my ($xref_id,$dets) = each %{$xrefs{'Transcript'}{$tid}}) {
	  $dets->{'db_name'} = $external_dbs->{$dets->{'external_db_id'}}{'db_name'};
	  $dets->{'db_display_name'} = $external_dbs->{$dets->{'external_db_id'}}{'db_display_name'};
	  foreach my $k (keys %{$external_synonyms->{$xref_id}}) {
	    push @{$dets->{'synonyms'}},$external_synonyms->{$xref_id}{$k};
	  }			 
	  push @{$old->{'xrefs'}}, $dets;
        }
	while (my ($xref_id,$dets) = each %{$xrefs{'Translation'}{$tlid}}) {
	  $dets->{'db_name'} = $external_dbs->{$dets->{'external_db_id'}}{'db_name'};
	  $dets->{'db_display_name'} = $external_dbs->{$dets->{'external_db_id'}}{'db_display_name'};
	  foreach my $k (keys %{$external_synonyms->{$xref_id}}) {
	    push @{$dets->{'synonyms'}},$external_synonyms->{$xref_id}{$k};
	  }			 
	  push @{$old->{'xrefs'}}, $dets;
        }
      }
    }
    &p( GeneLine($dbspecies,
		 $old->{'gsid'},
		 $old->{'tsids'},
		 $old->{'tlsids'},
		 $old->{'exons'},
		 $old->{'biotype'},
		 $old->{'ad_dl'},
		 $old->{'disp_xref'},
		 $old->{'desc'},
		 $old->{'xrefs'},
		 $db,
		 $counter),
	$nogzip, $fh);
    print LOG "    Gene info query done ".&date_and_mem()."\n";


    my $other_count = 0;
    my %current_stable_ids =();
    foreach my $type (qw(gene transcript translation)) {
      $current_stable_ids{$type}  = {map {@$_} @{$conf->{'dbh'}->selectall_arrayref( "select stable_id,1 from $COREDB.".$type."_stable_id" )}};
    }
    my $species = $conf->{'species'};
    my $sth = $conf->{'dbh'}->prepare( qq(
    SELECT sie.type, sie.old_stable_id, if(isnull(sie.new_stable_id),'NULL',sie.new_stable_id),
           ms.old_release*1.0 as X, ms.new_release*1.0 as Y
      FROM $dbname.mapping_session as ms, $dbname.stable_id_event as sie
     WHERE ms.mapping_session_id = sie.mapping_session_id and ( old_stable_id != new_stable_id or isnull(new_stable_id) )
     ORDER by Y desc, X desc
  ));

    $sth->execute();
    my %mapping = ();
    while( my($type,$osi,$nsi) = $sth->fetchrow_array() ) {
      next if $current_stable_ids{$type}{$osi}; ## Don't need to cope with current IDS already searchable...
      $mapping{$type}{$osi}{$nsi}=1;
      if($mapping{$type}{$nsi}) {
	foreach( keys %{$mapping{$type}{$nsi}} ) {
	  $mapping{$type}{$osi}{$_}=1;
	}
      }
    }
    foreach my $type ( keys %mapping ) {
      foreach my $osi ( keys %{$mapping{$type}} ) {
	my @current_sis = ();
	my @deprecated_sis = ();
	foreach ( keys %{$mapping{$type}{$osi}} ) {
	  next if $osi eq $_;
	  if( $current_stable_ids{$_} ) {
	    push @current_sis,$_;
	  } elsif( $_ ne 'NULL' ) {
	    push @deprecated_sis,$_;
	  }
	}
	if( @current_sis ) {
	  $other_count++;
	  my $desc = qq(Ensembl $type $osi is no longer in the database but it has been mapped to the following current identifiers: @current_sis);
	  $desc .= @deprecated_sis ? qq(; and the following deprecated identifiers: @deprecated_sis) : '';
	  &p (&GeneStableIdMappingLine($dbspecies,$desc,$osi,\@current_sis,\@deprecated_sis,$type,$db,$counter),$nogzip, $fh);
	}
	elsif( @deprecated_sis ) {
	  $other_count++;
	  my $desc = qq(Ensembl $type $osi is no longer in the database but it has been mapped to the following identifiers: @deprecated_sis);
	  &p (&GeneStableIdMappingLine($dbspecies,$desc,$osi,[],\@deprecated_sis,$type,$db,$counter),$nogzip, $fh);
	}
	else {
	  $other_count++;
	  my $desc = qq(Ensembl $type $osi is no longer in the database and has not been mapped to any newer identifiers);
	  &p (&GeneStableIdMappingLine($dbspecies,$desc,$osi,[],[],$type,$db,$counter),$nogzip, $fh);
	}
      }
    }
    print LOG "    Stable_id mapping querying done ".&date_and_mem()."\n";
    $total_c += footer( $counter->(),$nogzip,$fh);

    while (0) {
      $other_count = 0;
      my %unmapped_queries = (
      'None' => qq(
      select a.logic_name, e.db_display_name,
             uo.identifier, ur.summary_description,
             'Not mapped'
        from $dbname.analysis as a, $dbname.external_db as e, $dbname.unmapped_object as uo,
             $dbname.unmapped_reason as ur
       where a.analysis_id = uo.analysis_id and
             uo.external_db_id = e.external_db_id and
             uo.unmapped_reason_id = ur.unmapped_reason_id and
               uo.ensembl_id = 0
    ),
      'Transcript' => qq(
      select a.logic_name, e.db_display_name,
             uo.identifier, ur.summary_description,
             concat( 'Transcript: ', tsi.stable_id, '; Gene: ',gsi.stable_id )
        from $dbname.analysis as a, $dbname.external_db as e, $dbname.unmapped_object as uo,
             $dbname.unmapped_reason as ur, $dbname.transcript_stable_id as tsi,
             $dbname.transcript as t, $dbname.gene_stable_id as gsi
       where a.analysis_id = uo.analysis_id and
             uo.external_db_id = e.external_db_id and
             uo.unmapped_reason_id = ur.unmapped_reason_id and
             uo.ensembl_id = t.transcript_id and
             uo.ensembl_object_type = 'Transcript' and
             t.transcript_id = tsi.transcript_id and
             t.gene_id       = gsi.gene_id
    ),
      'Translation' => qq(
      select a.logic_name, e.db_display_name, uo.identifier, ur.summary_description,
             concat( 'Protein: ',trsi.stable_id,'; Transcript: ', tsi.stable_id, '; Gene: ',gsi.stable_id )
        from $dbname.analysis as a, $dbname.external_db as e, $dbname.unmapped_object as uo,
             $dbname.unmapped_reason as ur, $dbname.transcript_stable_id as tsi,
             $dbname.translation as tr, $dbname.translation_stable_id as trsi,
             $dbname.transcript as t, $dbname.gene_stable_id as gsi
       where a.analysis_id = uo.analysis_id and 
             uo.external_db_id = e.external_db_id and
             uo.unmapped_reason_id = ur.unmapped_reason_id and
             uo.ensembl_id = tr.translation_id and 
             tr.transcript_id = t.transcript_id and
             trsi.translation_id = tr.translation_id and
             uo.ensembl_object_type = 'Translation' and
             t.transcript_id = tsi.transcript_id and
             t.gene_id       = gsi.gene_id
    )
    );

      foreach my $FLAG (keys %unmapped_queries) {
	my $SQL = $unmapped_queries{$FLAG};
	my $sth = $conf->{'dbh'}->prepare($SQL);
	$sth->execute;
	while( my $T = $sth->fetchrow_arrayref() ) {
	  print O join "\t",
	    (INC_SPECIES?"$conf->{'species'}\t":"").qq(Unmapped feature),
	      "$T->[1] $T->[2]",
		"/$conf->{'species'}/Location/Genome?ftype=Gene;id=$T->[2]",
		  "$T->[2] $T->[4]",
		    "$T->[3]; $T->[4]\n";
	}
      }
    }
    close O;
  }
  return $total_c;
}

sub GeneLine {
  my ($species, $gsid, $tsids, $tlsids, $exons, $biotype, $ad_label, $disp_xref, $desc, $xrefs, $db, $counter) = @_;
  $species =~ s/_/ /;
  $biotype =~ s/_/ /;
  $desc = &clean($desc,'desc');
  my $description = $desc . " [Type: $biotype $ad_label]";
  my $xml = qq(
<entry id="$gsid">
  <description>$description</description>
  <cross_references>);
  my %seen_syns;
  foreach my $xref (@$xrefs) {
    my $dbname = $xref->{'db_name'};
    my $dbkey  = $xref->{'label'};
    next if $seen_syns{$dbkey}{$dbname};
    $seen_syns{$dbkey}{$dbname} = 1;
    $dbkey = &clean($dbkey,'dbkey');
    $xml .= qq(
    <ref dbname="$dbname" dbkey="$dbkey"/>);
    foreach my $syn (@{$xref->{'synonyms'}}) {
      $dbkey = &clean($dbkey,'syn');
      $xml .= qq(
    <ref dbname="$dbname" dbkey="$syn"/>);
    }
    $cross_references{$dbname}++;
  }
  $xml .= qq(
  </cross_references>);

  $xml .= qq(
  <additional_fields>
    <field name="species">$species</field>
    <field name="featuretype">Gene</field>
     <field name="action">Summary</field>
    <field name="source">$ad_label</field>);
  unless ($db eq 'core') {
    $xml .= qq(
   <field name="db">$db</field>);
  }
  foreach my $tsi (keys %$tsids) {
    $xml .= qq(
    <field name="transcript">$tsi</field>);
  }
  foreach my $tlsi (keys %$tlsids) {
    $xml .= qq(
    <field name="peptide">$tlsi</field>);
  }
  foreach my $esi (keys %$exons) {
    $xml .= qq(
    <field name="exon">$esi</field>);
  }
  $xml .= qq(
  </additional_fields>);
  $counter->();
  return $xml . qq(
</entry>);
}

#deal with those pesky gene names and descriptions (order of regexps is important)
sub clean {
  my ($dbkey,$field) = @_;
  $dbkey =~ s/<i>//g;
  $dbkey =~ s/<\/i>//g;
  $dbkey =~ s/<em>//g;
  $dbkey =~ s/<\/em>//g;
  $dbkey =~ s/</&lt;/g;
  $dbkey =~ s/>/&gt;/g;
  $dbkey =~ s/ & / &amp; /g;
  if ($dbkey =~ /[<>]/) {
    print LOG "WARNING: Unsupported character $dbkey in dbkey field\n";
  }
  return $dbkey;
}

sub GeneStableIdMappingLine {
  my ($species,$desc,$osi,$current_sis,$deprecated_sis,$type,$db,$counter) = @_;
  $species =~ s/_/ /;
  $type = lc($type);
  my $xml = qq(
<entry id="$osi">
  <description>$desc</description>
  <additional_fields>);
  foreach my $id (@$current_sis,@$deprecated_sis) {
    $xml .= qq(
    <field name="old_id">$id</field>);
  }
  $xml .= qq(
    <field name="species">$species</field>
    <field name="featuretype">Gene</field>
    <field name="action">Idhistory</field>
    <field name="db">$db</field>
  </additional_fields>);
  $counter->();
  return $xml . qq(
</entry>);
}

########################################################################## Regulatory Features

sub dumpRegulatoryFeature {
  my $conf = shift;
  my $dbname = $conf->{'dbs'}->{'DATABASE_FUNCGEN'};
  return unless $dbname;

  my $dbspecies = $conf->{'species'};
  my $db = 'regulatoryfeatures';
  my $counter   = make_counter(0);
  my $file = $conf->{'directory'}."/${dbname}_RegulatoryFeature.xml";
  $file .= ".gz" unless $nogzip;
  my $start_time = time;
  my $fh;
  unless ($nogzip) {
    $fh = new IO::Zlib;
    $fh->open( "$file", "wb9" )
      or die("Can't open compressed stream to $file: $!");
  }
  else {
    open( FILE, ">$file" ) or die "Can't open $file: $!";
  }
  print LOG "  Dumping $dbname to $file ... ".&date_and_mem()."\n";
  header( $dbname, $dbspecies, $db, $nogzip, $fh, $release );

  my $ftype = 'RegulatoryFeature';
  my $params;


  my $prefix = ($dbspecies =~/Mus/) ? 'ENSMUSR' : 'ENSR';
  my $d = $conf->{'dbh'}->selectall_arrayref( 
    "select concat('$prefix', lpad(rf.stable_id, 11, 0)),
            sr.name, rf.bound_seq_region_start, rf.bound_seq_region_end, ft.name
       from $dbname.regulatory_feature rf, $dbname.seq_region sr, $dbname.coord_system cs,
            $dbname.feature_type ft, $dbname.feature_set fs
      where fs.name='RegulatoryFeatures' and fs.feature_set_id=rf.feature_set_id and
            rf.feature_type_id=ft.feature_type_id and rf.seq_region_id=sr.seq_region_id and
            sr.coord_system_id=cs.coord_system_id and cs.is_current=1
   group by rf.regulatory_feature_id"
  );

  foreach my $row ( @$d ) {
    my $desc = qq($row->[4] regulatory feature);
    my $id = $row->[0];
    my $ids = [ ];
    my $r = $row->[1] .":".$row->[2] . "-" . $row->[3];
    $params = { 'r' => $r, 'subtype' => 'RegulatoryFeature' };
    &p (RegulatoryFeatureLine($dbspecies,$desc,$id,$ids,$ftype,$params,$db,$counter),$nogzip, $fh);
  }


## External Features...
  my $e = $conf->{'dbh'}->selectall_arrayref(
  "select ef.display_label, group_concat(distinct ft.name), count(distinct ef.external_feature_id),
          ft.description, ft.class, fs.name, sr.name, ef.seq_region_start, ef.seq_region_end,
          ef.seq_region_strand
    from  $dbname.feature_type ft, $dbname.external_feature ef, $dbname.feature_set fs, $dbname.seq_region sr,
          $dbname.coord_system cs,$dbname.status s, $dbname.status_name sn
    where ft.feature_type_id=ef.feature_type_id and fs.feature_set_id=ef.feature_set_id and
          fs.type='external' and ef.seq_region_id=sr.seq_region_id  and sr.coord_system_id=cs.coord_system_id
          and cs.is_current=1 and  s.table_name='feature_set' and s.table_id=fs.feature_set_id and
          s.status_name_id=sn.status_name_id and sn.name='MART_DISPLAYABLE'
 group by ef.display_label"
  );

  foreach my $f ( @$e) {
    my ($display_label, $f_name, $count, $f_desc, $f_class, $fs_name, $seq_region, $start, $end, $strand) = @$f;
 #   warn "$display_label -- $f_name -- $count -- $f_desc -- $f_class -- $fs_name -- $seq_region -- $start -- $end -- $strand";
 #   exit;
    my @ids = split ' ', $f_name;
    if ($count >> 1) {
      $params = { 'f_name' => $f_name, 'subtype' => 'RegulatoryFactor' };
#	$link = "/$species/Location/Genome?ftype=RegulatoryFactor;id=$display_label;name=$f_name;";
    }
    else {
      # link miranda features to gene reg view other feats to region in detail
      if ( $f_class eq 'RNA'){
	my ($trans_id, $feat) = split(/:/,$display_label);
	$params = { 't' => $trans_id, 'subtype' => 'RegulationGene', 'hid' => $display_label };
#	$link = "/$species/Gene/Regulation?t=$trans_id;hid=$display_label";
      }
      else {
        $start = $start -=100;
        $end = $end +=100;
        my $r  = $seq_region .':' . $start . "-" . $end;
        my $renderer;
        if ($f_class =~/Search/) {
	  $renderer = 'regulatory_regions_funcgen_search';
	}
        else {
	  $renderer = 'regulatory_regions_funcgen_feature_set';
	}
	$params = { 'r' => $r, 'subtype' => 'RegulationLocation','hid' => $display_label, 'contigviewbottom' => "$renderer=normal" };
#        $link = "/$species/Location/View?r=$region;hid=$display_label;contigviewbottom=$renderer=normal";
      }
    }
    my $desc = "$display_label is a $f_class from $fs_name which hits the genome in $count locations";
    &p(RegulatoryFeatureLine($dbspecies,$desc,$display_label,\@ids,$ftype,$params,$db,$counter),$nogzip, $fh);
  }
  return footer( $counter->(),$nogzip,$fh);
}

sub RegulatoryFeatureLine {
  my ($species,$desc,$id,$ids,$ftype,$params,$db,$counter) = @_;
  $species =~ s/_/ /;
  my $xml = qq(
<entry id="$id">
  <description>$desc</description>
  <additional_fields>);
  $xml .= qq(
    <field name="species">$species</field>
    <field name="featuretype">$ftype</field>);
  foreach my $syn (@$ids) {
    $xml .= qq(
    <field name="synonym">$syn</field>);
  }
  while (my ($param,$value) = each %$params) {
    $xml .= qq(
    <field name="$param">$value</field>);
  }
  $xml .= qq(
  </additional_fields>);
  $counter->();
  return $xml . qq(
</entry>);
}

sub make_counter {
  my $start = shift;
  return sub { $start++ }
}

sub header {
  my ( $dbname, $dbspecies, $dbtype, $nogzip, $fh, $release ) = @_;
  $dbspecies =~ s/_/ /;
  p("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>",$nogzip,$fh);
  p("<!DOCTYPE database [ <!ENTITY auml \"&#228;\">]>",$nogzip,$fh);
  p("<database>",$nogzip,$fh);
  p("<name>$dbname</name>",$nogzip,$fh);
  p("<description>Ensembl $dbspecies $dbtype database</description>",$nogzip,$fh);
  p("<release>$release</release>",$nogzip,$fh);
  p("",$nogzip,$fh);
  p("<entries>",$nogzip,$fh);
}

sub footer {
  my ($ecount,$nogzip, $fh, $release) = @_;
  p("</entries>",$nogzip,$fh);
  p("<entry_count>$ecount</entry_count>",$nogzip,$fh);
  p("</database>",$nogzip,$fh);
  print LOG "  ...Dumped $ecount entries\n";
  if ($nogzip) {
    close(FILE) or die $!;
  }
  else {
    $fh->close();
  }
  return $ecount;
}

sub p {
  my ($str,$nogzip,$fh) = @_;
  return unless $str;
  # TODO - encoding
  $str .= "\n";
  if ($nogzip) {
    if (! $dry_run) {
      print FILE $str or die "Can't write to file ", $!;
    }
  }
  else {
    print $fh $str or die "Can't write string: $str";
  }
}

sub format_datetime {
  my $t = shift;
  my ( $y, $m, $d, $ss, $mm, $hh ) = ( localtime($t) )[ 5, 4, 3, 0, 1, 2 ];
  $y += 1900;
  $d = "0" . $d if ( $d < 10 );
  my $ms = text_month($m);
  return sprintf "$d-$ms-$y %02d:%02d:%02d", $hh, $mm, $ss;
}

sub text_month {
  my $m = shift;
  my @months = qw[JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC];
  return $months[$m];
}

sub date_and_mem {
  my $date = strftime "%Y-%m-%d %T", localtime;
  my $mem = `ps -p $$ -o vsz |tail -1`;
  chomp $mem;
  return "[$date, mem $mem]";
}

sub elapsed_time {
  my $start_time = shift;
  my $diff = time - $start_time;
  my $sec = $diff % 60;
  $diff = ($diff - $sec) / 60;
  my $min = $diff % 60;
  my $hours = ($diff - $min) / 60;
  return "${hours}h ${min}min ${sec}sec";
}
