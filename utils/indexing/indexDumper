#!/usr/local/bin/perl

use strict;

my $ENSEMBL_ROOT;

BEGIN {
  use FindBin qw($Bin);
  use File::Basename qw( dirname );
  $ENSEMBL_ROOT = dirname( $Bin );
  $ENSEMBL_ROOT =~ s/\/utils$//;
  unshift @INC, "$ENSEMBL_ROOT/conf";
  eval{ require SiteDefs };
  if ($@){ die "Can't use SiteDefs.pm - $@\n"; }
  map{ unshift @INC, $_ } @SiteDefs::ENSEMBL_LIB_DIRS;
}

use EnsEMBL::Web::SpeciesDefs;
use Data::Dumper;
package indexDumper;

use constant INC_SPECIES => 0;
use CGI;

our $SD = EnsEMBL::Web::SpeciesDefs->new();

my ( $SPECIES_STRING, @indexes) = @ARGV;

## HACK 1 - if the INDEX is set to all grab all dumper methods...
@indexes = map { /dump(\w+)/?$1:() } keys %indexDumper:: if $indexes[0] eq 'ALL';

## HACK 2 - if the SPECIES is set to ALL grab stuff from config...

my @species;
my %X = %{$SD->ENSEMBL_SPECIES_ALIASES};

if( $SPECIES_STRING eq 'ALL' ) {
  @species = @{$SD->ENSEMBL_SPECIES}
} else {
  @species = grep {$_} map { $X{lc($_)} } split /:/, $SPECIES_STRING;
}

# EnsEMBL::Web::IndexSupport takes path to conf, path to files, species
my $conf = {};
mkdir 'input', 0777 unless -e 'input';

foreach my $species ( @species ) {
  $conf->{'directory'} = "input/$species";
  mkdir $conf->{'directory'}, 0777 unless -e  $conf->{'directory'};
  $conf->{'species'}   = $species;
  my %dbs = %{$SD->get_config($species,'databases')||{}};
  $conf->{'dbs'}       = { map { ($_,$dbs{$_}{NAME}) } keys %dbs };
  $conf->{'dbs'}{'ENSEMBL_COMPARA'} = 'ensembl_compara_38';
  my $core = $dbs{'ENSEMBL_DB'};
  $conf->{'dbh'}       = DBI->connect( "dbi:mysql:$core->{'NAME'};host=$core->{'HOST'};port=$core->{'PORT'}",
        $core->{'USER'}, $core->{'PASS'} );
  warn join ' ', $species, Data::Dumper::Dumper $conf;
  foreach my $index (@indexes) {
    warn "  Index: $species $index";
    my $function = "dump$index";
    no strict "refs";
    &$function( $conf );
  }
}

## Now for all the dump functions...............................

########################################################################## QTLs

sub dumpUnmapped {
  my $conf = shift;
  my %queries = ( 'None' => q(
select a.logic_name, e.db_display_name,
       uo.identifier, ur.summary_description,
       'Not mapped'
  from analysis as a, external_db as e, unmapped_object as uo,
       unmapped_reason as ur
 where a.analysis_id = uo.analysis_id and 
       uo.external_db_id = e.external_db_id and
       uo.unmapped_reason_id = ur.unmapped_reason_id and
       uo.ensembl_id = 0
), 'Transcript' => q(
select a.logic_name, e.db_display_name,
       uo.identifier, ur.summary_description,
       concat( 'Transcript: ',
                tsi.stable_id, '; Gene: ',gsi.stable_id )
  from analysis as a, external_db as e, unmapped_object as uo,
       unmapped_reason as ur, transcript_stable_id as tsi,
       transcript as t, gene_stable_id as gsi
 where a.analysis_id = uo.analysis_id and 
       uo.external_db_id = e.external_db_id and
       uo.unmapped_reason_id = ur.unmapped_reason_id and
       uo.ensembl_id = t.transcript_id and
       uo.ensembl_object_type = 'Transcript' and
       t.transcript_id = tsi.transcript_id and
       t.gene_id       = gsi.gene_id
), 'Translation' => q(
select e.db_display_name, uo.identifier, ur.summary_description,
       concat( 'Translation: ',trsi.stable_id,'; Transcript: ',
                tsi.stable_id, '; Gene: ',gsi.stable_id )
  from analysis as a, external_db as e, unmapped_object as uo,
       unmapped_reason as ur, transcript_stable_id as tsi,
       translation as tr, translation_stable_id as trsi,
       transcript as t, gene_stable_id as gsi
 where a.analysis_id = uo.analysis_id and 
       uo.external_db_id = e.external_db_id and
       uo.unmapped_reason_id = ur.unmapped_reason_id and
       uo.ensembl_id = tr.translation_id and 
       tr.transcript_id = t.transcript_id and
       trsi.translation_id = tr.translation_id and
       uo.ensembl_object_type = 'Translation' and
       t.transcript_id = tsi.transcript_id and
       t.gene_id       = gsi.gene_id
  ));
  open O, ">$conf->{'directory'}/Unmapped.txt";
  foreach my $FLAG (keys %queries) {
    my $SQL = $queries{$FLAG};
    my $sth = $conf->{'dbh'}->prepare($SQL);
    $sth->execute;
    while( my $T = $sth->fetchrow_arrayref() ) {
      print O join "\t", (INC_SPECIES?"$conf->{'species'}\t":"").qq(Unmapped feature:),
    "$T->[1] $T->[2]",
    "/$conf->{'species'}/featureview?type=Unmapped;name=$T->[2]", "$T->[2] $T->[4]", "$T->[3]; $T->[4]\n";
    }
  }
  close O;
}   
sub dumpQTL {
  my $conf = shift;
  my $sth = $conf->{'dbh'}->prepare(qq(
 select c.name as chr, qf.seq_region_start, qf.seq_region_end,
        a.logic_name as analysis, q.qtl_id,
        q.trait, qs.source_database, qs.source_primary_id,
        fms1.source as fm1_source, fms1.name as fm1_name,
        fms2.source as fm2_source, fms2.name as fm2_name,
        pms.source  as pm_source,  pms.name  as pm_name
   from seq_region as c, qtl_feature as qf, qtl_synonym as qs ,
        analysis as a, qtl as q left join marker as fm1 on
        fm1.marker_id = q.flank_marker_id_1 left join marker_synonym as fms1 on
        fm1.display_marker_synonym_id = fms1.marker_synonym_id left join marker as fm2 on
        fm2.marker_id = q.flank_marker_id_2 left join marker_synonym as fms2 on
        fm2.display_marker_synonym_id = fms2.marker_synonym_id left join marker as pm on
        pm.marker_id = q.peak_marker_id left join marker_synonym as pms on
        pm.display_marker_synonym_id = pms.marker_synonym_id 
  where c.seq_region_id = qf.seq_region_id and qs.qtl_id = q.qtl_id and 
        qf.analysis_id = a.analysis_id and qf.qtl_id = q.qtl_id
  ));
  $sth->execute();
  open O, ">$conf->{'directory'}/QTL.txt";
  my $desc       = '';
  my $old_qtl = 0;
  my $old_ID  = '';
  my $old_pos = '';
  my $IDS;
  while( my $T = $sth->fetchrow_hashref() ){
    if($T->{qtl_id} eq $old_qtl) {
      $IDS  .= " $T->{source_primary_id}";
      $desc .= " $T->{source_database}:$T->{source_primary_id}";
    } else {
      print O &QTLLine( $conf->{'species'}, $old_ID, $old_pos, $IDS,$desc );
      $IDS = "$T->{trait} $T->{source_primary_id}";
      $IDS.= " $T->{fm1_name}" if $T->{fm1_name};
      $IDS.= " $T->{fm2_name}" if $T->{fm2_name};
      $IDS.= " $T->{pm_name}" if $T->{pm_name};
      $old_ID = $T->{pm_name};
      $old_pos = "$T->{chr}:".($T->{seq_region_start}-1e4).'-'.($T->{seq_region_end}+1e4);
      $desc       = "QTL exhibiting '$T->{trait}' has ";
      my $f2 = $T->{pm_name} ? 1 : 0;
      if( $T->{fm1_name} || $T->{fm2_name} ) {
        my $f1= ($T->{fm1_name}) && ($T->{fm2_name}) ? 1 : 0;
        $desc.='flanking marker'.($f1?'s ':' ').$T->{fm1_name}.($f1?' and ':'').$T->{fm2_name}.($f2?'; ':'');
      }
      if($f2) {
        $desc.= "peak marker $T->{pm_name};";
      }
      $desc.=" and names: $T->{source_database}:$T->{source_primary_id}";
      $old_qtl = $T->{qtl_id};
    }
  }
  print O &QTLLine( $conf->{'species'}, $old_ID,$old_pos, $IDS,$desc );
  close O;
}

sub QTLLine {
  my ($species, $trait, $pos, $IDS, $desc ) = @_;
  return if $trait eq '';
  return join "\t", (INC_SPECIES?"$conf->{'species'}\t":"").qq(QTL),
    $trait, "/$conf->{'species'}/contigview?l=$pos", $IDS, "$desc\n";
}

########################################################################## SNPs


sub dumpSNP {
  my $conf = shift;
  next if $conf->{'species'} eq 'Homo_sapiens'; ## SKIP HUMAN SNPS....
  next if $conf->{'species'} eq 'Mus_musculus'; ## SKIP HUMAN SNPS....
  my $SNPDB = $conf->{'dbs'}->{'ENSEMBL_VARIATION'};
  return unless $SNPDB;
  my %SOURCES = map { @$_ } @{$conf->{'dbh'}->selectall_arrayref( "select source_id, name from $SNPDB.source" )};
  my $sth = $conf->{'dbh'}->prepare(
    "select v.source_id as o1, v.name as o2, vs.source_id as o3, vs.name as o4
       from $SNPDB.variation as v left join $SNPDB.variation_synonym as vs on vs.variation_id = v.variation_id
      order by o1,o2,o3,o4"
  );
  $sth->execute();
  my $old = {}; my $desc; my $IDS;
  open O, ">$conf->{'directory'}/SNP.txt";
  while( my $T= $sth->fetchrow_hashref()) {
    if($T->{o1} eq $old->{o1} && $T->{o2} eq $old->{o2}) {
      $desc.= ", ".$SOURCES{$T->{o3}}.":$T->{o4}";
      $IDS .= " $T->{o4}";
    } else {
      print O &snpLine( $conf->{'species'}, $SOURCES{$old->{o1}}, $old->{o2}, $IDS, $desc);
      $IDS = $T->{o2};
      $desc = '';
      if( $T->{o3} ) {
        $desc .= ", ".$SOURCES{$T->{o3}}.":$T->{o4}";
        $IDS  .= " $T->{o4}";
      }
      $old = {%$T};
    }
  }
  print O &snpLine( $conf->{'species'}, $SOURCES{$old->{o1}}, $old->{o2}, $IDS, $desc);
  close O;
}

sub snpLine {
  my ($species, $source, $snpid, $IDS, $desc ) =@_;
  return if $snpid eq '';
  $desc =~ s/^, //;
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(Ensembl SNP),
    $snpid,
    "/$species/snpview?snp=$snpid;source=$source",
    "$IDS",
    "SNP $snpid. Alternative IDs: $desc.\n";
}



########################################################################## Markers

sub dumpMarker {
  my $conf = shift;
  my $sth = $conf->{'dbh'}->prepare(qq(
   select m.marker_id, ms2.name, ms1.name
     from marker_synonym as ms1, marker as m left join
          marker_synonym as ms2 on ms2.marker_synonym_id = m.display_marker_synonym_id
    where ms1.marker_id = m.marker_id
    order by m.marker_id
  ));

  $sth->execute( );

  open O, ">$conf->{'directory'}/Marker.txt";
  my $counter    = 0;
  my $desc       = '';
  my $old_ID = 0;
  my ($ID,$marker,$synonym);
  while( ($ID,$marker,$synonym) = $sth->fetchrow_array()){
    $marker = $synonym unless $marker;
    if($ID == $old_ID) {
      $desc .= " $synonym";
      $counter++;
    } else {
      print O &markerLine( $conf->{'species'}, $desc, $counter );
      $desc       = "$synonym";
      $old_ID = $ID;
      $counter    = 1;
    }
  }
  print O &markerLine( $conf->{'species'}, $desc, $counter );
  close O;
}

sub markerLine {
  my( $species, $IDS, $counter ) = @_;
  return if $counter == 0;
  my @synonyms = sort split /\s+/, $IDS;
  my $key = pop @synonyms;
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(Ensembl Marker),    ## Type
    qq($key),               ## ID
    qq(/$species/markerview?marker=$key),
    qq($IDS),     ## Index locations,
    qq(A marker with $counter synonyms ($IDS)\n);
}

########################################################################## Similarity features

sub dumpGenomicAlignment {
  my  $conf = shift;
  open D, ">$conf->{'directory'}/GenomicAlignment.txt";
  my @features = (
  [ 'uniprotblast',       'Protein', 'UniprotKB blast' ],
  [ 'drosophilablast',    'Protein', 'Drosophila blast' ],
  [ 'uniprot_wublastx',   'Protein', 'BLASTX hits' ],
  [ 'uniprot_wublastx',   'Protein', 'BLASTX hits' ],
  [ 'blastx',             'Protein', 'BLASTX hits' ],
  [ 'blastp',             'Protein', 'BLASTP hits' ],
  [ 'macaque_protein',    'Protein', 'Macaque protein' ],
  [ 'opossum_protein',    'Protein', 'Opossum protein' ],
  [ 'fugu_protein',       'Protein', 'Fugu Protein' ],
  [ 'fish_protein',       'Protein', 'Fish Protein' ],
  [ 'anopheles_protein',  'Protein', 'Anopheles Protein' ],
  [ 'drosophila_protein', 'Protein', 'Drosophila Protein' ],
  [ 'cow_protein',        'Protein', 'Cow Protein' ],
  [ 'cow_proteins',       'Protein', 'Cow Protein' ],
  [ 'other_proteins',     'Protein', 'Other Protein' ],
  [ 'human_ensembl_proteins', 'Protein', 'Human (Ensembl) Protein' ],
  [ 'beeproteinblast', 'Protein', 'Bee protein BLAST evidence' ],
  [ 'beeproteinsimilarity', 'Protein', 'Bee protein Similarity evidence' ],
  [ 'chicken_protein', 'Protein', 'Chicken peptide' ],
  [ 'dog_protein', 'Protein', 'Dog peptide' ],
  [ 'drosophila-peptides', 'Protein', 'Fly peptide' ],
  [ 'btaurus_exonerate_protein', 'Protein', 'Cow peptide' ],
  [ 'gapfilluniprothomologyevidence', 'Protein', 'UniProtKB (evidence in gaps)' ],
  [ 'genomeuniprotblast', 'Protein', 'Genome Uniprot BLAST' ],
  [ 'genscanpeptidesuniprotblast', 'Protein', 'Genscan Uniprot BLAST' ],
  [ 'human_ensembl_peptides', 'Protein', 'Ensembl peptides (Human)' ],
  [ 'human_protein', 'Protein', 'Human peptide' ],
  [ 'human_refseq', 'Protein', 'Human RefSeq peptide' ],
  [ 'mammal_protein', 'Protein', 'Mammal peptide' ],
  [ 'mouse_protein', 'Protein', 'Mouse peptide' ],
  [ 'mouse_refseq', 'Protein', 'Mouse RefSeq peptide' ],
  [ 'other_protein', 'Protein', 'Other peptide' ],
  [ 'rodent_protein', 'Protein', 'Rodent peptide' ],
  [ 'similarity_genewise', 'Protein', 'Similarity Genewise' ],
  [ 'similaritygenewise', 'Protein', 'Similarity Genewise' ],
  [ 'support_other_protein', 'Protein', 'Other peptide (supporting)' ],
  [ 'support_xtrop_protein', 'Protein', 'X.tropicalis protein (supporting)' ],
  [ 'swall', 'Protein', 'UniProt' ],
  [ 'swall_blastx', 'Protein', 'UniProt' ],
  [ 'targettedgenewise', 'Protein', 'Targetted Genewise' ],
  [ 'tge_gw', 'Protein', 'Targetted Genewise' ],
  [ 'uniprot', 'Protein', 'UniProtKB' ],
  [ 'uniprot_mammal', 'Protein', 'Mammal UniProtKB' ],
  [ 'uniprot_non_mammal', 'Protein', 'Non-mammal UniProtKB' ],
  [ 'uniprothomologyevidence', 'Protein', 'UniProtKB (evidence)' ],
  [ 'wormpep', 'Protein', 'Wormbase peptide' ],

  [ 'macaque_cdna',   'cDNA', 'Macaque cDNA' ],
  [ 'opossum_cdna',   'cDNA', 'Opossum cDNA' ],
  [ 'cdm',            'cDNA', 'Tetraodon cDNA' ],
  [ 'chicken_cdna',   'cDNA', 'Chicken cDNA' ],
  [ 'duck_cdna',      'cDNA', 'Duck cDNA' ],
  [ 'exonerate_cdna', 'cDNA', 'Ciona cDNA' ],
  [ 'fugu_cdna',      'cDNA', 'Fugu cDNA' ],
  [ 'cint_cdna',      'cDNA', 'Ciona cDNA' ],
  [ 'btaurus_exonerate_cdna', 'cDNA', 'Cow cDNA' ],
  [ 'dog_cdna', 'cDNA', 'Dog cDNA' ],
  [ 'drosophila_cdna_all', 'cDNA', 'Fly cDNA' ],
  [ 'drosophila_gold_cdna', 'cDNA', 'Fly gold cDNA' ],
  [ 'fugu_cdnas', 'cDNA', 'Fugu cDNA' ],
  [ 'human_cdna', 'cDNA', 'Human cDNA' ],
  [ 'human_cdna_update', 'cDNA', 'Human cDNA (update)' ],
  [ 'cdna_update', 'cDNA', 'cDNA (update)' ],
  [ 'mouse_cdna', 'cDNA', 'Mouse cDNA' ],
  [ 'rat_cdna', 'cDNA', 'Rat cDNA' ],
  [ 'xlaevis_cdna', 'cDNA', 'X.leavis cDNA' ],
  [ 'xtrop_cdna', 'cDNA', 'X.tropicalis cDNA' ],
  [ 'zfish_cdna', 'cDNA', 'Zebrafish cDNA' ],
  [ 'cow_cdna', 'cDNA', 'Cow cDNA' ],
  [ 'harvard_manual', 'cDNA', 'Manually curated anopheles transcript' ],
  [ 'kyotograil_2004', 'cDNA', 'Kyotograil 2004 models' ],
  [ 'kyotograil_2005', 'cDNA', 'Kyotograil 2005 models' ],

  [ 'eg3_f', 'Ecotig', 'Ecotig (Fugu DNA)' ],
  [ 'eg3_h', 'Ecotig', 'Ecotig (Human DNA)' ],
  [ 'eg3_s', 'Ecotig', 'Ecotig (Mouse DNA)' ],
  [ 'ep3_h', 'Ecotig', 'Ecotig (Human Protein)' ],
  [ 'ep3_s', 'Ecotig', 'Ecotig (Mouse Protein)' ],

  [ 'est_bestn_3prim', 'EST', 'Ciona EST' ],
  [ 'est_bestn_5prim', 'EST', 'Ciona EST' ],
  [ 'cint_est',   'EST', 'Ciona EST' ],
  [ 'yeast_est',   'EST', 'Yeast EST' ],
  [ 'macaque_est', 'EST', 'Macaque EST' ],
  [ 'bee_est', 'EST', 'Bee EST' ],
  [ 'beeestalignmentevidence', 'EST', 'Bee EST evidence' ],
  [ 'cbriggsae_est', 'EST', 'C.briggsae EST' ],
  [ 'celegans_est', 'EST', 'C.elegans EST' ],
  [ 'chicken_est', 'EST', 'Chicken EST' ],
  [ 'chicken_est_exonerate', 'EST', 'Chicken EST (exonerate)' ],
  [ 'ciona_est', 'EST', 'Ciona EST' ],
  [ 'btaurus_exonerate_est', 'EST', 'Cow EST' ],
  [ 'drosophila_est', 'EST', 'Fly EST' ],
  [ 'est_cluster_imcb', 'EST', 'Zebrafish EST cluster (IMCB)' ],
  [ 'est_cluster_washu', 'EST', 'Zebrafish EST cluster (WashU)' ],
  [ 'exonerate_est_083', 'EST', 'Ciona EST (083)' ],
  [ 'fugu_est', 'EST', 'Fugu EST' ],
  [ 'human_est', 'EST', 'Human EST' ],
  [ 'human_est_exonerate', 'EST', 'Human EST (exonerate)' ],
  [ 'mouse_est', 'EST', 'Mouse EST' ],
  [ 'other_est', 'EST', 'Other EST' ],
  [ 'rat_est', 'EST', 'Rat EST' ],
  [ 'rna', 'EST', 'Mosquito EST' ],
  [ 'rna', 'EST', 'Mosquito EST (RNA)' ],
  [ 'rna_best', 'EST', 'Mosquito EST (RNA BEST)' ],
  [ 'cow_est', 'EST', 'Cow EST' ],
  [ 'scerevisiae_est', 'EST', 'Yeast EST' ],
  [ 'xlaevis_est', 'EST', 'X.leavis EST' ],
  [ 'xtrop_cluster', 'EST', 'X.tropicalis EST cluster' ],
  [ 'xtrop_est', 'EST', 'X.tropicalis EST' ],
  [ 'zfish_est', 'EST', 'Zebrafish EST' ],
  [ 'estgene', 'EST', 'EST' ],
  [ 'est_gene', 'EST', 'EST' ],
  [ 'anopheles_cdna_est_all', 'cDNA/EST', 'Anopheles cDNA/EST' ],
  [ 'anopheles_cdna_est',     'cDNA/EST', 'Anopheles cDNA/EST' ],

  [ 'cbriggsae_mrna', 'mRNA', 'C.briggsae mRNA' ],
  [ 'celegans_mrna', 'mRNA', 'C.elegans mRNA' ],
  [ 'vertrna', 'mRNA', 'EMBL mRNA' ],

  [ 'unigene', 'Unigene', 'UniGene' ],

## RNA
  [ 'blastmirna',     'RNA', 'miRbase RNA' ],
  [ 'rfamblast',      'RNA', 'RFAM RNA' ],
  [ 'mirbase',        'RNA', 'miRbase RNA' ],
  [ 'mirna_registry', 'RNA', 'miRbase RNA' ],
  [ 'mirna_registry', 'RNA', 'miRbase RNA' ],
  [ 'rfam',           'RNA', 'RFAM RNA' ],
);

my %analysis = map { $_->[0] => [$_->[1],$_->[2]] } @features;

  my $species = $conf->{'species'};
  my $COREDB = $conf->{'dbs'}->{'ENSEMBL_CORE'};    
  my $ESTDB  = $conf->{'dbs'}->{'ENSEMBL_EST'};
  my $CDNADB = $conf->{'dbs'}->{'ENSEMBL_CDNA'};
  my %tables = (
    'dna_align_feature'     => 'DnaAlignFeature',
    'protein_align_feature' => 'ProteinAlignFeature',
  );
  my %errors = ();
  foreach my $table ( keys %tables ) {
    my $source = $tables{ $table };
    my $sth    = $conf->{'dbh'}->prepare(
      "select a.logic_name, t.hit_name, count(*) as hits
         from analysis as a, $table as t
        where a.analysis_id = t.analysis_id
        group by a.logic_name, t.hit_name"
    ); 
    $sth->execute();
    while( my( $logic_name, $hid, $count ) = $sth->fetchrow_array ) { 
      $logic_name = lc($logic_name);
      next if $errors{ $logic_name }; 
      unless( $analysis{ $logic_name } ) {
        warn "UNRECOGNISED LOGIC NAME $species-$logic_name";
        $errors{$logic_name} = 1;
        next;
      }
      my($F,$AN) = @{$analysis{$logic_name}};
      my $string = join "\t", (INC_SPECIES?"$species\t":"")."$F similarity feature: $AN",
        $hid, "/$species/featureview?type=$source;id=$hid",
        $hid, qq($AN $hid hits the genome in $count locations.\n);
      print D $string if $F;
    }
  }
  if( $ESTDB ) {
    my $table  = 'dna_align_feature';
    my $source = 'DnaAlignFeature;db=est';
    my $sth    = $conf->{'dbh'}->prepare(
      "select a.logic_name, t.hit_name, count(*) as hits
         from $ESTDB.analysis as a, $ESTDB.$table as t
        where a.analysis_id = t.analysis_id
        group by a.logic_name, t.hit_name"
    );
    $sth->execute();
    while( my( $logic_name, $hid, $count ) = $sth->fetchrow_array ) {
      $logic_name = lc($logic_name);
      next if $errors{ $logic_name };
      unless( $analysis{ $logic_name } ) {
        warn "UNRECOGNISED LOGIC NAME $species-$logic_name";
        $errors{$logic_name} = 1;
        next;
      }
      my($F,$AN) = @{$analysis{$logic_name}};

      my $string = join "\t", (INC_SPECIES?"$species\t":"")."$F similarity feature: $AN",
        $hid, "/$species/featureview?type=$source;id=$hid",
        $hid, qq(EST ($logic_name) $hid hits the genome in $count locations.\n);
      print D $string;
    }
  }
  if( $CDNADB ) {
    my $table  = 'dna_align_feature';
    my $source = 'DnaAlignFeature;db=cdna';
    my $sth    = $conf->{'dbh'}->prepare(
      "select a.logic_name, t.hit_name, count(*) as hits
         from $CDNADB.analysis as a, $CDNADB.$table as t
        where a.analysis_id = t.analysis_id
        group by a.logic_name, t.hit_name"
    );
    $sth->execute();
    while( my( $logic_name, $hid, $count ) = $sth->fetchrow_array ) {
      $logic_name = lc($logic_name);
      next if $errors{ $logic_name };
      unless( $analysis{ $logic_name } ) {
        warn "UNRECOGNISED LOGIC NAME $species-$logic_name";
        $errors{$logic_name} = 1;
        next;
      }
      my($F,$AN) = @{$analysis{$logic_name}};

      my $string = join "\t", (INC_SPECIES?"$species\t":"")."$F Similarity feature: $AN",
        $hid, "/$species/featureview?type=$source;id=$hid",
        $hid, qq(CDNA ($logic_name) $hid hits the genome in $count locations.\n);
      print D $string;
    }
  }

  close D;
}

sub dumpOligoProbe {
  my $conf = shift;
  open A, ">$conf->{'directory'}/OligoProbe.txt";
  my $species = $conf->{'species'};
  my $COREDB = $conf->{'dbs'}->{'ENSEMBL_CORE'};
  my $sth    = $conf->{'dbh'}->prepare(
    "select p.probeset, count(*) as hits, a.type
       from oligo_probe as p, oligo_feature as f, oligo_array as a
      where p.oligo_probe_id = f.oligo_probe_id and p.oligo_array_id = a.oligo_array_id
      group by p.probeset"
  );
  $sth->execute();
  while( my( $hid, $count, $type ) = $sth->fetchrow_array ) {
    print A join "\t", (INC_SPECIES?"$species\t":"")."$type Oligo Probe set",
      $hid, "/$species/featureview?type=OligoProbe;id=$hid",
      $hid, qq($type oligo probeset $hid hits the genome in $count locations.\n);
  }
  close A;
}


########################################################################## Diseases

sub dumpDisease {
  my $conf = shift;
  my $DISDB   = $conf->{'dbs'}->{'ENSEMBL_DISEASE'};    
  return unless $DISDB;
  my $COREDB   = $conf->{'dbs'}->{'ENSEMBL_CORE'};    
  my $sth = $conf->{'dbh'}->prepare(
    "select distinct concat( g.gene_symbol,':',g.omim_id, ' (',gsi.stable_id,')') as name,
            d.disease, d.disease
       from $DISDB.disease as d,
            $DISDB.gene as g,
            $COREDB.xref as cx, 
            $COREDB.object_xref as cox, 
            $COREDB.translation as tr,
            $COREDB.transcript as t,
            $COREDB.gene_stable_id as gsi 
      where d.id = g.id and cx.display_label = g.omim_id and cx.external_db_id = 1500 and
            cox.xref_id = cx.xref_id and cox.ensembl_id = tr.translation_id and
            tr.transcript_id = t.transcript_id and gsi.gene_id = t.gene_id
      order by disease, g.omim_id, g.gene_symbol"
  );
  $sth->execute();
  open O, ">$conf->{'directory'}/Disease.txt";
  my $old_omim = '';
  my $IDS  = '';
  my $description = '';
  my $old_desc = '';
  my ($gene, $omim, $desc );
  while( ($gene, $omim, $desc ) = $sth->fetchrow_array()){
    if($omim eq $old_omim) {
      $IDS .= " $gene";
      $description .=", $gene";
    } else {
      print O &diseaseLine($conf->{'species'}, $old_omim, $IDS, $description );
      $description = "$desc Genes: $gene";
      $IDS  = "$gene $desc";
      $old_omim = $omim;
    }
  }
  print O &diseaseLine($conf->{'species'}, $old_omim, $IDS, $description );
  close O;
}

use CGI qw(escape escapeHTML);
sub diseaseLine {
  my($species, $did, $IDS, $description) = @_;
  return if $description eq '';
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(OMIM disease),    ## Type
    escapeHTML($did),               ## ID
    qq(/$species/featureview?type=Disease;id=).escape($did),
    qq($did $IDS),     ## Index locations,
    qq(OMIM - $description\n);
}

########################################################################## Domains

sub dumpDomain {
  my $conf = shift;
  my $COREDB = $conf->{'dbs'}->{'ENSEMBL_DB'};
  my $sth = $conf->{'dbh'}->prepare(
    "select x.dbprimary_acc, i.id, x.description
       from $COREDB.xref as x, $COREDB.interpro as i
      where x.dbprimary_acc = i.interpro_ac
      order by x.dbprimary_acc"
  );
  $sth->execute();
  open O, ">$conf->{'directory'}/Domain.txt";
  my $old_acc     = '';
  my $IDS         = '';
  my $description = '';
  my $counter     = 0;
  my ($acc, $id, $desc, $old_desc  );
  while( ($acc, $id, $desc ) = $sth->fetchrow_array()){
    if($acc eq $old_acc) {
      $IDS         .= " $id";
      $description .= ", $id";
      $counter++;
    } else {
      print O &domainLine($conf->{'species'}, $old_acc, $IDS, $old_desc, $counter, $description );
      $description = $id;
      $IDS         = $id;
      $old_acc     = $acc;
      $old_desc    = $desc;
      $counter     = 1;
    }
  }
  print O &domainLine( $conf->{'species'}, $old_acc, $IDS, $old_desc, $counter, $description );
  close O;
}

sub domainLine {
  my($species, $did, $IDS, $desc, $counter, $description) = @_;
  return if $did eq '';
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(Interpro domain),    ## Type
    qq($did),               ## ID
    qq(/$species/domainview?domainentry=$did), ## URL
    qq($did $IDS $desc),     ## Index locations
    qq(InterPro domain $did [$desc] has $counter associated external database identifiers: $description.\n);   ## Description text

}

########################################################################## Families

sub dumpFamily {
    my $conf = shift;
    my $FAMDB = $conf->{'dbs'}->{'ENSEMBL_COMPARA'};
    my $CORE  = $conf->{'dbs'}->{'ENSEMBL_DB'};
    my $t_sth = $conf->{'dbh'}->prepare(
	"select meta_value from $CORE.meta where meta_key='species.taxonomy_id'"
    );
    $t_sth->execute;
    my $taxon_id = ($t_sth->fetchrow);
    return unless $taxon_id;

    my $sth = $conf->{'dbh'}->prepare(
        "select f.stable_id, f.description, m.stable_id
           from $FAMDB.family as f, $FAMDB.family_member as fm, 
                $FAMDB.member as m
          where fm.family_id = f.family_id and fm.member_id = m.member_id and
                m.taxon_id = $taxon_id
          order by f.stable_id, m.stable_id"
    );

    $sth->execute();
    open O, ">$conf->{'directory'}/Family.txt";
    my $old_id      = '';
    my $IDS         = '';
    my $description = '';
    my $counter     = 0;
    my ( $id, $dbid, $desc, $old_desc );
    while( ($id, $desc, $dbid ) = $sth->fetchrow_array()){
        if($id eq $old_id) {
            $IDS         .= " $dbid";
            $description .= ", $dbid" if ($counter <8 );
            $description .= ", ..."   if ($counter == 8 );
            $counter++;
        } else {
            print O &familyLine($conf->{'species'}, $old_id, $IDS, $old_desc, $counter, $description );
            $description = $dbid;
            $IDS         = $dbid;
            $old_id      = $id;
            $old_desc    = $desc;
            $counter     = 1;
        }
    }
    print O &familyLine($conf->{'species'}, $old_id, $IDS, $old_desc, $counter, $description );
    close O;
}

sub familyLine {
    my($species, $fid, $IDS, $desc, $counter, $description) = @_;
    return if $fid eq '';
    return join "\t",
        (INC_SPECIES?"$species\t":"").qq(Ensembl protein family),    ## Type
        qq($fid),               ## ID
        qq(/$species/familyview?family=$fid), ## URL
        qq($fid $IDS $desc),     ## Index locations
        qq(Ensembl protein family $fid [$desc] has $counter members: $description.\n);   ## Description text
}
 
########################################################################## Genes

sub dumpGene {
    my $conf = shift;
    my $COREDB = $conf->{'dbs'}->{'ENSEMBL_DB'};
    my $SANGDB = $conf->{'dbs'}->{'ENSEMBL_VEGA'};
    my $ESTGENEDB = $conf->{'dbs'}->{'ENSEMBL_EST'};
    my %sths = (
        'Ensembl' => $conf->{'dbh'}->prepare(qq(
select gsi.stable_id as gsid, tsi.stable_id as tsid, trsi.stable_id as trsid,
       x.display_label as disp_id, x.dbprimary_acc as db_id, xd.db_display_name as db,
       g.description,
       Z_x.display_label as disp_id_1, Z_x.dbprimary_acc as db_id_1, Z_xd.db_display_name as db_1,
       Y_x.display_label as disp_id_2, Y_x.dbprimary_acc as db_id_2, Y_xd.db_display_name as db_2
  from $COREDB.gene_stable_id as gsi, $COREDB.gene as g,
       $COREDB.transcript_stable_id as tsi,
       $COREDB.transcript as t left join
       $COREDB.translation as tr on t.transcript_id = tr.transcript_id left join
       $COREDB.translation_stable_id as trsi on tr.translation_id = trsi.translation_id left join
       $COREDB.object_xref as ox on tr.translation_id = ox.ensembl_id and ox.ensembl_object_type = 'Translation'
 left join
       $COREDB.xref as x on ox.xref_id = x.xref_id left join
       $COREDB.external_db as xd on xd.external_db_id = x.external_db_id left join
       $COREDB.object_xref as Z_ox on t.transcript_id = Z_ox.ensembl_id and Z_ox.ensembl_object_type = 'Transcript' left join
       $COREDB.xref as Z_x on Z_ox.xref_id = Z_x.xref_id left join
       $COREDB.external_db as Z_xd on Z_xd.external_db_id = Z_x.external_db_id left join
       $COREDB.object_xref as Y_ox on t.gene_id = Y_ox.ensembl_id and Y_ox.ensembl_object_type = 'Gene' left join
       $COREDB.xref as Y_x on Y_ox.xref_id = Y_x.xref_id left join
       $COREDB.external_db as Y_xd on Y_xd.external_db_id = Y_x.external_db_id
 where t.gene_id = gsi.gene_id and t.transcript_id = tsi.transcript_id and t.gene_id = g.gene_id
 order by gsi.stable_id, tsi.stable_id
        ))
    );
    my @TYPES = ( "Ensembl" );

    if( $SANGDB ) {
      $sths{'Vega'} 
        = $conf->{'dbh'}->prepare(qq(
select gsi.stable_id as gsid, tsi.stable_id as tsid, trsi.stable_id as trsid,
       x.display_label as disp_id, x.dbprimary_acc as db_id, xd.db_display_name as db,
       g.description,
       Z_x.display_label as disp_id_1, Z_x.dbprimary_acc as db_id_1, Z_xd.db_display_name as db_1,
       Y_x.display_label as disp_id_2, Y_x.dbprimary_acc as db_id_2, Y_xd.db_display_name as db_2
  from $SANGDB.gene_stable_id as gsi, $SANGDB.gene as g,
       $SANGDB.transcript_stable_id as tsi,
       $SANGDB.transcript as t left join
       $SANGDB.translation as tr on t.transcript_id = tr.transcript_id left join
       $SANGDB.translation_stable_id as trsi on tr.translation_id = trsi.translation_id left join
       $SANGDB.object_xref as ox on tr.translation_id = ox.ensembl_id and ox.ensembl_object_type = 'Translation' left join
       $SANGDB.xref as x on ox.xref_id = x.xref_id left join
       $SANGDB.external_db as xd on xd.external_db_id = x.external_db_id left join
       $SANGDB.object_xref as Z_ox on t.transcript_id = Z_ox.ensembl_id and Z_ox.ensembl_object_type = 'Transcript' left join
       $SANGDB.xref as Z_x on Z_ox.xref_id = Z_x.xref_id left join
       $SANGDB.external_db as Z_xd on Z_xd.external_db_id = Z_x.external_db_id left join
       $SANGDB.object_xref as Y_ox on t.gene_id = Y_ox.ensembl_id and Y_ox.ensembl_object_type = 'gene' left join
       $SANGDB.xref as Y_x on Y_ox.xref_id = Y_x.xref_id left join
       $SANGDB.external_db as Y_xd on Y_xd.external_db_id = Y_x.external_db_id
 where t.gene_id = gsi.gene_id and t.transcript_id = tsi.transcript_id and t.gene_id = g.gene_id
 order by gsi.stable_id, tsi.stable_id
       ));
       push @TYPES, 'Vega';
     }

    if( $ESTGENEDB ) {
    $sths{'Ensembl EST'} = $conf->{'dbh'}->prepare(qq(
select gsi.stable_id as gsid, tsi.stable_id as tsid, trsi.stable_id as trsid,
       x.display_label, x.dbprimary_acc, xd.db_display_name, g.description
  from $ESTGENEDB.gene_stable_id as gsi, $ESTGENEDB.gene as g,
       $ESTGENEDB.transcript_stable_id as tsi,
       $ESTGENEDB.transcript as t left join
       $ESTGENEDB.translation as tr on t.transcript_id = tr.transcript_id left join
       $ESTGENEDB.translation_stable_id as trsi on tr.translation_id = trsi.translation_id left join
       $ESTGENEDB.object_xref as ox on tr.translation_id = ox.ensembl_id and ox.ensembl_object_type = 'Translation' left join
       $ESTGENEDB.xref as x on ox.xref_id = x.xref_id left join
       $ESTGENEDB.external_db as xd on xd.external_db_id = x.external_db_id
 where t.gene_id = gsi.gene_id and t.transcript_id = tsi.transcript_id and t.gene_id = g.gene_id
 order by gsi.stable_id, tsi.stable_id
    ));
	push @TYPES, 'Ensembl EST';
    }

    open O, ">$conf->{'directory'}/Gene.txt";
    foreach my $GENETYPE ( @TYPES ) {
        my $sth = $sths{$GENETYPE};
        $sth->execute();
        my $extras =  $GENETYPE eq 'Vega' ? '&db=vega' : '';
           $extras .= $GENETYPE eq 'Ensembl EST' ? '&db=est' : '';
        my $old_gid     = '';
        my $old_desc     = '';
        my $transcripts = {};
        my $peptides    = {};
        my $external_ids= {};
        my %IDX         = ();
        while( my($gid, $tid, $trid, $dispid, $dbid, $db, $desc, $dispid2,$dbid2,$db2,$dispid3,$dbid3,$db3 ) = $sth->fetchrow_array() ) {
          $desc =~ s/[\r\n\t\s ]+/ /g;
            if($gid eq $old_gid) {
                if( $db ) {
                  $external_ids->{$db}{$dispid}   = 1; $external_ids->{$db}{$dbid}   = 1;
                  $IDX{$dbid}                     = 1; $IDX{$dispid}                 = 1;
                }
                if( $db2 ) {
                  $external_ids->{$db2}{$dispid2} = 1; $external_ids->{$db2}{$dbid2}   = 1;
                  $IDX{$dbid2}                    = 1; $IDX{$dispid2}                 = 1;
                }
                if( $db3 ) {
                  $external_ids->{$db3}{$dispid3} = 1; $external_ids->{$db3}{$dbid3}   = 1;
                  $IDX{$dbid3}                    = 1; $IDX{$dispid3}                 = 1;
                }
                $transcripts->{ $tid }=1;
                $peptides->{ $trid }=1 if $trid;
                $IDX{$tid} = 1;
                $IDX{$trid} = 1 if $trid;
            } else {
                print O &geneLine(
                  $conf->{'species'},
                  $GENETYPE, $old_gid, $extras,
                  join(' ',$old_gid, $old_desc, keys %IDX),
                  $transcripts, $peptides, $external_ids, $old_desc
                );
                $old_gid = $gid;
                $old_desc = $desc;
                $transcripts = { $tid => 1 };
                $peptides = {};
                $peptides->{ $trid } = 1 if $trid;
                $external_ids= {  };
                %IDX         = ( $tid=>1 );
                $IDX{$trid} = 1 if $trid;
                if( $db ) {
                  $external_ids->{$db}{$dispid}   = 1; $external_ids->{$db}{$dbid}   = 1;
                  $IDX{$dbid}                     = 1; $IDX{$dispid}                 = 1;
                }
                if( $db2 ) {
                  $external_ids->{$db2}{$dispid2} = 1; $external_ids->{$db2}{$dbid2}   = 1;
                  $IDX{$dbid2}                    = 1; $IDX{$dispid2}                 = 1;
                }
                if( $db3 ) {
                  $external_ids->{$db3}{$dispid3} = 1; $external_ids->{$db3}{$dbid3}   = 1;
                  $IDX{$dbid3}                    = 1; $IDX{$dispid3}                 = 1;
                }
            }
        }
        print O &geneLine(
            $conf->{'species'},
            $GENETYPE, $old_gid, $extras,
            join(' ',$old_gid, $old_desc, keys %IDX),
            $transcripts, $peptides, $external_ids, $old_desc
        );
    }
    my %old_ids = (
      'Gene' => qq(select distinct sie.old_stable_id, gsi.stable_id 
  from $COREDB.stable_id_event as sie
       left join $COREDB.gene_stable_id as gsi  on gsi.stable_id  = sie.new_stable_id
       left join $COREDB.gene_stable_id as gsio on gsio.stable_id = sie.old_stable_id
 where sie.type = 'gene' and sie.mapping_session_id = 357 and !isnull(sie.old_stable_id) and
       sie.new_stable_id!=sie.old_stable_id and isnull(gsio.stable_id)
 order by sie.old_stable_id, sie.new_stable_id),
      'Transcript' => qq(select distinct sie.old_stable_id, tsi.stable_id 
  from $COREDB.stable_id_event as sie
       left join $COREDB.transcript_stable_id as tsi  on tsi.stable_id  = sie.new_stable_id
       left join $COREDB.transcript_stable_id as tsio on tsio.stable_id = sie.old_stable_id
 where sie.type = 'transcript' and sie.mapping_session_id = 357 and !isnull(sie.old_stable_id) and
       sie.new_stable_id!=sie.old_stable_id  and isnull(tsio.stable_id)
 order by sie.old_stable_id, sie.new_stable_id),
      'Peptide' => qq(select distinct sie.old_stable_id, tsi.stable_id 
  from $COREDB.stable_id_event as sie
       left join $COREDB.translation_stable_id as tsi  on tsi.stable_id  = sie.new_stable_id
       left join $COREDB.translation_stable_id as tsio on tsio.stable_id = sie.old_stable_id
 where sie.type = 'translation' and sie.mapping_session_id = 357 and !isnull(sie.old_stable_id) and
       sie.new_stable_id!=sie.old_stable_id  and isnull(tsio.stable_id)
 order by sie.old_stable_id, sie.new_stable_id)
    );
    foreach my $type ( keys %old_ids ) {
      my $sth = $conf->{'dbh'}->prepare( $old_ids{$type} );
      $sth->execute;
      my $ID = '';
      my @MAP = ();
      while( my($old_id, $new_id ) = $sth->fetchrow_array() ) {
        if( $ID ne $old_id ) {
          print O &geneLineOld( $conf->{'species'}, $type, $ID, @MAP );
          $ID = $old_id;
          @MAP = $new_id ? ($new_id) : ();
        }
      }
      print O &geneLineOld( $conf->{'species'}, $type, $ID, @MAP );
    }
    close O;
}

sub geneLineOld {
  my( $species, $type, $gid, @GIDS ) = @_;
  return unless $gid;
  if( @GIDS ) {
    return join( "\t",
      (INC_SPECIES?"$species\t":"").qq(EnsEMBL $type),
      qq($gid),
      qq(/$species/geneview?).lc($type).qq(=$gid),
      join( ' ', $gid, @GIDS ),
      qq($type $gid is no longer in the Ensembl database but it has been mapped to the following identifiers: @GIDS\n)
    );
  } else {
    return join( "\t",
      (INC_SPECIES?"$species\t":"").qq(EnsEMBL $type),
      qq($gid),
      qq(/$species/geneview?).lc($type).qq(=$gid),
      qq($gid),
      qq($type $gid is no longer in the Ensembl database and it has not been mapped to any new identifiers\n)
    );
  }
}

sub geneLine {
  my ($species, $X, $gid, $extra, $IDX, $transcripts, $peptides, $external_identifiers, $description )=@_;
  return if $gid eq '';
  my $T = scalar (keys %$transcripts);
  my $P = scalar (keys %$peptides);
  my $EX = scalar (keys %$external_identifiers);
  return join( "\t",
    (INC_SPECIES?"$species\t":"").qq($X Gene),
    qq($gid),
    qq(/$species/geneview?gene=$gid$extra),
    qq($IDX),
    qq($X gene $gid has $T transcript).($T==1?'':'s').qq(: ).join(', ',sort keys(%$transcripts)).
    ( $P > 0 ? 
      qq( and associated peptide).($P==1?'':'s').qq(: ).join(', ',sort keys(%$peptides)) : '').
    qq(<br />$description).( $EX>0 ?
      (
        qq(<br />The gene has the following external identifiers mapped to it:<br />).
        ( join '<br />',
          map { "$_: ".(join ", ", keys %{$external_identifiers->{$_}}) }
          sort { lc($a) cmp lc($b) } keys %$external_identifiers
        )
      ) : ''
    ).qq(\n)
  );
}

########################################################################## Sequences

sub dumpSequence {
    my $conf = shift;

    my $sanger = sanger_project_names( $conf );
    my %config = (
      "Homo_sapiens" => [
        [ 'Clone',      'tilepath,cloneset_1mb,cloneset_30k,cloneset_32k', 'name,well_name,clone_name,synonym,embl_acc,sanger_project' ],
        [ 'NT Contig',  'ntctgs',                  'name' ],
        [ 'Encode region', 'encode', 'name,synonym,description' ],
      ],
      "Mus_musculus" => [
        [ 'BAC',        'cloneset_0_5mb,cloneset_1mb,bac_map', 'embl_acc,name' ],
        [ 'Fosmid',     'fosmid_map', 'name' ],
        [ 'Supercontig','superctgs', 'name' ],
        [ 'NT Contig',  'ntctgs',    'name' ],
      ],
      "Anopheles_gambiae" => [
        [ 'BAC' ,       'bacs',        'name,synonym' ],
        [ 'BAC band' ,  'bacs_bands',  'name,synonym' ],
      ]
    );

  my $COREDB   = $conf->{'dbs'}->{'ENSEMBL_DB'};
  open O, ">$conf->{'directory'}/Sequence.txt";
  my @types = @{$config{$conf->{'species'}}||[]};
  foreach my $arrayref ( @types ) {
    my( $TYPE, $mapsets, $annotationtypes ) = @$arrayref;
    my @temp         = split (',',$mapsets);        
    my @mapsets;
    foreach my $X ( @temp ) {
       my $ID = $conf->{'dbh'}->selectrow_array( "select misc_set_id from misc_set where code = ?", {}, $X );
      push @mapsets, $ID if($ID);
    }
    next unless @mapsets;
    @temp = split (',',$annotationtypes);        
    my @mapannotationtypes;
    foreach my $X ( @temp ) {
      my $ID = $conf->{'dbh'}->selectrow_array( "select attrib_type_id from attrib_type where code = ?", {}, $X );
      push @mapannotationtypes, $ID if($ID);
    }
    next unless @mapannotationtypes;
    my $Z = " ma.value";
    my $MAPSETS = join ',',@mapsets;
    my $sth = $conf->{'dbh'}->prepare(
      "select mf.misc_feature_id, sr.name,
              ma.value, mf.seq_region_end-mf.seq_region_start+1 as len, 
              at.code
         from misc_feature_misc_set as ms, 
              misc_feature as mf,
              seq_region   as sr,
              misc_attrib  as ma,
              attrib_type  as at 
        where mf.seq_region_id = sr.seq_region_id and mf.misc_feature_id = ms.misc_feature_id and ms.misc_set_id in ($MAPSETS) and
              mf.misc_feature_id = ma.misc_feature_id and ma.attrib_type_id = at.attrib_type_id
        order by mf.misc_feature_id, at.code"
    );
    $sth->execute();
    my ($oldtype,$old_ID,$oldchr,$emblaccs,$oldlen,$synonyms, $NAME );
    while( my($ID,$chr,$val,$len,$type) = $sth->fetchrow_array() ) {
      if($ID == $old_ID) {
        $NAME = $val if $type eq 'well_name' || $type eq 'clone_name' || $type eq 'name' || $type eq 'non_ref';
        $NAME = $val if !$NAME && $type eq 'embl_acc';
        $NAME = $val if !$NAME && $type eq 'synonym';
        $NAME = $val if !$NAME && $type eq 'sanger_project';
        $emblaccs.=", $val" if $val;
      } else {
        print O &seqLine( $conf->{'species'}, $TYPE, $NAME, $oldchr, $emblaccs,$oldlen,$sanger) if $old_ID;
        $NAME = undef;
        $NAME = $val if $type eq 'well_name' || $type eq 'clone_name' || $type eq 'name' || $type eq 'non_ref';
        $NAME = $val if !$NAME && $type eq 'embl_acc';
        $NAME = $val if !$NAME && $type eq 'synonym';
        $NAME = $val if !$NAME && $type eq 'sanger_project';
        ($old_ID,$oldchr,$emblaccs,$oldlen) = ($ID,$chr,$val,$len);
      }
    }
    print O &seqLine( $conf->{'species'}, $TYPE, $NAME, $oldchr, $emblaccs ,$oldlen,$sanger) if $old_ID;
  }

  my $sth = $conf->{'dbh'}->prepare(
    "select c.name, c.length, cs.name
       from seq_region as c, coord_system as cs
      where c.coord_system_id = cs.coord_system_id" );
  $sth->execute();
  while( my($name,$length,$type) = $sth->fetchrow_array() ) {
    my $extra_IDS = ''; my $extra_desc = '';
    if( %{$sanger->{$name}||{}} ) {
      $extra_IDS  = join ' ', '',sort keys %{$sanger->{$name}};
      $extra_desc = " and corresponds to the following Sanger projects: ".join( ', ',sort keys %{$sanger->{$name}});
    }
    print O join "\t",
      (INC_SPECIES?"$conf->{'species'}\t":"").ucfirst($type),       $name,
      ($type eq 'chromosome' && length( $name ) < 5) ?
        "/$conf->{'species'}/mapview?chr=$name" :
        ($length > 0.5e6 ? "/$conf->{'species'}/cytoview?region=$name" :
              "/$conf->{'species'}/contigview?region=$name" ),
      "$name$extra_IDS", "$name is a @{[ucfirst($type)]} (of length $length)$extra_desc\n";
  }
  close O;
}

sub seqLine {
  my($species,$type,$name,$chr,$val,$len,$sanger) = @_;
  my $Q = $val; $Q=~s/,//g;
  my $SCRIPT = $len > 0.5e6 ? 'cytoview' : 'contigview';
  my $extra_IDS = '';
  my $extra_desc = '';
  my %HASH;
  foreach ( split / +/,"$name $val" ) {
    foreach( keys %{$sanger->{$name}||{}} ) {
      $HASH{$_}=1;
    }
  }
  if( %HASH ) {
    $extra_IDS  = join ' ', '',sort keys %HASH;
    $extra_desc = " and corresponds to the following Sanger projects: ".join( ', ',sort keys %HASH );
  }

  return join "\t",
    (INC_SPECIES?"$species\t":"").$type,
    $name, "/$species/$SCRIPT?mapfrag=$name",
    "$name $Q$extra_IDS",
    "$type $name is mapped to Chromosome $chr, and has". (($val &&  ($val ne "")) ? " EMBL accession(s)/synonyms $val and " : "").
    " length $len bps$extra_desc\n";
}

########################################################################## Sanger Projects

sub sanger_project_names {
  my $conf = shift;
  my %SPECIES = qw(
    Homo_sapiens Human Mus_musculus Mouse Danio_rerio Zebradish
    Drosophila_melanogaster Drosophila Rattus_norvegicus Rat
  );
  my $sanger_species_name = $SPECIES{$conf->{'species'}};
  return {} unless $sanger_species_name;
  my $clones = {};
  my $dbh = DBI->connect("DBI:mysql:host=otterlive;port=3301;database=submissions", 'ottro', undef, {RaiseError => 1});
  unless( $dbh ) {
    warn "Can't connect to submissions database as 'read_only' ", DBI::errstr();
    return $clones;
  }
  my $sth = $dbh->prepare(
    "SELECT distinct a.project_name, a.accession 
       FROM project_acc a, project_dump d,
            sequence s, species_chromosome c
      WHERE a.sanger_id = d.sanger_id AND d.seq_id = s.seq_id
        AND s.chromosome_id = c.chromosome_id 
        AND c.species_name = '$sanger_species_name' AND a.accession != 'UNKNOWN'"
  );
  $sth->execute(  );
  while( my ($proj, $acc) = $sth->fetchrow() ) {
    $clones->{$acc}{$proj}=1;
  }
  return $clones;
}

