#!/usr/local/bin/perl

use strict;

my $ENSEMBL_ROOT;

BEGIN {
  use FindBin qw($Bin);
  use File::Basename qw( dirname );
  $ENSEMBL_ROOT = dirname( $Bin );
  $ENSEMBL_ROOT =~ s/\/utils$//;
}

use lib "$ENSEMBL_ROOT/modules";

package indexDumper;

use constant INC_SPECIES => 0;
use CGI;
use EnsEMBL::Web::IndexSupport;

my ( $SPECIES_STRING, @indexes) = @ARGV;

## HACK 1 - if the INDEX is set to all grab all dumper methods...
@indexes = map { /dump(\w+)/?$1:() } keys %indexDumper:: if $indexes[0] eq 'ALL';

## HACK 2 - if the SPECIES is set to ALL grab stuff from config...
$SPECIES_STRING = join ':', keys %{EnsEMBL::Web::IndexSupport->new()->short_codes} if $SPECIES_STRING eq 'ALL';

# EnsEMBL::Web::IndexSupport takes path to conf, path to files, species
my $conf;
mkdir 'input', 0777 unless -e 'input';

foreach my $SPECIES ( split /:/,$SPECIES_STRING) {
  $conf = EnsEMBL::Web::IndexSupport->new( "$ENSEMBL_ROOT/conf", "input", $SPECIES );
  mkdir $conf->{'directory'}, 0777 unless -e $conf->{'directory'};
  warn( "Species: $SPECIES - $conf->{'directory'}" );
  foreach my $INDEX (@indexes) {
    warn "  Index: $INDEX";
    my $function = "dump$INDEX";
    no strict "refs";
    &$function( $conf );
  }
}

## Now for all the dump functions...............................

########################################################################## QTLs

sub dumpQTL {
  my $conf = shift;
  my $sth = $conf->{'dbh'}->prepare(qq(
 select c.name as chr, qf.seq_region_start, qf.seq_region_end,
        a.logic_name as analysis, q.qtl_id,
        q.trait, qs.source_database, qs.source_primary_id,
        fms1.source as fm1_source, fms1.name as fm1_name,
        fms2.source as fm2_source, fms2.name as fm2_name,
        pms.source  as pm_source,  pms.name  as pm_name
   from seq_region as c, qtl_feature as qf, qtl_synonym as qs ,
        analysis as a, qtl as q left join marker as fm1 on
        fm1.marker_id = q.flank_marker_id_1 left join marker_synonym as fms1 on
        fm1.display_marker_synonym_id = fms1.marker_synonym_id left join marker as fm2 on
        fm2.marker_id = q.flank_marker_id_2 left join marker_synonym as fms2 on
        fm2.display_marker_synonym_id = fms2.marker_synonym_id left join marker as pm on
        pm.marker_id = q.peak_marker_id left join marker_synonym as pms on
        pm.display_marker_synonym_id = pms.marker_synonym_id 
  where c.seq_region_id = qf.seq_region_id and qs.qtl_id = q.qtl_id and 
        qf.analysis_id = a.analysis_id and qf.qtl_id = q.qtl_id
  ));
  $sth->execute();
  open O, ">$conf->{'directory'}/QTL.txt";
  my $desc       = '';
  my $old_qtl = 0;
  my $old_ID  = '';
  my $old_pos = '';
  my $IDS;
  while( my $T = $sth->fetchrow_hashref() ){
    if($T->{qtl_id} eq $old_qtl) {
      $IDS  .= " $T->{source_primary_id}";
      $desc .= " $T->{source_database}:$T->{source_primary_id}";
    } else {
      print O &QTLLine( $conf->{'species'}, $old_ID, $old_pos, $IDS,$desc );
      $IDS = "$T->{trait} $T->{source_primary_id}";
      $IDS.= " $T->{fm1_name}" if $T->{fm1_name};
      $IDS.= " $T->{fm2_name}" if $T->{fm2_name};
      $IDS.= " $T->{pm_name}" if $T->{pm_name};
      $old_ID = $T->{pm_name};
      $old_pos = "$T->{chr}:".($T->{seq_region_start}-1e4).'-'.($T->{seq_region_end}+1e4);
      $desc       = "QTL exhibiting '$T->{trait}' has ";
      my $f2 = $T->{pm_name} ? 1 : 0;
      if( $T->{fm1_name} || $T->{fm2_name} ) {
        my $f1= ($T->{fm1_name}) && ($T->{fm2_name}) ? 1 : 0;
        $desc.='flanking marker'.($f1?'s ':' ').$T->{fm1_name}.($f1?' and ':'').$T->{fm2_name}.($f2?'; ':'');
      }
      if($f2) {
        $desc.= "peak marker $T->{pm_name};";
      }
      $desc.=" and names: $T->{source_database}:$T->{source_primary_id}";
      $old_qtl = $T->{qtl_id};
    }
  }
  print O &QTLLine( $conf->{'species'}, $old_ID,$old_pos, $IDS,$desc );
  close O;
}

sub QTLLine {
  my ($species, $trait, $pos, $IDS, $desc ) = @_;
  return if $trait eq '';
  return join "\t", (INC_SPECIES?"$conf->{'species'}\t":"").qq(QTL),
    $trait, "/$conf->{'species'}/contigview?l=$pos", $IDS, "$desc\n";
}

########################################################################## SNPs


sub dumpSNP {
  my $conf = shift;
  my $SNPDB = $conf->{'dbs'}->{'ENSEMBL_VARIATION'};
  return unless $SNPDB;
  my %SOURCES = map { @$_ } @{$conf->{'dbh'}->selectall_arrayref( "select source_id, name from $SNPDB.source" )};
  my $sth = $conf->{'dbh'}->prepare(
    "select v.source_id as o1, v.name as o2, vs.source_id as o3, vs.name as o4
       from $SNPDB.variation as v left join $SNPDB.variation_synonym as vs on vs.variation_id = v.variation_id
      order by o1,o2,o3,o4"
  );
  $sth->execute();
  my $old = {}; my $desc; my $IDS;
  open O, ">$conf->{'directory'}/SNP2.txt";
  while( my $T= $sth->fetchrow_hashref()) {
    if($T->{o1} eq $old->{o1} && $T->{o2} eq $old->{o2}) {
      $desc.= ", ".$SOURCES{$T->{o3}}.":$T->{o4}";
      $IDS .= " $T->{o4}";
    } else {
      print O &snpLine( $conf->{'species'}, $SOURCES{$old->{o1}}, $old->{o2}, $IDS, $desc);
      $IDS = $T->{o2};
      $desc = '';
      if( $T->{o3} ) {
        $desc .= ", ".$SOURCES{$T->{o3}}.":$T->{o4}";
        $IDS  .= " $T->{o4}";
      }
      $old = {%$T};
    }
  }
  print O &snpLine( $conf->{'species'}, $SOURCES{$old->{o1}}, $old->{o2}, $IDS, $desc);
  close O;
}

sub snpLine {
  my ($species, $source, $snpid, $IDS, $desc ) =@_;
  return if $snpid eq '';
  $desc =~ s/^, //;
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(EnsEMBL SNP),
    $snpid,
    "/$species/snpview?snp=$snpid&source=$source",
    "$IDS",
    "SNP $snpid. Alternative IDs: $desc.\n";
}



########################################################################## Markers

sub dumpMarker {
  my $conf = shift;
  my $sth = $conf->{'dbh'}->prepare(qq(
   select ms2.name, ms1.name
     from marker_synonym as ms1, marker_synonym as ms2, marker as m
    where ms1.marker_id = m.marker_id and ms2.marker_synonym_id = m.display_marker_synonym_id
    order by ms2.name
  ));

  $sth->execute( );

  open O, ">$conf->{'directory'}/Marker.txt";
  my $counter    = 0;
  my $desc       = '';
  my $old_marker = '';
  my ($marker,$synonym);
  while( ($marker,$synonym) = $sth->fetchrow_array()){
    if($marker eq $old_marker) {
      $desc .= " $synonym";
      $counter++;
    } else {
      print O &markerLine( $conf->{'species'}, $desc, $counter );
      $desc       = "$synonym";
      $old_marker = $marker;
      $counter    = 1;
    }
  }
  print O &markerLine( $conf->{'species'}, $desc, $counter );
  close O;
}

sub markerLine {
  my( $species, $IDS, $counter ) = @_;
  return if $counter == 0;
  my @synonyms = sort split /\s+/, $IDS;
  my $key = pop @synonyms;
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(EnsEMBL Marker),    ## Type
    qq($key),               ## ID
    qq(/$species/markerview?marker=$key),
    qq($IDS),     ## Index locations,
    qq(A marker with $counter synonyms ($IDS)\n);
}

########################################################################## Similarity features

sub dumpFeature {
  my $conf = shift;
  open D, ">$conf->{'directory'}/MRNA.txt";
  open P, ">$conf->{'directory'}/Protein.txt";
  open U, ">$conf->{'directory'}/Unigene.txt";
  open E, ">$conf->{'directory'}/EST.txt";
  my  %analysis = (
    'BLASTX_ENS_HUM'     => [ 'P','Ensembl Human peptide'],
    'BLASTX_ENS_MUS'     => [ 'P','Ensembl Mouse peptide'],
    'BLASTX_HUM_GENSCAN' => [ 'P','Ensembl Human genscan'],
    'BLASTX_SPROT'       => [ 'P','SWISSPROT peptide'],
    'BLASTX_TREMBL'      => [ 'P','TrEMBL peptide'],
'Swall'   => [ 'P', 'UniProt peptide' ],
'Uniprot' => [ 'P', 'UniProt peptide' ],
'swall'   => [ 'P', 'UniProt peptide' ],
'swall_high_sens'   => [ 'P', 'UniProt peptide' ],
'Unigene' => [ 'U', 'Unigene feature' ],
'Vertrna' => [ 'D', 'EMBL mRNA' ],
'WormPep'         => [ 'P', 'WormPep peptide' ],
'human_est_exonerate'   => [ 'E', 'H.sapiens EST' ],
'cbriggsae_est'   => [ 'E', 'C.briggsae EST' ],
'cbriggsae_mrna'  => [ 'D', 'C.briggsae mRNA' ],
'xlaevis_CDNA'    => [ 'D', 'X.laevis cDNA' ],
'xlaevis_EST'     => [ 'E', 'X.laevis EST' ],
'xtrop_CDNA'      => [ 'D', 'X.tropicalis cDNA' ],
'xtrop_cluster'   => [ 'E', 'X.tropicalis EST cluster' ],
'celegans_est'    => [ 'E', 'C.elegans EST' ],
'celegans_mrna'   => [ 'D', 'C.elegans mRNA' ],
'zfish_cDNA'      => [ 'D', 'D.rerio cDNA' ],
'fugu_cdnas'      => [ 'D', 'F.rubripes cDNA' ],
'zfish_EST'       => [ 'E', 'D.rerio EST' ],
'human_cdna'      => [ 'D', 'H.sapiens cDNA' ],
'human_refseq'    => [ 'P', 'H.sapiens RefSeq' ],
'mouse_refseq'    => [ 'P', 'M.musculus RefSeq' ],
'human_est'       => [ 'E', 'H.sapiens EST' ],
'human_protein'   => [ 'P', 'H.sapiens peptide' ],
'chicken_cdna'      => [ 'D', 'G.gallus cDNA' ],
'chicken_est'       => [ 'E', 'G.gallus EST' ],
'chicken_protein'   => [ 'P', 'G.gallus peptide' ],
'mouse_cdna'      => [ 'D', 'M.musculus cDNA' ],
'mouse_est'       => [ 'E', 'M.musculus EST' ],
'mouse_protein'   => [ 'P', 'M.musculus peptide' ],
'dog_cdna'      => [ 'D', 'C.familiaris cDNA' ],
'dog_est'       => [ 'E', 'C.familiaris EST' ],
'dog_protein'   => [ 'P', 'C.familiaris peptide' ],
'other_est'       => [ 'E', 'Other EST' ],
'other_protein'   => [ 'P', 'Other peptide' ],
'pasteur_est'     => [ 'E', 'Pasteur EST' ],
'anopheles_peptides'   => [ 'P', 'A.gambiae peptide' ],
'drosophila_peptides'   => [ 'P', 'D.melanogaster peptide' ],
'bee_pep_evidence'   => [ 'P', 'A.mellifera peptide' ],
'drosophila-peptides'   => [ 'P', 'D.melanogaster peptide' ],
'PipelineExonerate-50-90-28-7-04'   => [ 'E', 'Bee EST evidence' ],
'rat_cdna'        => [ 'D', 'R.norvegicus cDNA' ],
'rat_est'         => [ 'E', 'R.norvegicus EST' ],
'RNA'             => [ 'E', 'ESTs (RNA)' ],
'RNA_BEST'        => [ 'E', 'ESTs (RNA best)' ],
'rodent_protein'  => [ 'P', 'Rodent peptide' ],
'z_dbest'         => [ 'E', 'EST' ],
'ex_e2g_feat'     => [ 'E', 'EST' ],
'exonerate'       => [ 'E', 'EST' ],
'EP3_H'       => [ 'D', 'Ecotig (Human prot)' ],
'EP3_S'       => [ 'D', 'Ecotig (Mouse prot)' ],
'EG3_H'       => [ 'D', 'Ecotig (Human DNA)' ],
'EG3_S'       => [ 'D', 'Ecotig (Mouse DNA)' ],
'EG3_F'       => [ 'D', 'Ecotig (Fugu DNA)' ],
'CDM'         => [ 'D', 'Tetraodon cDNAs' ],
'ep3_h'       => [ 'D', 'Ecotig (Human prot)' ],
'ep3_s'       => [ 'D', 'Ecotig (Mouse prot)' ],
'EST_cluster_WashU' => [ 'E', 'EST cluster (WashU)' ],
'EST_cluster_IMCB' => [ 'E', 'EST cluster (IMCB)' ],
  );
  my $species = $conf->{'species'};
  my $COREDB = $conf->{'dbs'}->{'ENSEMBL_CORE'};    
  my $ESTDB  = $conf->{'dbs'}->{'ENSEMBL_EST'};
  my %tables = (
    'dna_align_feature'     => 'DnaAlignFeature',
    'protein_align_feature' => 'ProteinAlignFeature',
  );
  my %errors = ();
  foreach my $table ( keys %tables ) {
    my $source = $tables{ $table };
    my $sth    = $conf->{'dbh'}->prepare(
      "select a.logic_name, t.hit_name, count(*) as hits
         from analysis as a, $table as t
        where a.analysis_id = t.analysis_id
        group by a.logic_name, t.hit_name"
    ); 
    $sth->execute();
    while( my( $logic_name, $hid, $count ) = $sth->fetchrow_array ) {
      next if $errors{ $logic_name }; 
      unless( $analysis{$logic_name} ) {
        warn "UNRECOGNISED LOGIC NAME $species-$logic_name";
        $errors{$logic_name} = 1;
        next;
      }
      my($F,$AN) = @{$analysis{$logic_name}};
      my $string = join "\t", (INC_SPECIES?"$species\t":"")."Similarity feature: $AN",
        $hid, "/$species/featureview?type=$source&id=$hid",
        $hid, qq($AN $hid hits the genome in $count locations.\n);
      if($F eq 'D') { print D $string; } 
      elsif($F eq 'P') { print P $string; }
      elsif($F eq 'U') { print U $string; }
      elsif($F eq 'E') { print E $string; }
    }
  }
  my $table  = 'dna_align_feature';
  my $source = 'DnaAlignFeature&db=est';
  my $sth    = $conf->{'dbh'}->prepare(
    "select a.logic_name, t.hit_name, count(*) as hits
       from $ESTDB.analysis as a, $ESTDB.$table as t
      where a.analysis_id = t.analysis_id
      group by a.logic_name, t.hit_name"
  );
  $sth->execute();
  while( my( $logic_name, $hid, $count ) = $sth->fetchrow_array ) {
  #  my $AN = $analysis{$logic_name};
    my $string = join "\t", (INC_SPECIES?"$species\t":"")."Similarity feature: EST",
      $hid, "/$species/featureview?type=$source&id=$hid",
      $hid, qq(EST ($logic_name) $hid hits the genome in $count locations.\n);
    print E $string;
  }

  close E;
  close D;
  close U;
  close P;
}

sub dumpAffyProbe {
  my $conf = shift;
  warn "FILE: $conf->{'directory'}/AffyProbe.txt";
  open A, ">$conf->{'directory'}/AffyProbe.txt";
  my $species = $conf->{'species'};
  my $COREDB = $conf->{'dbs'}->{'ENSEMBL_CORE'};
  my $sth    = $conf->{'dbh'}->prepare(
    "select p.probeset, count(*) as hits
       from affy_probe as p, affy_feature as f
      where p.affy_probe_id = f.affy_probe_id
      group by p.probeset"
  );
  $sth->execute();
  while( my( $hid, $count ) = $sth->fetchrow_array ) {
    print A join "\t", (INC_SPECIES?"$species\t":"")."Affymetrix Probe set",
      $hid, "/$species/featureview?type=AffyProbe&id=$hid",
      $hid, qq(Affymetric probeset $hid hits the genome in $count locations.\n);
  }
  close A;
}


########################################################################## Diseases

sub dumpDisease {
  my $conf = shift;
  my $DISDB   = $conf->{'dbs'}->{'ENSEMBL_DISEASE'};    
  return unless $DISDB;
  my $COREDB   = $conf->{'dbs'}->{'ENSEMBL_CORE'};    
  my $sth = $conf->{'dbh'}->prepare(
    "select if(isnull(gsi.stable_id), g.gene_symbol,
            concat( g.gene_symbol, ' (',gsi.stable_id,')') )as name,
            g.omim_id, d.disease
       from $DISDB.disease as d,
            $DISDB.gene as g left join
            $COREDB.xref as cx on cx.display_label = g.gene_symbol left join
            $COREDB.object_xref as cox on cox.xref_id = cx.xref_id left join
            $COREDB.translation as tr on cox.ensembl_id = tr.translation_id left join
            $COREDB.transcript as t on tr.transcript_id = t.transcript_id left join
            $COREDB.gene_stable_id as gsi on gsi.gene_id = t.gene_id
      where d.id = g.id;"
  );
  $sth->execute();
  open O, ">$conf->{'directory'}/Disease.txt";
  my $old_omim = '';
  my $IDS  = '';
  my $description = '';
  my $old_desc = '';
  my ($gene, $omim, $desc );
  while( ($gene, $omim, $desc ) = $sth->fetchrow_array()){
    if($omim eq $old_omim) {
      $IDS .= " $gene";
      $description .=", $gene";
    } else {
      print O &diseaseLine($conf->{'species'}, $old_omim, $IDS, $old_desc, $description );
      $old_desc = $desc;
      $description = "Genes: $gene";
      $IDS  = "$desc $gene";
      $old_omim = $omim;
    }
  }
  print O &diseaseLine($conf->{'species'}, $old_omim, $IDS, $old_desc, $description );
  close O;
}

sub diseaseLine {
  my($species, $did, $IDS, $desc, $description) = @_;
  return if $description eq '';
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(OMIM disease),    ## Type
    qq($desc),               ## ID
    qq(/$species/diseaseview?disease=).&CGI::escape($desc), ## URL
    qq($did $IDS),     ## Index locations,
    qq(OMIM - $did $description\n);
}

########################################################################## Domains

sub dumpDomain {
  my $conf = shift;
  my $COREDB = $conf->{'dbs'}->{'ENSEMBL_DB'};
  my $sth = $conf->{'dbh'}->prepare(
    "select x.dbprimary_acc, i.id, x.description
       from $COREDB.xref as x, $COREDB.interpro as i
      where x.dbprimary_acc = i.interpro_ac
      order by x.dbprimary_acc"
  );
  $sth->execute();
  open O, ">$conf->{'directory'}/Domain.txt";
  my $old_acc     = '';
  my $IDS         = '';
  my $description = '';
  my $counter     = 0;
  my ($acc, $id, $desc, $old_desc  );
  while( ($acc, $id, $desc ) = $sth->fetchrow_array()){
    if($acc eq $old_acc) {
      $IDS         .= " $id";
      $description .= ", $id";
      $counter++;
    } else {
      print O &domainLine($conf->{'species'}, $old_acc, $IDS, $old_desc, $counter, $description );
      $description = $id;
      $IDS         = $id;
      $old_acc     = $acc;
      $old_desc    = $desc;
      $counter     = 1;
    }
  }
  print O &domainLine( $conf->{'species'}, $old_acc, $IDS, $old_desc, $counter, $description );
  close O;
}

sub domainLine {
  my($species, $did, $IDS, $desc, $counter, $description) = @_;
  return if $did eq '';
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(Interpro domain),    ## Type
    qq($did),               ## ID
    qq(/$species/domainview?domainentry=$did), ## URL
    qq($did $IDS $desc),     ## Index locations
    qq(InterPro domain $did [$desc] has $counter associated external database identifiers: $description.\n);   ## Description text

}

########################################################################## Families

sub dumpFamily {
    my $conf = shift;
    my $FAMDB = $conf->{'dbs'}->{'ENSEMBL_COMPARA'};
    my $CORE  = $conf->{'dbs'}->{'ENSEMBL_DB'};
    my $t_sth = $conf->{'dbh'}->prepare(
	"select meta_value from $CORE.meta where meta_key='species.taxonomy_id'"
    );
    $t_sth->execute;
    my $taxon_id = ($t_sth->fetchrow);
    return unless $taxon_id;

    my $sth = $conf->{'dbh'}->prepare(
        "select f.stable_id, f.description, m.stable_id
           from $FAMDB.family as f, $FAMDB.family_member as fm, 
                $FAMDB.member as m
          where fm.family_id = f.family_id and fm.member_id = m.member_id and
                m.taxon_id = $taxon_id
          order by f.stable_id, m.stable_id"
    );

    $sth->execute();
    open O, ">$conf->{'directory'}/Family.txt";
    my $old_id      = '';
    my $IDS         = '';
    my $description = '';
    my $counter     = 0;
    my ( $id, $dbid, $desc, $old_desc );
    while( ($id, $desc, $dbid ) = $sth->fetchrow_array()){
        if($id eq $old_id) {
            $IDS         .= " $dbid";
            $description .= ", $dbid" if ($counter <8 );
            $description .= ", ..."   if ($counter == 8 );
            $counter++;
        } else {
            print O &familyLine($conf->{'species'}, $old_id, $IDS, $old_desc, $counter, $description );
            $description = $dbid;
            $IDS         = $dbid;
            $old_id      = $id;
            $old_desc    = $desc;
            $counter     = 1;
        }
    }
    print O &familyLine($conf->{'species'}, $old_id, $IDS, $old_desc, $counter, $description );
    close O;
}

sub familyLine {
    my($species, $fid, $IDS, $desc, $counter, $description) = @_;
    return if $fid eq '';
    return join "\t",
        (INC_SPECIES?"$species\t":"").qq(EnsEMBL protein family),    ## Type
        qq($fid),               ## ID
        qq(/$species/familyview?family=$fid), ## URL
        qq($fid $IDS $desc),     ## Index locations
        qq(EnsEMBL protein family $fid [$desc] has $counter members: $description.\n);   ## Description text
}

########################################################################## Genes

sub dumpGene {
    my $conf = shift;
    my $COREDB = $conf->{'dbs'}->{'ENSEMBL_DB'};
    my $SANGDB = $conf->{'dbs'}->{'ENSEMBL_VEGA'};
    my $ESTGENEDB = $conf->{'dbs'}->{'ENSEMBL_ESTGENE'};
    my %sths = (
        'Ensembl' => $conf->{'dbh'}->prepare(qq(
select gsi.stable_id as gsid, tsi.stable_id as tsid, x.display_label, x.dbprimary_acc, xd.db_name, gd.description
  from $COREDB.gene_stable_id as gsi,
       $COREDB.transcript_stable_id as tsi,
       $COREDB.transcript as t left join
       $COREDB.translation as tr on t.transcript_id = tr.transcript_id left join
       $COREDB.object_xref as ox on tr.translation_id = ox.ensembl_id and ox.ensembl_object_type = 'Translation' left join
       $COREDB.xref as x on ox.xref_id = x.xref_id left join
       $COREDB.external_db as xd on xd.external_db_id = x.external_db_id left join
       $COREDB.gene_description as gd on gd.gene_id = gsi.gene_id
 where t.gene_id = gsi.gene_id and t.transcript_id = tsi.transcript_id
 order by gsi.stable_id, tsi.stable_id
        ))
    );
    my @TYPES = ( "Ensembl" );

    if( $SANGDB ) {
      $sths{'Vega'} 
        = $conf->{'dbh'}->prepare(qq(
select gsi.stable_id as gsid, tsi.stable_id as tsid,
       x.display_label as disp_id, x.dbprimary_acc as db_id, xd.db_name as db,
       gd.description,
       Z_x.display_label as disp_id_1, Z_x.dbprimary_acc as db_id_1, Z_xd.db_name as db_1,
       Y_x.display_label as disp_id_2, Y_x.dbprimary_acc as db_id_2, Y_xd.db_name as db_2
  from $SANGDB.gene_stable_id as gsi,
       $SANGDB.transcript_stable_id as tsi,
       $SANGDB.transcript as t left join
       $COREDB.translation as tr on t.transcript_id = tr.transcript_id left join
       $SANGDB.object_xref as ox on tr.translation_id = ox.ensembl_id and ox.ensembl_object_type = 'Translation' left join
       $SANGDB.xref as x on ox.xref_id = x.xref_id left join
       $SANGDB.external_db as xd on xd.external_db_id = x.external_db_id left join
       $SANGDB.object_xref as Z_ox on t.transcript_id = Z_ox.ensembl_id and Z_ox.ensembl_object_type = 'Transcript' left join
       $SANGDB.xref as Z_x on Z_ox.xref_id = Z_x.xref_id left join
       $SANGDB.external_db as Z_xd on Z_xd.external_db_id = Z_x.external_db_id left join
       $SANGDB.object_xref as Y_ox on t.gene_id = Y_ox.ensembl_id and Y_ox.ensembl_object_type = 'Gene' left join
       $SANGDB.xref as Y_x on Y_ox.xref_id = Y_x.xref_id left join
       $SANGDB.external_db as Y_xd on Y_xd.external_db_id = Y_x.external_db_id left join
       $SANGDB.gene_description as gd on gd.gene_id = gsi.gene_id
 where t.gene_id = gsi.gene_id and t.transcript_id = tsi.transcript_id
 order by gsi.stable_id, tsi.stable_id
       ));
       push @TYPES, 'Vega';
     }

    if( $ESTGENEDB ) {
    $sths{'Ensembl EST'} = $conf->{'dbh'}->prepare(qq(
select gsi.stable_id as gsid, tsi.stable_id as tsid, x.display_label, x.dbprimary_acc, xd.db_name, gd.description
  from $ESTGENEDB.gene_stable_id as gsi,
       $ESTGENEDB.transcript_stable_id as tsi,
       $ESTGENEDB.transcript as t left join
       $COREDB.translation as tr on t.transcript_id = tr.transcript_id left join
       $ESTGENEDB.object_xref as ox on tr.translation_id = ox.ensembl_id and ox.ensembl_object_type = 'Translation' left join
       $ESTGENEDB.xref as x on ox.xref_id = x.xref_id left join
       $ESTGENEDB.external_db as xd on xd.external_db_id = x.external_db_id left join
       $ESTGENEDB.gene_description as gd on gd.gene_id = gsi.gene_id
 where t.gene_id = gsi.gene_id and t.transcript_id = tsi.transcript_id
 order by gsi.stable_id, tsi.stable_id
    ));
	push @TYPES, 'Ensembl EST';
    }

    open O, ">$conf->{'directory'}/Gene.txt";
    foreach my $GENETYPE ( @TYPES ) {
        my $sth = $sths{$GENETYPE};
        $sth->execute();
        my $extras =  $GENETYPE eq 'Vega' ? '&db=vega' : '';
           $extras .= $GENETYPE eq 'Ensembl EST' ? '&db=estgene' : '';
        my $old_gid     = '';
        my $old_desc     = '';
        my $transcripts = {};
        my $external_ids= {};
        my %IDX         = ();
        while( my($gid, $tid, $dispid, $dbid, $db, $desc, $dispid2,$dbid2,$db2,$dispid3,$dbid3,$db3 ) = $sth->fetchrow_array() ) {
            if($gid eq $old_gid) {
                if( $db ) {
                  $external_ids->{$db}{$dispid}   = 1; $external_ids->{$db}{$dbid}   = 1;
                  $IDX{$dbid}                     = 1; $IDX{$dispid}                 = 1;
                }
                if( $db2 ) {
                  $external_ids->{$db2}{$dispid2} = 1; $external_ids->{$db2}{$dbid2}   = 1;
                  $IDX{$dbid2}                    = 1; $IDX{$dispid2}                 = 1;
                }
                if( $db3 ) {
                  $external_ids->{$db3}{$dispid3} = 1; $external_ids->{$db3}{$dbid3}   = 1;
                  $IDX{$dbid3}                    = 1; $IDX{$dispid3}                 = 1;
                }
                $transcripts->{ $tid }=1;
                $IDX{$tid} = 1;
            } else {
                print O &geneLine(
                  $conf->{'species'},
                  $GENETYPE, $old_gid, $extras,
                  join(' ',$old_gid, $old_desc, keys %IDX),
                  $transcripts, $external_ids, $old_desc
                );
                $old_gid = $gid;
                $old_desc = $desc;
                $transcripts = { $tid => 1 };
                $external_ids= {  };
                %IDX         = ( $tid=>1 );
                if( $db ) {
                  $external_ids->{$db}{$dispid}   = 1; $external_ids->{$db}{$dbid}   = 1;
                  $IDX{$dbid}                     = 1; $IDX{$dispid}                 = 1;
                }
                if( $db2 ) {
                  $external_ids->{$db2}{$dispid2} = 1; $external_ids->{$db2}{$dbid2}   = 1;
                  $IDX{$dbid2}                    = 1; $IDX{$dispid2}                 = 1;
                }
                if( $db3 ) {
                  $external_ids->{$db3}{$dispid3} = 1; $external_ids->{$db3}{$dbid3}   = 1;
                  $IDX{$dbid3}                    = 1; $IDX{$dispid3}                 = 1;
                }
            }
        }
        print O &geneLine(
            $conf->{'species'},
            $GENETYPE, $old_gid, $extras,
            join(' ',$old_gid, $old_desc, keys %IDX),
            $transcripts, $external_ids, $old_desc
        );
    }
    close O;
}

sub geneLine {
  my ($species, $X, $gid, $extra, $IDX, $transcripts, $external_identifiers, $description )=@_;
  return if $gid eq '';
  my $T = scalar (keys %$transcripts);
  my $EX = scalar (keys %$external_identifiers);
  return join( "\t",
    (INC_SPECIES?"$species\t":"").qq($X Gene),
    qq($gid),
    qq(/$species/geneview?gene=$gid$extra),
    qq($IDX),
    qq($X gene $gid has $T transcript).($T==1?'':'s').qq(: ).join(', ',keys(%$transcripts)).
    qq(<br />$description).( $EX>0 ?
      (
        qq(<br />The gene has the following external identifiers mapped to it:<br />).
        ( join '<br />',
          map { "$_: ".(join ", ", keys %{$external_identifiers->{$_}}) }
          sort { lc($a) cmp lc($b) } keys %$external_identifiers
        )
      ) : ''
    ).qq(\n)
  );
}

########################################################################## Peptides

sub dumpPeptide {
    my $conf = shift;
    my $COREDB = $conf->{'dbs'}->{'ENSEMBL_DB'};
    my $SANGDB = $conf->{'dbs'}->{'ENSEMBL_SANGER'};
    my %sths = (
        'EnsEMBL' => $conf->{'dbh'}->prepare(qq(
select trsi.stable_id as pid, tsi.stable_id as tid, gsi.stable_id as gid
  from $COREDB.translation_stable_id as trsi, $COREDB.gene_stable_id as gsi,
       $COREDB.transcript_stable_id as tsi, $COREDB.transcript as t, $COREDB.translation as tr
 where tr.transcript_id = tsi.transcript_id and
       tr.transcript_id = t.transcript_id and 
       tr.translation_id = trsi.translation_id and
       t.gene_id = gsi.gene_id
        ))
    );
    
    $sths{'Sanger'} 
        = $conf->{'dbh'}->prepare(qq(
select trsi.stable_id as pid, tsi.stable_id as tid, gsi.stable_id as gid
  from $SANGDB.translation_stable_id as trsi, $SANGDB.gene_stable_id as gsi,
       $SANGDB.transcript_stable_id as tsi,   $SANGDB.transcript as t, $SANGDB.translation as tr
 where tr.transcript_id = tsi.transcript_id and
       tr.transcript_id = t.transcript_id and
       tr.translation_id = trsi.translation_id and
       t.gene_id = gsi.gene_id
    )) if( $SANGDB );

    open O, ">$conf->{'directory'}/Peptide.txt";
    foreach my $X ( keys %sths ) {
        my $sth = $sths{$X};
        my $extras = $X eq 'Sanger' ? '&db=sanger' : '';
        $sth->execute();
        my $old_id      = '';   my $IDS         = '';
        my $description = '';
        my $counter     = 0;
        my ( $pid, $tid, $gid );
        while( ( $pid, $tid, $gid ) = $sth->fetchrow_array()){
        ## Type `-> ID `-> IDs to search `-> Description
            print O &peptideLine( $conf->{'species'}, $X, $pid, $tid, $gid, $extras)
        }
    }
    close O;
}

sub peptideLine {
    my($species,$TYPE,$pid,$tid,$gid, $extras) = @_;
    return join "\t",
        (INC_SPECIES?"$species\t":"").qq($TYPE Peptide),    ## Type
        qq($pid),               ## ID
        qq(/$species/protview?peptide=$pid$extras), ## URL
        qq($pid $tid $gid),     ## Index locations
        qq($TYPE peptide $pid is a product of $TYPE gene $gid [transcript $tid]\n);   ## Description text

}

########################################################################## Sequences

sub dumpSequence {
    my $conf = shift;
    my %config = (
      "Homo_sapiens" => [
        [ 'Clone',      'tilepath,cloneset_1mb,clonset_37k,cloneset_32k', 'name,wellname,clone_name,synonym,embl_acc,bac_acc' ],
        [ 'NT Contig',  'ntctgs',                  'name' ],
        [ 'Encode region', 'encode', 'name,synonym,description' ],
      ],
      "Mus_musculus" => [
        [ 'BAC',        'cloneset,bac_map', 'synonym,bac_acc,embl_acc,name' ],
        [ 'Supercontig','superctgs', 'name' ],
        [ 'NT Contig',  'ntctgs',    'name' ],
      ],
      "Anopheles_gambiae" => [
        [ 'BAC' ,       'bacs',        'name,synonym' ],
        [ 'BAC band' ,  'bacs_bands',  'name,synonym' ],
        [ 'Haplotype' , 'haplotype',   'name' ],
      ]
    );

  my $COREDB   = $conf->{'dbs'}->{'ENSEMBL_DB'};
  open O, ">$conf->{'directory'}/Sequence.txt";
  my @types = @{$config{$conf->{'species'}}||[]};
  foreach my $arrayref ( @types ) {
    my( $TYPE, $mapsets, $annotationtypes ) = @$arrayref;
    my @temp         = split (',',$mapsets);        
    my @mapsets;
    foreach my $X ( @temp ) {
       my $ID = $conf->{'dbh'}->selectrow_array( "select misc_set_id from misc_set where code = ?", {}, $X );
      push @mapsets, $ID if($ID);
    }
    next unless @mapsets;
    @temp = split (',',$annotationtypes);        
    my @mapannotationtypes;
    foreach my $X ( @temp ) {
      my $ID = $conf->{'dbh'}->selectrow_array( "select attrib_type_id from attrib_type where code = ?", {}, $X );
      push @mapannotationtypes, $ID if($ID);
    }
    next unless @mapannotationtypes;
    my $Z = " ma.value";
    my $MAPSETS = join ',',@mapsets;
    my $sth = $conf->{'dbh'}->prepare(
      "select mf.misc_feature_id, sr.name,
              ma.value, mf.seq_region_end-mf.seq_region_start+1 as len, 
              at.code
         from misc_feature_misc_set as ms, 
              misc_feature as mf,
              seq_region   as sr,
              misc_attrib  as ma,
              attrib_type  as at 
        where mf.seq_region_id = sr.seq_region_id and mf.misc_feature_id = ms.misc_feature_id and ms.misc_set_id in ($MAPSETS) and
              mf.misc_feature_id = ma.misc_feature_id and ma.attrib_type_id = at.attrib_type_id
        order by mf.misc_feature_id, at.code"
    );
    $sth->execute();
    my ($oldtype,$old_ID,$oldchr,$emblaccs,$oldlen,$synonyms, $NAME );
    while( my($ID,$chr,$val,$len,$type) = $sth->fetchrow_array() ) {
      if($ID == $old_ID) {
        $NAME = $val if $type eq 'name' || $type eq 'non_ref';
        $NAME = $val if !$NAME && $type eq 'synonym';
        $emblaccs.=", $val" if $val;
      } else {
        print O &seqLine( $conf->{'species'}, $TYPE, $NAME, $oldchr, $emblaccs,$oldlen) if $old_ID;
        $NAME = undef;
        $NAME = $val if $type eq 'name' || $type eq 'non_ref';
        $NAME = $val if !$NAME && $type eq 'synonym';
        ($old_ID,$oldchr,$emblaccs,$oldlen) = ($ID,$chr,$val,$len);
      }
    }
    print O &seqLine( $conf->{'species'}, $TYPE, $NAME, $oldchr, $emblaccs ,$oldlen) if $old_ID;
  }

  my $sth = $conf->{'dbh'}->prepare(
    "select c.name, c.length, cs.name
       from seq_region as c, coord_system as cs
      where c.coord_system_id = cs.coord_system_id" );
  $sth->execute();
  while( my($name,$length,$type) = $sth->fetchrow_array() ) {
    print O join "\t",
      (INC_SPECIES?"$conf->{'species'}\t":"").ucfirst($type),       $name,
      $type eq 'chromosome' ?
        "/$conf->{'species'}/mapview?chr=$name" :
        ($length > 0.5e6 ? "/$conf->{'species'}/cytoview?region=$name" :
              "/$conf->{'species'}/contigview?region=$name" ),
      $name, "$name is a @{[ucfirst($type)]} (of length $length)\n";
  }
  close O;
}

sub seqLine {
    my($species,$type,$name,$chr,$val,$len) = @_;
    my $Q = $val; $Q=~s/,//g;
    my $SCRIPT = $len > 0.5e6 ? 'cytoview' : 'contigview';
    return join "\t",
	(INC_SPECIES?"$species\t":"").$type,
        $name, "/$species/$SCRIPT?mapfrag=$name",
        "$name $Q",
	"$type $name is mapped to Chromosome $chr, and has". (($val &&  ($val ne "")) ? " EMBL accession(s)/synonyms $val and " : "").
		" length $len bps\n";
}

########################################################################## Sanger Projects

sub dumpSangerProject {
    my $conf = shift;
    my $dbh = DBI->connect("DBI:mysql:host=humsrv1;port=3399;database=submissions",
        'read_only', undef, {RaiseError => 1})
        or die "Can't connect to submissions database as 'read_only' ",
        DBI::errstr();

    my %SPECIES = qw(
      Homo_sapiens Human
      Mus_musculus Mouse
      Danio_rerio Zebradish
      Drosophila_melanogaster Drosophila
      Rattus_norvegicus Rat);
   
    my $sth = $dbh->prepare(
       "SELECT distinct a.project_name, a.accession 
          FROM project_acc a, project_dump d,
               sequence s, species_chromosome c
         WHERE a.sanger_id = d.sanger_id AND d.seq_id = s.seq_id
           AND s.chromosome_id = c.chromosome_id 
           AND c.species_name = '@{[$SPECIES{$conf->{'species'}}]}' AND a.accession != 'UNKNOWN'"
    );
    $sth->execute(  );
    my $species = $conf->{'species'},

    my $i = 0;
    open O,">$conf->{'directory'}/SangerProject.txt";
    while (my ($proj, $acc) = $sth->fetchrow()) {
        print O join "\t",
            (INC_SPECIES?"$species\t":"")."Sanger Project",
            $proj,
            "/$conf->{'species'}/contigview?clone=$acc",
            "$acc $proj",
            qq(Sanger sequencing project $proj corresponds to Ensembl clone accession $acc.\n);
    }
    close O;
}

