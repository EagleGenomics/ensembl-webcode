#!/usr/local/bin/perl

use strict;

my $ENSEMBL_ROOT;

BEGIN {
  use FindBin qw($Bin);
  use File::Basename qw( dirname );
  $ENSEMBL_ROOT = dirname( $Bin );
  $ENSEMBL_ROOT =~ s/\/utils$//;
  unshift @INC, "$ENSEMBL_ROOT/conf";
  eval{ require SiteDefs };
  if ($@){ die "Can't use SiteDefs.pm - $@\n"; }
  map{ unshift @INC, $_ } @SiteDefs::ENSEMBL_LIB_DIRS;
}

use EnsEMBL::Web::SpeciesDefs;
use Data::Dumper;
package indexDumper;

use constant INC_SPECIES => 0;
use CGI;

our $SD = EnsEMBL::Web::SpeciesDefs->new();

my ( $SPECIES_STRING, @indexes) = @ARGV;

## HACK 1 - if the INDEX is set to all grab all dumper methods...
@indexes = map { /dump(\w+)/?$1:() } keys %indexDumper:: if $indexes[0] eq 'ALL';

## HACK 2 - if the SPECIES is set to ALL grab stuff from config...

my @species;
my %X = %{$SD->ENSEMBL_SPECIES_ALIASES};

if( $SPECIES_STRING eq 'ALL' ) {
  @species = @{$SD->ENSEMBL_SPECIES}
} else {
  @species = grep {$_} map { $X{lc($_)} } split /:/, $SPECIES_STRING;
}

# EnsEMBL::Web::IndexSupport takes path to conf, path to files, species
my $conf = {};
mkdir 'input', 0777 unless -e 'input';

foreach my $species ( @species ) {
  $conf->{'directory'} = "input/$species";
  mkdir $conf->{'directory'}, 0777 unless -e  $conf->{'directory'};
  $conf->{'species'}   = $species;
  my %dbs = %{$SD->get_config($species,'databases')||{}};
  $conf->{'dbs'}       = { map { ($_,$dbs{$_}{NAME}) } keys %dbs };
  $conf->{'dbs'}{'ENSEMBL_COMPARA'} = 'ensembl_compara_42';
  my $core = $dbs{'ENSEMBL_DB'};
  $conf->{'dbh'}       = DBI->connect( "dbi:mysql:$core->{'NAME'};host=$core->{'HOST'};port=$core->{'PORT'}",
        $core->{'USER'}, $core->{'PASS'} );
  warn join ' ', $species, Data::Dumper::Dumper $conf;
  foreach my $index (@indexes) {
    warn "  Index: $species $index";
    my $function = "dump$index";
    no strict "refs";
    &$function( $conf );
  }
}

## Now for all the dump functions...............................

########################################################################## QTLs

sub dumpQTL {
  my $conf = shift;
  my $sth = $conf->{'dbh'}->prepare(qq(
 select c.name as chr, qf.seq_region_start, qf.seq_region_end,
        a.logic_name as analysis, q.qtl_id,
        q.trait, qs.source_database, qs.source_primary_id,
        fms1.source as fm1_source, fms1.name as fm1_name,
        fms2.source as fm2_source, fms2.name as fm2_name,
        pms.source  as pm_source,  pms.name  as pm_name
   from seq_region as c, qtl_feature as qf, qtl_synonym as qs ,
        analysis as a, qtl as q left join marker as fm1 on
        fm1.marker_id = q.flank_marker_id_1 left join marker_synonym as fms1 on
        fm1.display_marker_synonym_id = fms1.marker_synonym_id left join marker as fm2 on
        fm2.marker_id = q.flank_marker_id_2 left join marker_synonym as fms2 on
        fm2.display_marker_synonym_id = fms2.marker_synonym_id left join marker as pm on
        pm.marker_id = q.peak_marker_id left join marker_synonym as pms on
        pm.display_marker_synonym_id = pms.marker_synonym_id 
  where c.seq_region_id = qf.seq_region_id and qs.qtl_id = q.qtl_id and 
        qf.analysis_id = a.analysis_id and qf.qtl_id = q.qtl_id
  ));
  $sth->execute();
  open O, ">$conf->{'directory'}/QTL.txt";
  my $desc       = '';
  my $old_qtl = 0;
  my $old_ID  = '';
  my $old_pos = '';
  my $IDS;
  while( my $T = $sth->fetchrow_hashref() ){
    if($T->{qtl_id} eq $old_qtl) {
      $IDS  .= " $T->{source_primary_id}";
      $desc .= " $T->{source_database}:$T->{source_primary_id}";
    } else {
      print O &QTLLine( $conf->{'species'}, $old_ID, $old_pos, $IDS,$desc );
      $IDS = "$T->{trait} $T->{source_primary_id}";
      $IDS.= " $T->{fm1_name}" if $T->{fm1_name};
      $IDS.= " $T->{fm2_name}" if $T->{fm2_name};
      $IDS.= " $T->{pm_name}" if $T->{pm_name};
      $old_ID = $T->{pm_name};
      $old_pos = "$T->{chr}:".($T->{seq_region_start}-1e4).'-'.($T->{seq_region_end}+1e4);
      $desc       = "QTL exhibiting '$T->{trait}' has ";
      my $f2 = $T->{pm_name} ? 1 : 0;
      if( $T->{fm1_name} || $T->{fm2_name} ) {
        my $f1= ($T->{fm1_name}) && ($T->{fm2_name}) ? 1 : 0;
        $desc.='flanking marker'.($f1?'s ':' ').$T->{fm1_name}.($f1?' and ':'').$T->{fm2_name}.($f2?'; ':'');
      }
      if($f2) {
        $desc.= "peak marker $T->{pm_name};";
      }
      $desc.=" and names: $T->{source_database}:$T->{source_primary_id}";
      $old_qtl = $T->{qtl_id};
    }
  }
  print O &QTLLine( $conf->{'species'}, $old_ID,$old_pos, $IDS,$desc );
  close O;
}

sub QTLLine {
  my ($species, $trait, $pos, $IDS, $desc ) = @_;
  return if $trait eq '';
  return join "\t", (INC_SPECIES?"$conf->{'species'}\t":"").qq(QTL),
    $trait, "/$conf->{'species'}/contigview?l=$pos", $IDS, "$desc\n";
}

########################################################################## SNPs


sub dumpSNP {
  my $conf = shift;
  next if $conf->{'species'} eq 'Homo_sapiens'; ## SKIP HUMAN SNPS....
  next if $conf->{'species'} eq 'Mus_musculus'; ## SKIP HUMAN SNPS....
  my $SNPDB = $conf->{'dbs'}->{'ENSEMBL_VARIATION'};
  return unless $SNPDB;
  my %SOURCES = map { @$_ } @{$conf->{'dbh'}->selectall_arrayref( "select source_id, name from $SNPDB.source" )};
  my $sth = $conf->{'dbh'}->prepare(
    "select v.source_id as o1, v.name as o2, vs.source_id as o3, vs.name as o4
       from $SNPDB.variation as v left join $SNPDB.variation_synonym as vs on vs.variation_id = v.variation_id
      order by o1,o2,o3,o4"
  );
  $sth->execute();
  my $old = {}; my $desc; my $IDS;
  open O, ">$conf->{'directory'}/SNP.txt";
  while( my $T= $sth->fetchrow_hashref()) {
    if($T->{o1} eq $old->{o1} && $T->{o2} eq $old->{o2}) {
      $desc.= ", ".$SOURCES{$T->{o3}}.":$T->{o4}";
      $IDS .= " $T->{o4}";
    } else {
      print O &snpLine( $conf->{'species'}, $SOURCES{$old->{o1}}, $old->{o2}, $IDS, $desc);
      $IDS = $T->{o2};
      $desc = '';
      if( $T->{o3} ) {
        $desc .= ", ".$SOURCES{$T->{o3}}.":$T->{o4}";
        $IDS  .= " $T->{o4}";
      }
      $old = {%$T};
    }
  }
  print O &snpLine( $conf->{'species'}, $SOURCES{$old->{o1}}, $old->{o2}, $IDS, $desc);
  close O;
}

sub snpLine {
  my ($species, $source, $snpid, $IDS, $desc ) =@_;
  return if $snpid eq '';
  $desc =~ s/^, //;
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(Ensembl SNP),
    $snpid,
    "/$species/snpview?snp=$snpid;source=$source",
    "$IDS",
    "SNP $snpid. Alternative IDs: $desc.\n";
}



########################################################################## Markers

sub dumpMarker {
  my $conf = shift;
  my $sth = $conf->{'dbh'}->prepare(qq(
   select m.marker_id, ms2.name, ms1.name
     from marker_synonym as ms1, marker as m left join
          marker_synonym as ms2 on ms2.marker_synonym_id = m.display_marker_synonym_id
    where ms1.marker_id = m.marker_id
    order by m.marker_id
  ));

  $sth->execute( );

  open O, ">$conf->{'directory'}/Marker.txt";
  my $counter    = 0;
  my $desc       = '';
  my $old_ID = 0;
  my ($ID,$marker,$synonym);
  while( ($ID,$marker,$synonym) = $sth->fetchrow_array()){
    $marker = $synonym unless $marker;
    if($ID == $old_ID) {
      $desc .= " $synonym";
      $counter++;
    } else {
      print O &markerLine( $conf->{'species'}, $desc, $counter );
      $desc       = "$synonym";
      $old_ID = $ID;
      $counter    = 1;
    }
  }
  print O &markerLine( $conf->{'species'}, $desc, $counter );
  close O;
}

sub markerLine {
  my( $species, $IDS, $counter ) = @_;
  return if $counter == 0;
  my @synonyms = sort split /\s+/, $IDS;
  my $key = pop @synonyms;
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(Ensembl Marker),    ## Type
    qq($key),               ## ID
    qq(/$species/markerview?marker=$key),
    qq($IDS),     ## Index locations,
    qq(A marker with $counter synonyms ($IDS)\n);
}

########################################################################## Similarity features

sub dumpGenomicAlignment {
  my  $conf = shift;
  open D, ">$conf->{'directory'}/GenomicAlignment.txt";

  my $species = $conf->{'species'};
  my $COREDB = $conf->{'dbs'}->{'ENSEMBL_DB'};    
  my $ESTDB  = $conf->{'dbs'}->{'ENSEMBL_OTHERFEATURES'};
  my $CDNADB = $conf->{'dbs'}->{'ENSEMBL_CDNA'};
  my %dbs    = ( 'core' => $COREDB );
  $dbs{'otherfeatures'}  =  $ESTDB  if $ESTDB;
  $dbs{'cdna'} = $CDNADB if $CDNADB;
  my %tables = (
    'dna_align_feature'     => [ 'DnaAlignFeature',     'DNA alignment feature' ],
    'protein_align_feature' => [ 'ProteinAlignFeature', 'Protein alignment feature' ]
  );
  my %errors = ();
  foreach my $db ( keys %dbs) { 
    my $DB_NAME = $dbs{$db};
    foreach my $table ( keys %tables ) {
      my $source = $tables{ $table }[0];
         $source .= ";db=$db" unless $db eq 'core';
      my $type   = $tables{ $table }[1];
      my $sth    = $conf->{'dbh'}->prepare(
        "select a.logic_name, ad.display_label, t.hit_name, count(*) as hits
           from $DB_NAME.analysis as a, $DB_NAME.$table as t left join
                $DB_NAME.analysis_description as ad on ad.analysis_id = a.analysis_id
          where a.analysis_id = t.analysis_id
          group by a.logic_name, t.hit_name"
      ); 
      $sth->execute();
      while( my( $logic_name, $label, $hid, $count ) = $sth->fetchrow_array ) { 
        print D join "\t",
          (INC_SPECIES?"$species\t":"")."$type: ".($label||$logic_name),
          $hid,
          "/$species/featureview?type=$source;id=$hid",
          $hid,
          qq($logic_name $hid hits the genome in $count locations.\n);
      }
    }
  }

  close D;
}

sub dumpOligoProbe {
  my $conf = shift;
  open A, ">$conf->{'directory'}/OligoProbe.txt";
  my $species = $conf->{'species'};
  my $COREDB = $conf->{'dbs'}->{'ENSEMBL_DB'};
  my $sth    = $conf->{'dbh'}->prepare(
    "select p.probeset, count(*) as hits, a.type
       from oligo_probe as p, oligo_feature as f, oligo_array as a
      where p.oligo_probe_id = f.oligo_probe_id and p.oligo_array_id = a.oligo_array_id
      group by p.probeset"
  );
  $sth->execute();
  while( my( $hid, $count, $type ) = $sth->fetchrow_array ) {
    print A join "\t", (INC_SPECIES?"$species\t":"")."$type Oligo Probe set",
      $hid, "/$species/featureview?type=OligoProbe;id=$hid",
      $hid, qq($type oligo probeset $hid hits the genome in $count locations.\n);
  }
  close A;
}


########################################################################## Diseases

sub dumpDisease {
  my $conf = shift;
  my $DISDB   = $conf->{'dbs'}->{'ENSEMBL_DISEASE'};    
  return unless $DISDB;
  my $COREDB   = $conf->{'dbs'}->{'ENSEMBL_DB'};    
  my $sth = $conf->{'dbh'}->prepare(
    "select distinct concat( g.gene_symbol,':',g.omim_id, ' (',gsi.stable_id,')') as name,
            d.disease, d.disease
       from $DISDB.disease as d,
            $DISDB.gene as g,
            $COREDB.xref as cx, 
            $COREDB.object_xref as cox, 
            $COREDB.translation as tr,
            $COREDB.transcript as t,
            $COREDB.gene_stable_id as gsi 
      where d.id = g.id and cx.display_label = g.omim_id and cx.external_db_id = 1500 and
            cox.xref_id = cx.xref_id and cox.ensembl_id = tr.translation_id and
            tr.transcript_id = t.transcript_id and gsi.gene_id = t.gene_id
      order by disease, g.omim_id, g.gene_symbol"
  );
  $sth->execute();
  open O, ">$conf->{'directory'}/Disease.txt";
  my $old_omim = '';
  my $IDS  = '';
  my $description = '';
  my $old_desc = '';
  my ($gene, $omim, $desc );
  while( ($gene, $omim, $desc ) = $sth->fetchrow_array()){
    if($omim eq $old_omim) {
      $IDS .= " $gene";
      $description .=", $gene";
    } else {
      print O &diseaseLine($conf->{'species'}, $old_omim, $IDS, $description );
      $description = "$desc Genes: $gene";
      $IDS  = "$gene $desc";
      $old_omim = $omim;
    }
  }
  print O &diseaseLine($conf->{'species'}, $old_omim, $IDS, $description );
  close O;
}

use CGI qw(escape escapeHTML);
sub diseaseLine {
  my($species, $did, $IDS, $description) = @_;
  return if $description eq '';
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(OMIM disease),    ## Type
    escapeHTML($did),               ## ID
    qq(/$species/featureview?type=Disease;id=).escape($did),
    qq($did $IDS),     ## Index locations,
    qq(OMIM - $description\n);
}

########################################################################## Domains

sub dumpDomain {
  my $conf = shift;
  my $COREDB = $conf->{'dbs'}->{'ENSEMBL_DB'};
  my $sth = $conf->{'dbh'}->prepare(
    "select x.dbprimary_acc, i.id, x.description
       from $COREDB.xref as x, $COREDB.interpro as i
      where x.dbprimary_acc = i.interpro_ac
      order by x.dbprimary_acc"
  );
  $sth->execute();
  open O, ">$conf->{'directory'}/Domain.txt";
  my $old_acc     = '';
  my $IDS         = '';
  my $description = '';
  my $counter     = 0;
  my ($acc, $id, $desc, $old_desc  );
  while( ($acc, $id, $desc ) = $sth->fetchrow_array()){
    if($acc eq $old_acc) {
      $IDS         .= " $id";
      $description .= ", $id";
      $counter++;
    } else {
      print O &domainLine($conf->{'species'}, $old_acc, $IDS, $old_desc, $counter, $description );
      $description = $id;
      $IDS         = $id;
      $old_acc     = $acc;
      $old_desc    = $desc;
      $counter     = 1;
    }
  }
  print O &domainLine( $conf->{'species'}, $old_acc, $IDS, $old_desc, $counter, $description );
  close O;
}

sub domainLine {
  my($species, $did, $IDS, $desc, $counter, $description) = @_;
  return if $did eq '';
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(Interpro domain),    ## Type
    qq($did),               ## ID
    qq(/$species/domainview?domainentry=$did), ## URL
    qq($did $IDS $desc),     ## Index locations
    qq(InterPro domain $did [$desc] has $counter associated external database identifiers: $description.\n);   ## Description text

}

########################################################################## Families

sub dumpFamily {
    my $conf = shift;
    my $FAMDB = $conf->{'dbs'}->{'ENSEMBL_COMPARA'};
    my $CORE  = $conf->{'dbs'}->{'ENSEMBL_DB'};
    my $t_sth = $conf->{'dbh'}->prepare(
	"select meta_value from $CORE.meta where meta_key='species.taxonomy_id'"
    );
    $t_sth->execute;
    my $taxon_id = ($t_sth->fetchrow);
    return unless $taxon_id;

    my $sth = $conf->{'dbh'}->prepare(
        "select f.stable_id, f.description, m.stable_id
           from $FAMDB.family as f, $FAMDB.family_member as fm, 
                $FAMDB.member as m
          where fm.family_id = f.family_id and fm.member_id = m.member_id and
                m.taxon_id = $taxon_id
          order by f.stable_id, m.stable_id"
    );

    $sth->execute();
    open O, ">$conf->{'directory'}/Family.txt";
    my $old_id      = '';
    my $IDS         = '';
    my $description = '';
    my $counter     = 0;
    my ( $id, $dbid, $desc, $old_desc );
    while( ($id, $desc, $dbid ) = $sth->fetchrow_array()){
        if($id eq $old_id) {
            $IDS         .= " $dbid";
            $description .= ", $dbid" if ($counter <8 );
            $description .= ", ..."   if ($counter == 8 );
            $counter++;
        } else {
            print O &familyLine($conf->{'species'}, $old_id, $IDS, $old_desc, $counter, $description );
            $description = $dbid;
            $IDS         = $dbid;
            $old_id      = $id;
            $old_desc    = $desc;
            $counter     = 1;
        }
    }
    print O &familyLine($conf->{'species'}, $old_id, $IDS, $old_desc, $counter, $description );
    close O;
}

sub familyLine {
    my($species, $fid, $IDS, $desc, $counter, $description) = @_;
    return if $fid eq '';
    return join "\t",
        (INC_SPECIES?"$species\t":"").qq(Ensembl protein family),    ## Type
        qq($fid),               ## ID
        qq(/$species/familyview?family=$fid), ## URL
        qq($fid $IDS $desc),     ## Index locations
        qq(Ensembl protein family $fid [$desc] has $counter members: $description.\n);   ## Description text
}
 
########################################################################## Genes

sub dumpGene {
    my $conf = shift;
    my $COREDB = $conf->{'dbs'}->{'ENSEMBL_DB'};
    my $SANGDB = $conf->{'dbs'}->{'ENSEMBL_VEGA'};
    my $ESTGENEDB = $conf->{'dbs'}->{'ENSEMBL_OTHERFEATURES'};
    my %DBS = ( 'core' => $COREDB );
    $DBS{'vega'}          = $SANGDB    if $SANGDB;
    $DBS{'otherfeatures'} = $ESTGENEDB if $ESTGENEDB;

    open O, ">$conf->{'directory'}/Gene.txt";
warn "START...";
    foreach my $DB ( keys %DBS ) {
      my $DBNAME = $DBS{$DB};
      my $extra = $DB ne 'core' ? ";db=$DB" : '';
      my %xrefs = ();
      my %disp_xrefs = ();
      foreach my $type( qw(Gene Transcript Translation) ) {
        my $T = $conf->{'dbh'}->selectall_arrayref(
     "select ox.ensembl_id,
             x.display_label, x.dbprimary_acc, ed.db_display_name, es.synonym
        from $DBNAME.object_xref as ox, $DBNAME.xref as x, $DBNAME.external_db as ed left join $DBNAME.external_synonym as es on es.xref_id = x.xref_id
       where ox.ensembl_object_type = '$type' and ox.xref_id = x.xref_id and x.external_db_id = ed.external_db_id"
        );
        foreach ( @$T ) {
          $xrefs{$type}{$_->[0]}{$_->[3]}{$_->[1]}=1 if $_->[1];
          $xrefs{$type}{$_->[0]}{$_->[3]}{$_->[2]}=1 if $_->[2];
          $xrefs{$type}{$_->[0]}{$_->[3]}{$_->[4]}=1 if $_->[4];
        }
        warn "XREF $type query...";
      }
      my %exons = ();
      my $T = $conf->{'dbh'}->selectall_arrayref(
	"select distinct t.gene_id, esi.stable_id
           from transcript as t, exon_transcript as et, exon_stable_id as esi
          where t.transcript_id = et.transcript_id and et.exon_id = esi.exon_id"
      );
      foreach( @$T ) {
        $exons{$_->[0]}{$_->[1]}=1;
      }
      my $gene_info = $conf->{'dbh'}->selectall_arrayref(qq(
select gsi.gene_id, tsi.transcript_id, trsi.translation_id,
       gsi.stable_id as gsid, tsi.stable_id as tsid, trsi.stable_id as trsid,
       g.description, ed.db_display_name, x.dbprimary_acc,x.display_label, ad.display_label, ad.description, g.source, g.status, g.biotype
  from $DBNAME.gene_stable_id as gsi, $DBNAME.gene as g,
       $DBNAME.transcript_stable_id as tsi,
       $DBNAME.analysis_description as ad,
       $DBNAME.transcript as t left join
       $DBNAME.translation as tr on t.transcript_id = tr.transcript_id left join
       $DBNAME.translation_stable_id as trsi on tr.translation_id = trsi.translation_id left join
       $DBNAME.xref as x on g.display_xref_id = x.xref_id left join
       $DBNAME.external_db as ed on ed.external_db_id = x.external_db_id
 where t.gene_id = gsi.gene_id and t.transcript_id = tsi.transcript_id and t.gene_id = g.gene_id and g.analysis_id = ad.analysis_id
 order by gsi.stable_id, tsi.stable_id
      ));
warn "Gene query...";
      my %old;
      foreach my $row (@$gene_info) {
        my($g,$t,$tr,$gs,$ts,$trs,$d,$ddb,$dpa,$dn,$a,$ad,$s,$st,$bt) = @$row;
        if( $old{'g'} != $g ) {
          if( $old{'g'} ) {
            print O &geneLine( $conf->{'species'}, $old{'ex'}, $old{'s'}.' '.$old{'bt'}, $old{'gs'}, $old{'alt'}, $extra, join( ' ', grep{$_}keys %{$old{'i'}}), $old{'t'},$old{'tr'},$old{'e'},$old{'d'} );
          }
          %old = (
            'g' => $g,
            'gs' => $gs,
            'd'  => $d,
            'tr' => {$trs?($trs=>1):()},
            't'  => {$ts ?($ts=>1) :()},
            'ex' => {},
            'e'  => {},
            'i'  => {$gs=>1,$d=>1,$dpa=>1,$dn=>1,$ts=>1,$trs=>1}, 
            'alt' => $dn ? "($ddb: $dn)" : "(novel gene)",
            'a'   => $a,
            'ad'  => $ad,
            's'   => ucfirst($s),
            'st'  => $st,
            'bt'  => $bt
          );
          $old{'s'}=~s/base/Base/;
          $old{'ex'} = $exons{$g};
          foreach my $K (keys %{$exons{$g}}) { $old{'i'}{$K} = 1; }
          foreach my $db( keys %{$xrefs{'Gene'}{$g}||{}} ) {
            foreach my $K( keys %{$xrefs{'Gene'}{$g}{$db}} ) { $old{'e'}{$db}{$K}=1; $old{'i'}{$K}=1; }
          }
          foreach my $db( keys %{$xrefs{'Transcript'}{$t}||{}} ) {
            foreach my $K( keys %{$xrefs{'Transcript'}{$t}{$db}} ) { $old{'e'}{$db}{$K}=1; $old{'i'}{$K}=1; }
          }
          foreach my $db( keys %{$xrefs{'Translation'}{$tr}||{}} ) {
            foreach my $K( keys %{$xrefs{'Translation'}{$tr}{$db}} ) { $old{'e'}{$db}{$K}=1;  $old{'i'}{$K}=1; }
          }
        } else {
          $old{'t'}{$ts}=1;
          $old{'tr'}{$trs}=1;
          foreach my $db( keys %{$xrefs{'Transcript'}{$t}||{}} ) {
            foreach my $K( keys %{$xrefs{'Transcript'}{$t}{$db}} ) { $old{'e'}{$db}{$K}=1; $old{'i'}{$K}=1; }
          }
          foreach my $db( keys %{$xrefs{'Translation'}{$tr}||{}} ) {
            foreach my $K( keys %{$xrefs{'Translation'}{$tr}{$db}} ) { $old{'e'}{$db}{$K}=1; $old{'i'}{$K}=1; }
          }
        }
      }
      print O &geneLine( $conf->{'species'}, $old{'ex'}, $old{'s'}.' '.$old{'bt'}, $old{'gs'}, $old{'alt'}, $extra, join( ' ', grep{$_}keys %{$old{'i'}}), $old{'t'},$old{'tr'},$old{'e'},$old{'d'} );
      warn "FINISHED...... genes...";
    }
my %current_stable_ids =();
foreach my $type (qw(gene transcript translation)) {
  $current_stable_ids{$type}  = {map {@$_} @{$conf->{'dbh'}->selectall_arrayref( "select stable_id,1 from $COREDB.".$type."_stable_id" )}};
}

   my $species = $conf->{'species'};

    my $sth = $conf->{'dbh'}->prepare( qq(
select sie.type, sie.old_stable_id, if(isnull(sie.new_stable_id),'NULL',sie.new_stable_id), ms.old_release*1.0 as X, ms.new_release*1.0 as Y
  from $COREDB.mapping_session as ms, $COREDB.stable_id_event as sie
 where ms.mapping_session_id = sie.mapping_session_id and ( old_stable_id != new_stable_id or isnull(new_stable_id) )
 order by Y desc, X desc));
   
    $sth->execute();
    my %mapping = ();
    while( my($type,$osi,$nsi) = $sth->fetchrow_array() ) {
      next if $current_stable_ids{$type}{$osi}; ## Don't need to cope with current IDS already searchable...
      $mapping{$type}{$osi}{$nsi}=1;
      if($mapping{$type}{$nsi}) {
        foreach( keys %{$mapping{$type}{$nsi}} ) {
          $mapping{$type}{$osi}{$_}=1;
        }
      }
    }
    foreach my $type ( keys %mapping ) {
      foreach my $osi ( keys %{$mapping{$type}} ) {
        my @current_sis = ();
        my @deprecated_sis = ();
        foreach ( keys %{$mapping{$type}{$osi}} ) {
          if( $current_stable_ids{$_} ) {
            push @current_sis,$_;
          } elsif( $_ ne 'NULL' ) {
            push @deprecated_sis,$_;
          }
        }
        if( @current_sis ) {
          print O join( "\t",
      (INC_SPECIES?"$species\t":"").qq(EnsEMBL $type),
      qq($osi),
      qq(/$species/idhistoryview?).lc($type).qq(=$osi),
      join( ' ', $osi, @current_sis, @deprecated_sis ),
      qq($type $osi is no longer in the Ensembl database but it has been mapped to the following current identifiers: @current_sis).
      ( @deprecated_sis ? "; and the following deprecated identifiers: @deprecated_sis" : '').
      ".\n"
          );
        } elsif( @deprecated_sis ) {
          print O join( "\t",
      (INC_SPECIES?"$species\t":"").qq(EnsEMBL $type),
      qq($osi),
      qq(/$species/idhistoryview?).lc($type).qq(=$osi),
      join( ' ', $osi, @deprecated_sis ),
      qq($type $osi is no longer in the Ensembl database but it has been mapped to the following deprecated identifiers: @deprecated_sis\n)
          );
        } else {
          print O join( "\t",
      (INC_SPECIES?"$species\t":"").qq(EnsEMBL $type),
      qq($osi),
      qq(/$species/idhistoryview?).lc($type).qq(=$osi),
      qq($osi),
      qq($type $osi is no longer in the Ensembl database and it has not been mapped to any newer identifiers\n)
          );
        }
      }
    }
  my %unmapped_queries = ( 'None' => qq(
select a.logic_name, e.db_display_name,
       uo.identifier, ur.summary_description,
       'Not mapped'
  from $COREDB.analysis as a, $COREDB.external_db as e, $COREDB.unmapped_object as uo,
       $COREDB.unmapped_reason as ur
 where a.analysis_id = uo.analysis_id and 
       uo.external_db_id = e.external_db_id and
       uo.unmapped_reason_id = ur.unmapped_reason_id and
       uo.ensembl_id = 0
), 'Transcript' => qq(
select a.logic_name, e.db_display_name,
       uo.identifier, ur.summary_description,
       concat( 'Transcript: ',
                tsi.stable_id, '; Gene: ',gsi.stable_id )
  from $COREDB.analysis as a, $COREDB.external_db as e, $COREDB.unmapped_object as uo,
       $COREDB.unmapped_reason as ur, $COREDB.transcript_stable_id as tsi,
       $COREDB.transcript as t, $COREDB.gene_stable_id as gsi
 where a.analysis_id = uo.analysis_id and 
       uo.external_db_id = e.external_db_id and
       uo.unmapped_reason_id = ur.unmapped_reason_id and
       uo.ensembl_id = t.transcript_id and
       uo.ensembl_object_type = 'Transcript' and
       t.transcript_id = tsi.transcript_id and
       t.gene_id       = gsi.gene_id
), 'Translation' => qq(
select a.logic_name, e.db_display_name, uo.identifier, ur.summary_description,
       concat( 'Translation: ',trsi.stable_id,'; Transcript: ',
                tsi.stable_id, '; Gene: ',gsi.stable_id )
  from $COREDB.analysis as a, $COREDB.external_db as e, $COREDB.unmapped_object as uo,
       $COREDB.unmapped_reason as ur, $COREDB.transcript_stable_id as tsi,
       $COREDB.translation as tr, $COREDB.translation_stable_id as trsi,
       $COREDB.transcript as t, $COREDB.gene_stable_id as gsi
 where a.analysis_id = uo.analysis_id and 
       uo.external_db_id = e.external_db_id and
       uo.unmapped_reason_id = ur.unmapped_reason_id and
       uo.ensembl_id = tr.translation_id and 
       tr.transcript_id = t.transcript_id and
       trsi.translation_id = tr.translation_id and
       uo.ensembl_object_type = 'Translation' and
       t.transcript_id = tsi.transcript_id and
       t.gene_id       = gsi.gene_id
  ));
  foreach my $FLAG (keys %unmapped_queries) {
    my $SQL = $unmapped_queries{$FLAG};
    my $sth = $conf->{'dbh'}->prepare($SQL);
    $sth->execute;
    while( my $T = $sth->fetchrow_arrayref() ) {
      print O join "\t", (INC_SPECIES?"$conf->{'species'}\t":"").qq(Unmapped feature),
    "$T->[1] $T->[2]",
    "/$conf->{'species'}/featureview?type=Gene;id=$T->[2]", "$T->[2] $T->[4]", "$T->[3]; $T->[4]\n";
    }
  }
    close O;
}

sub geneLineOld {
  my( $species, $type, $gid, @GIDS ) = @_;
  return unless $gid;
  if( @GIDS ) {
    return join( "\t",
      (INC_SPECIES?"$species\t":"").qq(EnsEMBL $type),
      qq($gid),
      qq(/$species/geneview?).lc($type).qq(=$gid),
      join( ' ', $gid, @GIDS ),
      qq($type $gid is no longer in the Ensembl database but it has been mapped to the following identifiers: @GIDS\n)
    );
  } else {
    return join( "\t",
      (INC_SPECIES?"$species\t":"").qq(EnsEMBL $type),
      qq($gid),
      qq(/$species/geneview?).lc($type).qq(=$gid),
      qq($gid),
      qq($type $gid is no longer in the Ensembl database and it has not been mapped to any new identifiers\n)
    );
  }
}

sub geneLine {
  my ($species, $exons, $X, $gid, $altid, $extra, $IDX, $transcripts, $peptides, $external_identifiers, $description )=@_;
  return if $gid eq '';
  my $T = scalar (keys %$transcripts);
  my $P = scalar (keys %$peptides);
  my $E = scalar (keys %$exons);
  my $EX = scalar (keys %$external_identifiers);
  return join( "\t",
    (INC_SPECIES?"$species\t":"").qq($X Gene),
    qq($gid $altid),
    qq(/$species/geneview?gene=$gid$extra),
    qq($IDX),
    qq($X gene $gid has $T transcript).($T==1?'':'s').qq(: ).join(', ',sort keys(%$transcripts)).
    ( $P > 0 ? 
      qq(, associated peptide).($P==1?'':'s').qq(: ).join(', ',sort keys(%$peptides)) : '').
    qq( and $E exon).($E==1?'':'s').qq(: ).join(', ',sort keys(%$exons)). 
    qq(<br />$description).( $EX>0 ?
      (
        qq(<br />The gene has the following external identifiers mapped to it:<br />).
        ( join '<br />',
          map { "$_: ".(join ", ", keys %{$external_identifiers->{$_}}) }
          sort { lc($a) cmp lc($b) } keys %$external_identifiers
        )
      ) : ''
    ).qq(\n)
  );
}

########################################################################## Sequences

sub dumpSequence {
    my $conf = shift;

    my $sanger = sanger_project_names( $conf );
    my %config = (
      "Homo_sapiens" => [
        [ 'Clone',      'tilepath,cloneset_1mb,cloneset_30k,cloneset_32k', 'name,well_name,clone_name,synonym,embl_acc,sanger_project,alt_well_name,bacend_well_name' ],
        [ 'NT Contig',  'ntctgs',                  'name' ],
        [ 'Encode region', 'encode', 'name,synonym,description' ],
      ],
      "Mus_musculus" => [
        [ 'BAC',        'cloneset_0_5mb,cloneset_1mb,bac_map,tilingpath_cloneset', 'embl_acc,name,clone_name,well_name,synonym,alt_embl_acc' ],
        [ 'Fosmid',     'fosmid_map', 'name,clone_name' ],
        [ 'Supercontig','superctgs', 'name' ],
      ],
      "Anopheles_gambiae" => [
        [ 'BAC' ,       'bacs',        'name,synonym,clone_name' ],
        [ 'BAC band' ,  'bacs_bands',  'name,synonym,clone_name' ],
      ],
      "Gallus_gallus" => [
        [ 'BAC', 'bac_map', 'name,synonym,clone_name' ],
        [ 'BAC ends', 'bacends', 'name,synonym,clone_name', 'otherfeatures' ]
      ]
    );

  my $COREDB   = $conf->{'dbs'}->{'ENSEMBL_DB'};
  my $ESTDB    = $conf->{'dbs'}->{'ENSEMBL_OTHERFEATURES'};
  open O, ">$conf->{'directory'}/Sequence.txt";
  my @types = @{$config{$conf->{'species'}}||[]};
  foreach my $arrayref ( @types ) {
    my( $TYPE, $mapsets, $annotationtypes,$DB ) = @$arrayref;
    my $DB = $DB eq 'otherfeatures' ? $ESTDB : $COREDB;
    my @temp         = split (',',$mapsets);        
    my @mapsets;
    foreach my $X ( @temp ) {
       my $ID = $conf->{'dbh'}->selectrow_array( "select misc_set_id from $DB.misc_set where code = ?", {}, $X );
      push @mapsets, $ID if($ID);
    }
    next unless @mapsets;
    @temp = split (',',$annotationtypes);        
    my @mapannotationtypes;
    foreach my $X ( @temp ) {
      my $ID = $conf->{'dbh'}->selectrow_array( "select attrib_type_id from $DB.attrib_type where code = ?", {}, $X );
      push @mapannotationtypes, $ID if($ID);
    }
    next unless @mapannotationtypes;
    my $Z = " ma.value";
    my $MAPSETS = join ',',@mapsets;
    my $sth = $conf->{'dbh'}->prepare(
      "select mf.misc_feature_id, sr.name,
              ma.value, mf.seq_region_end-mf.seq_region_start+1 as len, 
              at.code
         from $DB.misc_feature_misc_set as ms, 
              $DB.misc_feature as mf,
              seq_region   as sr,
              $DB.misc_attrib  as ma,
              $DB.attrib_type  as at 
        where mf.seq_region_id = sr.seq_region_id and mf.misc_feature_id = ms.misc_feature_id and ms.misc_set_id in ($MAPSETS) and
              mf.misc_feature_id = ma.misc_feature_id and ma.attrib_type_id = at.attrib_type_id
        order by mf.misc_feature_id, at.code"
    );
    $sth->execute();
    my ($oldtype,$old_ID,$oldchr,$emblaccs,$oldlen,$synonyms, $NAME );
    while( my($ID,$chr,$val,$len,$type) = $sth->fetchrow_array() ) {
      if($ID == $old_ID) {
        $NAME = $val if $type eq 'well_name' || $type eq 'clone_name' || $type eq 'name' || $type eq 'non_ref';
        $NAME = $val if !$NAME && $type eq 'embl_acc';
        $NAME = $val if !$NAME && $type eq 'synonym';
        $NAME = $val if !$NAME && $type eq 'sanger_project';
        $emblaccs.=", $val" if $val;
      } else {
        print O &seqLine( $conf->{'species'}, $TYPE, $NAME, $oldchr, $emblaccs,$oldlen,$sanger) if $old_ID;
        $NAME = undef;
        $NAME = $val if $type eq 'well_name' || $type eq 'clone_name' || $type eq 'name' || $type eq 'non_ref';
        $NAME = $val if !$NAME && $type eq 'embl_acc';
        $NAME = $val if !$NAME && $type eq 'synonym';
        $NAME = $val if !$NAME && $type eq 'sanger_project';
        ($old_ID,$oldchr,$emblaccs,$oldlen) = ($ID,$chr,$val,$len);
      }
    }
    print O &seqLine( $conf->{'species'}, $TYPE, $NAME, $oldchr, $emblaccs ,$oldlen,$sanger) if $old_ID;
  }

  my $sth = $conf->{'dbh'}->prepare(
    "select c.name, c.length, cs.name
       from seq_region as c, coord_system as cs
      where c.coord_system_id = cs.coord_system_id" );
  $sth->execute();
  while( my($name,$length,$type) = $sth->fetchrow_array() ) {
    my $extra_IDS = ''; my $extra_desc = '';
    if( %{$sanger->{$name}||{}} ) {
      $extra_IDS  = join ' ', '',sort keys %{$sanger->{$name}};
      $extra_desc = " and corresponds to the following Sanger projects: ".join( ', ',sort keys %{$sanger->{$name}});
    }
    print O join "\t",
      (INC_SPECIES?"$conf->{'species'}\t":"").ucfirst($type),       $name,
      ($type eq 'chromosome' && length( $name ) < 5) ?
        "/$conf->{'species'}/mapview?chr=$name" :
        ($length > 0.5e6 ? "/$conf->{'species'}/cytoview?region=$name" :
              "/$conf->{'species'}/contigview?region=$name" ),
      "$name$extra_IDS", "$name is a @{[ucfirst($type)]} (of length $length)$extra_desc\n";
  }
  close O;
}

sub seqLine {
  my($species,$type,$name,$chr,$val,$len,$sanger) = @_;
  my $Q = $val; $Q=~s/,//g;
  my $SCRIPT = $len > 0.5e6 ? 'cytoview' : 'contigview';
  my $extra_IDS = '';
  my $extra_desc = '';
  my %HASH;
  foreach ( split / +/,"$name $val" ) {
    foreach( keys %{$sanger->{$name}||{}} ) {
      $HASH{$_}=1;
    }
  }
  if( %HASH ) {
    $extra_IDS  = join ' ', '',sort keys %HASH;
    $extra_desc = " and corresponds to the following Sanger projects: ".join( ', ',sort keys %HASH );
  }

  return join "\t",
    (INC_SPECIES?"$species\t":"").$type,
    $name, "/$species/$SCRIPT?mapfrag=$name",
    "$name $Q$extra_IDS",
    "$type $name is mapped to Chromosome $chr, and has". (($val &&  ($val ne "")) ? " EMBL accession(s)/synonyms $val and " : "").
    " length $len bps$extra_desc\n";
}

########################################################################## Sanger Projects

sub sanger_project_names {
  my $conf = shift;
  my %SPECIES = qw(
    Homo_sapiens Human Mus_musculus Mouse Danio_rerio Zebrafish
    Drosophila_melanogaster Drosophila Rattus_norvegicus Rat
  );
  my $sanger_species_name = $SPECIES{$conf->{'species'}};
  return {} unless $sanger_species_name;
  my $clones = {};
  my $dbh = DBI->connect("DBI:mysql:host=otterlive;port=3301;database=submissions", 'ottro', undef, {RaiseError => 1});
  unless( $dbh ) {
    warn "Can't connect to submissions database as 'read_only' ", DBI::errstr();
    return $clones;
  }
  my $sth = $dbh->prepare(
    "SELECT distinct a.project_name, a.accession 
       FROM project_acc a, project_dump d,
            sequence s, species_chromosome c
      WHERE a.sanger_id = d.sanger_id AND d.seq_id = s.seq_id
        AND s.chromosome_id = c.chromosome_id 
        AND c.species_name = '$sanger_species_name' AND a.accession != 'UNKNOWN'"
  );
  $sth->execute(  );
  while( my ($proj, $acc) = $sth->fetchrow() ) {
    $clones->{$acc}{$proj}=1;
  }
  return $clones;
}
