#!/usr/local/bin/perl

use strict;

my $ENSEMBL_ROOT;

BEGIN {
  use FindBin qw($Bin);
  use File::Basename qw( dirname );
  $ENSEMBL_ROOT = dirname( $Bin );
  $ENSEMBL_ROOT =~ s/\/utils$//;
  unshift @INC, "$ENSEMBL_ROOT/conf";
  eval{ require SiteDefs };
  if ($@){ die "Can't use SiteDefs.pm - $@\n"; }
  map{ unshift @INC, $_ } @SiteDefs::ENSEMBL_LIB_DIRS;
}

use EnsEMBL::Web::SpeciesDefs;
use Data::Dumper;
package indexDumper;

use constant INC_SPECIES => 0;
use CGI;

our $SD = EnsEMBL::Web::SpeciesDefs->new();

my ( $SPECIES_STRING, @indexes) = @ARGV;

## HACK 1 - if the INDEX is set to all grab all dumper methods...
@indexes = map { /dump(\w+)/?$1:() } keys %indexDumper:: if $indexes[0] eq 'ALL';

## HACK 2 - if the SPECIES is set to ALL grab stuff from config...

my @species;
my %X = %{$SD->ENSEMBL_SPECIES_ALIASES};

if( $SPECIES_STRING eq 'ALL' ) {
  @species = @{$SD->ENSEMBL_SPECIES}
} else {
  @species = grep {$_} map { $X{lc($_)} } split /:/, $SPECIES_STRING;
}

# EnsEMBL::Web::IndexSupport takes path to conf, path to files, species
my $conf = {};
mkdir 'input', 0777 unless -e 'input';

foreach my $species ( @species ) {
  $conf->{'directory'} = "input/$species";
  mkdir $conf->{'directory'}, 0777 unless -e  $conf->{'directory'};
  $conf->{'species'}   = $species;
  my %dbs = %{$SD->get_config($species,'databases')||{}};
  $conf->{'dbs'}       = { map { ($_,$dbs{$_}{NAME}) } keys %dbs };
  $conf->{'dbs'}{'ENSEMBL_COMPARA'} = 'ensembl_compara_43';
  my $core = $dbs{'ENSEMBL_DB'};
  $conf->{'dbh_compara'}       = DBI->connect( "dbi:mysql:ensembl_compara_43;host=ensdb-1-03;port=3303",
        $core->{'USER'}, $core->{'PASS'} );
  $conf->{'dbh'}       = DBI->connect( "dbi:mysql:$core->{'NAME'};host=$core->{'HOST'};port=$core->{'PORT'}",
        $core->{'USER'}, $core->{'PASS'} );
  warn join ' ', $species, Data::Dumper::Dumper $conf;
  foreach my $index (@indexes) {
    warn "  Index: $species $index";
    my $function = "dump$index";
    no strict "refs";
    &$function( $conf );
  }
}

## Now for all the dump functions...............................

########################################################################## SNPs

sub dumpSNP {
  my $conf = shift;
#  next if $conf->{'species'} eq 'Homo_sapiens'; ## SKIP HUMAN SNPS....
#  next if $conf->{'species'} eq 'Mus_musculus'; ## SKIP HUMAN SNPS....
  my $SNPDB = $conf->{'dbs'}->{'ENSEMBL_VARIATION'};

  `/mysqld/current/bin/mysql -h ensdb-1-01 -uensro $SNPDB -e 'select variation_id,source_id,name from variation order by variation_id' > v.txt`;
  `/mysqld/current/bin/mysql -h ensdb-1-01 -uensro $SNPDB -e 'select variation_id,source_id,name from variation_synonym order by variation_id' > vs.txt`;

  return unless $SNPDB;
  my $SOURCES = { map { @$_ } @{$conf->{'dbh'}->selectall_arrayref( "select source_id, name from $SNPDB.source" )} };
  
  open( my $fh1, 'v.txt' );
  open( my $fh2, 'vs.txt' );
  open( my $fh3, '>snps.txt' );
  my $shift = <$fh1>; # remove first line
  $shift = <$fh2>;
  my $F=1;
  my $snp1 = n($fh1,$SOURCES);
  my $snp2 = n($fh2,$SOURCES) || [0,0,''];
  while( $snp1 && $snp2 ) {
#   warn "$snp1->[0]-$snp2->[0]";
    if( $snp2->[0] ) {
      if( $snp1->[0] ) {
        if($snp2->[0]<$snp1->[0]) {
          warn "ARGH!! snp2_ID < snp1_ID panic!! @{$snp2}";
          $snp2 = n($fh2,$SOURCES)||[0,0,'']; # get next synonym
        } elsif($snp2->[0]>$snp1->[0]) {
          print $fh3 "@$snp1\n";
          $snp1 = n($fh1,$SOURCES); # get next snp...
        } else {
          push @{$snp1}, "$snp2->[1]:$snp2->[2]";
          $snp2 = n($fh2,$SOURCES)||[0,0,'']; # get next snp2
        }
      } else {
        warn "ARGH!!!! run out of snps";
      }
    } elsif( $snp1->[0] ) {
      print $fh3 "@$snp1\n";
      $snp1 = n($fh1,$SOURCES);
    } else {
      $F = 0;
    }
  }
  if($snp1) {
    print $fh3 "@$snp1\n";
  }

  unlink 'v.txt';
  unlink 'vs.txt';
  close $fh1;
  close $fh2;
  close $fh3;
  open I, 'snps.txt' ;
  open O, ">$conf->{'directory'}/SNP.txt";
  while(<I>) {
    my($ID,$source,$name,@keywords) = split;
    my @K = map { (my $t=$_)=~ s/^\w+://;$t } @keywords;
    print O "$source SNP\t$name\t/$conf->{'species'}/snpview?source=$source;snp=$name\t$name @K\tA $source SNP with ".
      (@keywords?@keywords.(" synonym".(@keywords>1?'s':'')." (@keywords)"):'no synonyms')."\n";
  }
  close O;
  close I;
}

sub n {
  my( $fh, $sources ) = @_;
  my $L = <$fh>;
  my $snp;
  if( $L ) {
    chomp $L;
    my @L = split /\t/, $L;
    $snp = [ $L[0], $sources->{$L[1]}, $L[2]];
  }
  return $snp;
}

sub snpLine {
  my ($species, $source, $snpid, $IDS, $desc ) =@_;
  return if $snpid eq '';
  $desc =~ s/^, //;
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(Ensembl SNP),
    $snpid,
    "/$species/snpview?snp=$snpid;source=$source",
    "$IDS",
    "SNP $snpid. Alternative IDs: $desc.\n";
}

1;
