<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 1.1.3  (Linux)">
	<META NAME="CREATED" CONTENT="20050823;13413200">
	<META NAME="CHANGED" CONTENT="20050823;19030200">
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1>Mapping Affymetrix probe sets to Ensembl transcripts</H1>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><A HREF="#introduction">Introduction</A>
		</P>
	<LI><P STYLE="margin-bottom: 0cm"><A HREF="#run">How to run the
	mappings</A> 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><A HREF="#probeset2transcriptlog">probeset2transcript.log</A>
		</P>
	<LI><P><A HREF="#usefulsql">Useful SQL</A> 
	</P>
</UL>
<H2><A NAME="introduction"></A>Introduction</H2>
<P>Microarray probe sets (aka composites) are mapped to transcripts
by the Java program org.ensembl.probemapping.ProbeMapper which reads
and writes data to/from an ensembl core database. The probe sets are
read from the “affy_*” tables and the transcripts from the
“transcript” table. Mappings are stored as standard ensembl xrefs
in the “xref” and “object_xref” tables. The probe sets and
transcripts must be populated <B>before</B> this program is run. 
</P>
<P>In addition to storing xrefs the program produces a
<A HREF="#probeset2transcriptlog">probeset2transcript.log</A> file
which details why every overlapping transcript and probe set pair
were or were not mapped.</P>
<P>Mapping works by finding overlapping probesets and transcripts
where at least 50% of the probes in the set overlap the transcript's
cDNA or 2000 bases downstream of it. A probe is considered to hit the
transcript if it's 25 bases match exactly or there is at most a 1
base substitution. Probes which cross exon boundaries are currently
ignored. 
</P>
<H2><A NAME="run"></A>How to run the mapping</H2>
<P>In the simplest case (described here) we assume the affy and
transcript data are in the same database we want to store the
mappings and you are running the mapping on a *nix computer. 
</P>
<OL>
	<LI><P>Create a directory for the mapping session. It is helpful to
	name it after the database to be mapped. 
	</P>
	<PRE>mkdir musculus_core_33_34a
cd musculus_core_33_34a</PRE>
	<LI><P>Backup “object_xref” and “xref” tables in case you
	need to restore them later. 
	</P>
	<PRE>mkdir backup
cd backup
mysqldump -h ecs2 -P3364 -u ensro -t mus_musculus_core_33_34a xref &gt; xref.txt
mysqldump -h ecs2 -P3364 -u ensro -t mus_musculus_core_33_34a object_xref &gt; object_xref.txt         </PRE>
	<LI><P>Create a configuration file called <B>db.properties</B>
	(mus_musculus_core_33_34a in the example) which specifies the
	database connection parameters.</P>
	<PRE>database mus_musculus_core_33_34a
host ecs2
port 3364
user ensadmin
password XXXXXX                </PRE>
	<LI><P>Run the script ensj-core/scripts/probeset2transcriptmapper.sh
	(available via CVS). This will continue to run even if you log out
	and all output is redirected to nohup.txt. You can view the programs
	output as it runs using “tail”. 
	</P>
	<PRE>PATH_TO_SCRIPTS/probeset2transcriptmapper.sh
tail -f nohup.txts</PRE>
	<OL>
		<LI><P>If there are any problems then you might need to fix the
		database by <A HREF="#missing">adding missing data</A>.</P>
	</OL>
</OL>
<UL>
	<LI><P>Check the results.</P>
</UL>
<OL>
	<LI><P>Generate some <A HREF="#status">status information</A> about
	the mappings. Running <I>affy_report.sql</I> will be probably be
	adequate.</P>
	<LI><P>Compare the results to a previous database if the mapping has
	been done before for this species by running the <I>affy_compare_dbs.py
	</I>python script in a subdirectory. In addition to printing the
	results to the console they are written to <I>report.txt. </I>&gt;Note
	that several intermediate files are also written to the directory.</P>
	<PRE>mkdir comparison
cd comparison
PATH_TO_SCRIPTS/affy_compare_ds.py</PRE>
</OL>
<H2><A NAME="probeset2transcriptlog"></A>probeset2transcript.log</H2>
<P>The output file “probeset2transcript.log” produced by the
ProbeMapper lists every overlapping probeset and transcript pair and
why they where or where not mapped. The format of the file is as
follows:</P>
<PRE>LINE = PROBESET_NAME    TRANSCRIPT_STABLE_ID    MAPPED_STATE     STATS   DESCRIPTION[,DESCRIPTION]* 

MAPPED_STATE = {0 | 1} # 0 = unmapped, 1 = mapped, quick to search if loaded into db

STATS = PROBE_SET_SIZE    NUM_EXON_HITS    NUM_INTRON_HITS    NUM_HITS_ON_REVERSE_STRAND

PROBE_SET_SIZE = number of probes in the microarray(s) this composite appears in

NUM__HITS = number of times a probe from the composite hits an exon in the transcript (same strand)

NUM_INTRON = number of times a probe from the composite hits an intron in the transcript (same strand)

NUM_HITS_ON_REVERSE_STRAND = number of times a probe from the
                             composite hits any where on the reverse strand of the extent transcript+flank

DESCRIPTION = {mapped | intronic | insufficient | antisense | promiscuous}+

Example lines:
--------------
comp_at_1    ENST1    1    11    10    0    0    mapped
comp_at_2    ENST2    1    11    9     1    0    mapped,intronic
comp_at_3    ENST3    0    16    0     12   0    insufficient,intronic
comp_at_3    ENST4    0    16    0     0    10   insufficient,antisense
comp_at_4    ENST4    0    16    2     2    10
insufficient,intronic,antisense</PRE><H2>
<A NAME="usefulsql"></A>Useful SQL</H2>
<H3><A NAME="status"></A>Status information</H3>
<UL>
	<LI><P>Run ensj-core/scripts/affy_report.sql against the database to
	get some useful stats.</P>
	<LI><P>Find the number of affy xref entries.</P>
	<PRE>  select count(*) from xref where external_db_id&gt;3000 and
    external_db_id&lt;3200</PRE>
	<LI><P>Find the number of transcript-probeset mappings in the
	database.</P>
	<PRE>  select count(*) from xref x, object_xref ox where
   external_db_id&gt;3000 and external_db_id&lt;3200 and
   x.xref_id=ox.xref_id;</PRE>
	<LI><P>Find the number of probesets each transcript is mapped to
	(ignores unmapped transcripts). 
	</P>
	<PRE>  select count(*) as count_unique_transcript2probeset_mappings from
    object_xref ox, xref x 
    where ox.xref_id=x.xref_id and external_db_id&gt;3000 and
    external_db_id&lt;3200 
    group by ensembl_id,display_label;</PRE>
	<LI><P>Find any (broken) object_xref entries that lack corresponding
	from xref entries. 
	</P>
	<PRE>  select count(*) from object_xref left join xref on
    object_xref.xref_id=xref.xref_id where xref.xref_id is NULL;</PRE>
</UL>
<H3><A NAME="missing"></A>Add missing data</H3>
<UL>
	<LI><P>Database fix: Add an affy_feature entry to the meta_coord
	table if it is missing. This is needed during the mapping process. 
	</P>
	<PRE>  select coord_system_id from affy_feature af, seq_region sr where
  af.seq_region_id=sr.seq_region_id limit 1;

  insert into meta_coord values ('affy_feature', COORD_SYSTEM_ID, 25);</PRE>
	<LI><P>Database fix: Add the probeset sizes of the affymetrix arrays
	to the affy_array table. This information is needed during the
	mapping process.</P>
	<PRE>  update affy_array set probe_setsize=16 where name='HG-U95B';
  update affy_array set probe_setsize=16 where name='HG-U95D';
  update affy_array set probe_setsize=11 where name='U133_X3P';
  update affy_array set probe_setsize=11 where name='HG-U133A';
  update affy_array set probe_setsize=16 where name='HG-U95Av2';
  update affy_array set probe_setsize=11 where name='HG-U133B';
  update affy_array set probe_setsize=11 where name='HG-U133A_2';
  update affy_array set probe_setsize=11 where name='HG-Focus';
  update affy_array set probe_setsize=11 where name='HG-U133_Plus_2';
  update affy_array set probe_setsize=16 where name='HG-U95E';
  update affy_array set probe_setsize=16 where name='HG-U95C';
  update affy_array set probe_setsize=20 where name='HuGeneFL';
  update affy_array set probe_setsize=16 where name='HC-G110';

  update affy_array set probe_setsize=11 where name='Canine';

  update affy_array set probe_setsize=16 where name='RG-U34C';
  update affy_array set probe_setsize=16 where name='RG-U34B';
  update affy_array set probe_setsize=16 where name='RG-U34A';
  update affy_array set probe_setsize=11 where name='Rat230_2';

  update affy_array set probe_setsize=11 where name='Mouse430_2';
  update affy_array set probe_setsize=20 where name='Mu11KsubA';

  update affy_array set probe_setsize=20 where name='Mu11KsubB';
  update affy_array set probe_setsize=11 where name='Mouse430A_2'; 
  update affy_array set probe_setsize=16 where name='MG-U74Bv2';
  update affy_array set probe_setsize=16 where name='MG-U74Cv2';
  update affy_array set probe_setsize=16 where name='MG-U74Av2';

  update affy_array set probe_setsize=14 where name='DrosGenome1';
  update affy_array set probe_setsize=14 where name='Drosophila_2';</PRE>
</UL>
<H3>Update internal ids (if built in test database) 
</H3>
<UL>
	<LI><P>Increment xref_id and object_xref_id values. This is usually
	only necessary if we created the output in a temporary database and
	need to change the ids so that they do not clash with ids in the
	release database. 
	</P>
	<PRE>update xref set xref_id=xref_id+2558994;
update object_xref set xref_id=xref_id+2558994;
update object_xref set object_xref_id=object_xref_id+5672274; </PRE>
</UL>
</BODY>
</HTML>
