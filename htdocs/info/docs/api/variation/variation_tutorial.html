c<html>
<head>
<title>Variation API Tutorial</title>
</head>

<body>

<h1>Variation API Tutorial</h1>

<ul>
	<li><a href="#intro">Introduction</a></li>
	<li><a href="#code">Code Conventions (and unconventions)</a></li>
	<li><a href="#connect">Connecting an Ensembl variation database</a></li>
	<li><a href="#genome">Variations in the genome</a></li>
	<li><a href="#alleles">Alleles and frequencies</a></li>
	<li><a href="#Consequence">Consequence type of variations</a></li>
	<li><a href="#flanks">Variations, Flanking sequences and Genes</a></li>
	<li><a href="#failed_variations">Failed variations</a></li>
	<li><a href="#annotation">Variation annotations</a></li>
	<li><a href="#variation_sets">Variation sets</a></li>
	<li><a href="#structural">Structural variations</a></li>
	<li><a href="#ld">LD calculation</a></li>
	<li><a href="#strains">Specific strain information</a></li>
	<li><a href="#help">Further help</a></li>
</ul>

<h2 id="intro">Introduction</h2>

<p>
This tutorial is an introduction to the
<a href="./index.html">Ensembl Variation API</a>.
Knowledge of the 
<a href="/info/docs/api/core/index.html">Ensembl Core API</a> and of the concepts and conventions in the
<a href="/info/docs/api/core/core_tutorial.html">Ensembl Core API tutorial</a> is assumed.

Documentation about the Variation database schema is available at
<a href="http://cvs.sanger.ac.uk/cgi-bin/viewvc.cgi/ensembl-variation/schema/?root=ensembl">
http://cvs.sanger.ac.uk/cgi-bin/viewvc.cgi/ensembl-variation/schema/?root=ensembl</a> 
, and while not necessary for this tutorial, an understanding of the database tables may help as many of the adaptor modules are table-specific.
</p>

<h2 id="code">Code Conventions (and unconventions)</h2>

<p>
Refer to the Ensembl core tutorial for a good description of the coding conventions normally used in Ensembl. Please note that there may be exceptions to these rules in variation.
</p>


<h2 id="connect">Connecting an Ensembl variation database</h2>

<p>
Connecting to an Ensembl variation database is made simple by using the Bio::EnsEMBL::Registry module:
</p>

<pre class="code">
use Bio::EnsEMBL::Registry;

my $registry = 'Bio::EnsEMBL::Registry';

$registry-&gt;load_registry_from_db(
    -host =&gt; 'ensembldb.ensembl.org',
    -user =&gt; 'anonymous'
);
</pre>

<p> The use of the registry ensures you will load the correct versions of the
Ensembl databases for the software release it can find on a database instance.
Using the registry object, you can then create any of number of database
adaptors. Each of these adaptors is responsible for generating an object of one
type. The Ensembl variation API uses a number of object types that relate to the
data stored in the database. For example, in order to generate variation
objects, you should first create a variation adaptor: </p>

<pre class="code">
use Bio::EnsEMBL::Registry;

my $registry = 'Bio::EnsEMBL::Registry';

$registry-&gt;load_registry_from_db(
    -host =&gt; 'ensembldb.ensembl.org',
    -user =&gt; 'anonymous'
);

my $variation_adaptor = $registry-&gt;get_adaptor(
	'human',	# species
	'variation',	# database
	'variation'	# object type
);

my $variation = $variation_adaptor-&gt;fetch_by_name('rs1333049');
</pre>

<p>
	The get_adaptor method will automatically create a connection to the
	relevant database; in the example above, a connection will be made to the
	variation database for human. The three parameters passed specify the
	species, database and object type you require. Below is a non exhaustive
	list of Ensembl variation adaptors that are most often used
</p>

<ul>
<li>IndividualAdaptor to fetch Bio::EnsEMBL::Variation::Individual objects</li>
<li>LDFeatureContainerAdaptor to fetch Bio::EnsEMBL::Variation::LDFeatureContainer objects</li>
<li>PopulationAdaptor to fetch Bio::EnsEMBL::Variation::Population objects</li>
<li>ReadCoverageAdaptor to fetch Bio::EnsEMBL::Variation::ReadCoverage objects</li>
<li>TranscriptVariationAdaptor to fetch Bio::EnsEMBL::Variation::TranscriptVariation objects</li>
<li>VariationAdaptor to fetch Bio::EnsEMBL::Variation::Variation objects</li>
<li>VariationFeatureAdaptor to fetch Bio::EnsEMBL::Variation::VariationFeature objects</li>
</ul>

<p>
Only some of these adaptors will be used for illustration as part of this tutorial through commented perl scripts code.
</p>


<h2 id="genome">Variations in the genome</h2>

<p>
One of the most important uses for the variation database is to be able to get all variations in a certain region in the genome.
Below it is a simple commented perl script to illustrate how to get all variations in chromosome 25 in zebrafish.
</p>

<pre class="code">
use strict;
use warnings;
use Bio::EnsEMBL::Registry;

my $registry = 'Bio::EnsEMBL::Registry';

$registry-&gt;load_registry_from_db(
    -host =&gt; 'ensembldb.ensembl.org',
    -user =&gt; 'anonymous'
);

my $slice_adaptor = $registry-&gt;get_adaptor('danio_rerio', 'core', 'slice'); #get the database adaptor for Slice objects
my $slice = $slice_adaptor-&gt;fetch_by_region('chromosome',25); #get chromosome 25 in zebrafish

my $vf_adaptor = $registry-&gt;get_adaptor('danio_rerio', 'variation', 'variationfeature'); #get adaptor to VariationFeature object
my $vfs = $vf_adaptor-&gt;fetch_all_by_Slice($slice); #return ALL variations defined in $slice

foreach my $vf (@{$vfs}){
  print "Variation: ", $vf-&gt;variation_name, " with alleles ", $vf-&gt;allele_string, 
        " in chromosome ", $slice-&gt;seq_region_name, " and position ", $vf-&gt;start,"-",$vf-&gt;end,"\n";
}
</pre>

<h2 id="alleles">Alleles and frequencies</h2>

<p>
Most variations in the Ensembl Variation database have associated allele frequencies. Each allele object associated with a variation represents an observation of a variant allele in a given population, and may have an associated frequency. Populations are also represented as objects.
</p>

<pre class="code">
use strict;
use warnings;
use Bio::EnsEMBL::Registry;

my $registry = 'Bio::EnsEMBL::Registry';

$registry-&gt;load_registry_from_db(
    -host =&gt; 'ensembldb.ensembl.org',
    -user =&gt; 'anonymous'
);

my $variation_adaptor = $registry-&gt;get_adaptor('mus_musculus', 'variation', 'variation');

my $variation = $variation_adaptor-&gt;fetch_by_name('rs4224828');
my $alleles = $variation-&gt;get_all_Alleles();

foreach my $allele(@{$alleles}) {
	print "Allele ", $allele-&gt;allele, " has frequency ", $allele-&gt;frequency,
		" in population ", $allele-&gt;population-&gt;name, "\n";
}
</pre>


<h2 id="Consequence">Consequence type of variations</h2>

<p>
Another common use of the variation database is to retrieve the effects that
variations have on a transcript. In human, Ensembl also provides <a
href="http://sift.jcvi.org/" target="_blank">SIFT</a> and <a
href="http://genetics.bwh.harvard.edu/pph/" target="_blank">PolyPhen</a>
predictions of the effects of non-synonymous protein changes. For a complete
list of the consequence types predicted by Ensembl, <a
href="../../variation/index.html">click here</a>.
</p>

<p>Consequences are represented by a heirarchy of objects as shown below:</p>

<ul>
	<li><strong>TranscriptVariation</strong> - represents the overlap of a variation feature and a transcript</li>
	<ul>
		<li><strong>TranscriptVariationAllele</strong> - the component represented by a particular allele of a variation</li>
		<ul>
			<li><strong>OverlapConsequence</strong> - represents the consequence itself</li>
		</ul>
	</ul>
</ul>

<p>
In the example below, it is explained how to get all variations in a particular
human transcript and see what is the effect of that variation in the transcript,
including the PolyPhen and SIFT predictions. It is also shown how to retrieve
the Sequence Ontology terms for the consequences.
</p>

<pre class="code">
use strict;
use warnings;
use Bio::EnsEMBL::Registry;

my $registry = 'Bio::EnsEMBL::Registry';

$registry-&gt;load_registry_from_db(
    -host =&gt; 'ensembldb.ensembl.org',
    -user =&gt; 'anonymous'
);

my $stable_id = 'ENST00000393489'; #this is the stable_id of a human transcript
my $transcript_adaptor = $registry-&gt;get_adaptor('homo_sapiens', 'core', 'transcript'); #get the adaptor to get the Transcript from the database
my $transcript = $transcript_adaptor-&gt;fetch_by_stable_id($stable_id); #get the Transcript object

my $trv_adaptor = $registry-&gt;get_adaptor('homo_sapiens', 'variation', 'transcriptvariation'); #get the adaptor to get TranscriptVariation objects
my $trvs = $trv_adaptor-&gt;fetch_all_by_Transcripts([$transcript]); #get ALL effects of Variations in the Transcript

foreach my $tv (@{$trvs}) {
	my $tvas = $tv-&gt;get_all_alternate_TranscriptVariationAlleles();

	foreach my $tva(@{$tvas}) {
		my @ensembl_consequences;
		my @so_consequences;
		
		my $ocs = $tva-&gt;get_all_OverlapConsequences();
		
		foreach my $oc(@{$ocs}) {
			push @ensembl_consequences, $oc-&gt;display_term;
			push @so_consequences, $oc-&gt;SO_term;
		}
		
		my $sift = $tva-&gt;sift_prediction;
		my $polyphen = $tva-&gt;polyphen_prediction;
		
		print
			"Variation ", $tv-&gt;variation_feature-&gt;variation_name,
			 " allele ", $tva-&gt;variation_feature_seq,
			 " has consequence ", join(",", @ensembl_consequences),
			 " (SO ", join(",", @so_consequences), ").";
			 
		if(defined($sift)) {
			print " SIFT=$sift";
		}
		if(defined($polyphen)) {
			print " PolyPhen=$polyphen";
		}
		
		print "\n";
	}
}
</pre>


<p>
It is also possible to calculate consequence types for variations not currently in the database. In the example below, we create a VariationFeature object from scratch, given a slice and VariationFeatureAdaptor object, and use this to calculate the consequence of our new SNP. Here we use the aggregation methods in the TranscriptVariation object instead of retrieving each TranscriptVariationAllele and OverlapConsequence object.
</p>
<p>
A script is also provided in ftp://ftp.ensembl.org/pub/misc-scripts/ that will calculate consequence types from a list of variations provided in an input file.
</p>

<pre class="code">
use strict;
use Bio::EnsEMBL::Registry;

# get registry
my $reg = 'Bio::EnsEMBL::Registry';
$reg->load_registry_from_db(-host => 'ensembldb.ensembl.org',-user => 'anonymous');

my $vfa = $reg->get_adaptor('human', 'variation', 'variationfeature');
my $sa = $reg->get_adaptor('human', 'core', 'slice');

# get a slice for the new feature to be attached to
my $slice = $sa->fetch_by_region('chromosome', 13);

# create a new VariationFeature object
my $new_vf = Bio::EnsEMBL::Variation::VariationFeature->new(
  -start => 114268626,
  -end => 114268626,
  -slice => $slice,           # the variation must be attached to a slice
  -allele_string => 'A/C',    # the first allele should be the reference allele
  -strand => 1,
  -map_weight => 1,
  -adaptor => $vfa,           # we must attach a variation feature adaptor
  -variation_name => 'newSNP',
);

# get the consequence types
my $cons = $new_vf->get_all_TranscriptVariations();

foreach my $con(@{$new_vf->get_all_TranscriptVariations}) {
  foreach my $string(@{$con->consequence_type}) {
    print
      "Variation ", $new_vf->variation_name,
      " at position ", $new_vf->seq_region_start,
      " on chromosome ", $new_vf->seq_region_name,
      " has consequence ", $string,
      " in transcript ", $con->transcript->stable_id, "\n";
  }
}
</pre>


<h2 id="flanks">Variations, Flanking sequences and Genes</h2>

<p>
Below is a complete example on how to use the variation API to retrieve different data from the database. In this particular example, 
we want to get, for a list of variation names, information about alleles, flanking sequences, locations, effects of variations
in transcripts, position in the transcript (in case it has a coding effect) and genes containing the transcripts.
</p>

<pre class="code">
use strict;
use warnings;
use Bio::EnsEMBL::Registry;

my $registry = 'Bio::EnsEMBL::Registry';

$registry-&gt;load_registry_from_db(
    -host =&gt; 'ensembldb.ensembl.org',
    -user =&gt; 'anonymous'
);

my $va_adaptor = $registry-&gt;get_adaptor('human', 'variation', 'variation'); #get the different adaptors for the different objects needed
my $vf_adaptor = $registry-&gt;get_adaptor('human', 'variation', 'variationfeature');
my $gene_adaptor = $registry-&gt;get_adaptor('human', 'core', 'gene');

my @rsIds = qw(rs1367827 rs1367830);
foreach my $id (@rsIds){
# get Variation object
  my $var = $va_adaptor-&gt;fetch_by_name($id); #get the Variation from the database using the name
  &amp;get_VariationFeatures($var);
}

sub get_VariationFeatures{
  my $var = shift;
  # get all VariationFeature objects: might be more than 1 !!!
  foreach my $vf (@{$vf_adaptor-&gt;fetch_all_by_Variation($var)}){
      print $vf-&gt;variation_name(),","; # print rsID
      print $vf-&gt;allele_string(),","; # print alleles
      print join(",",@{$vf-&gt;get_consequence_type()}),","; # print consequenceType
      print substr($var-&gt;five_prime_flanking_seq,-10) , "[",$vf-&gt;allele_string,"]"; #print the allele string
      print substr($var-&gt;three_prime_flanking_seq,0,10), ","; # print RefSeq
      print $vf-&gt;seq_region_name, ":", $vf-&gt;start,"-",$vf-&gt;end; # print position in Ref in format Chr:start-end
      &amp;get_TranscriptVariations($vf); # get Transcript information
  }
}

sub get_TranscriptVariations{
  my $vf = shift; 
  
  # get all TranscriptVariation objects: might be more than 1 !!!
  my $transcript_variations = $vf-&gt;get_all_TranscriptVariations; #get ALL the effects of the variation in 
                                                                    # different Transcripts
  if (defined $transcript_variations){
    foreach my $tv (@{$transcript_variations}){
      print ",", $tv-&gt;pep_allele_string if (defined $tv-&gt;pep_allele_string);
                                              # the AA change, but only if it is in a coding region
      my $gene = $gene_adaptor-&gt;fetch_by_transcript_id($tv-&gt;transcript-&gt;dbID);
      print ",",$gene-&gt;stable_id if (defined $gene-&gt;external_name); # and the external gene name
    }
  }
  print "\n";
}
</pre>


<h2 id="failed_variations">
	Failed variations
</h2>

<p>
	In the Variation pipeline, quality checks are performed in order to remove variations that contain errors or inconsistencies.
	Prior to Ensembl release 61, much of the data related to these variations that failed the quality checks were deleted from the
	database and no longer accessible. Starting from release 61, these variations are flagged as being failed but all related data
	is kept in the database and can be retrieved via the API or the web interface.
</p>
<p>
	The default API behaviour when fetching multiple objects is not to return data for variations that have been flagged as failed but
	this can be modified in the Bio::EnsEMBL::Variation::DBSQL::DBAdaptor module by setting the include_failed_variations flag. This
	will affect all adaptors that have been created	(and will be created) using the connection until the behaviour is explicitly changed
	again (or the connection to the database is closed).
</p>
<p>
	Below it is a simple commented perl script to illustrate how to get data related to variations that have been flagged as failed.
</p>

<pre class="code">
	
use strict;
use warnings;
use Bio::EnsEMBL::Registry;

my $registry = 'Bio::EnsEMBL::Registry';

$registry-&gt;load_registry_from_db(
    -host =&gt; 'ensembldb.ensembl.org',
    -user =&gt; 'anonymous'
);

# Get the database adaptor for Slice objects for human
my $slice_adaptor = $registry-&gt;get_adaptor('human', 'core', 'slice');
# Get a slice from chromosome 6
my $slice = $slice_adaptor-&gt;fetch_by_region('chromosome','6',133017695,133161157); 

# Get adaptor to VariationFeature object
my $vf_adaptor = $registry-&gt;get_adaptor('human', 'variation', 'variationfeature');

# First, get all variations on the slice. The default behaviour is to exclude variations that have been flagged as failed
my $vfs = $vf_adaptor-&gt;fetch_all_by_Slice($slice); 

# Count the number of variations returned
print "There are " . scalar(@{$vfs}) . " variations in the " . $slice->display_id() . " region\n";

# Now, tell the DBAdaptor that we want the failed variations as well. We get the DBAdaptor via the db() subroutine in our adaptor
$vf_adaptor->db->include_failed_variations(1);

# Again, fetch all variations on the slice but this time include the failed variations
$vfs = $vf_adaptor-&gt;fetch_all_by_Slice($slice); 

# Count the number of variations returned, this number is likely to be higher than when failed variations were omitted
print "There are " . scalar(@{$vfs}) . " variations in the " . $slice->display_id() . " region\n";

</pre>

<p>
	There are a few subroutines to query the failed status of a variation. In the code snippet below we loop over the
	variations we got and find out how many are flagged as failed and why.
</p>

<pre class="code">
	
my $failed = 0;
my %descriptions;
foreach my $vf (@{$vfs}) {
	
	# Check whether the variation for this variation feature is failed
	if ($vf->variation->is_failed()) {
		$failed++;
		
		# Get the reason why the variation failed and count the number of variations failed for the same reason.
		map {$descriptions{$_}++} @{$vf->variation->get_all_failed_descriptions()};
	}
}

# Print the results
print "There are $failed variations on slice " . $slice->display_id() . " that have been flagged as failed:\n";
map { print "\t" . $descriptions{$_} . " variations failed because " . $_ . "\n"; } keys(%descriptions);
	
</pre>

<p>
	Note that some fetch methods are unaffected by the include_failed_variations flag in DBAdaptor. These are methods that
	return data related to specific variations, rather than a general batch fetch. For example, the fetch_by_dbID and
	fetch_all_by_VariationFeatures methods in TranscriptVariationAdaptor will not be affected by the flag whereas the
	fetch_all_by_Transcripts method will be.
</p>
<p>
	Even though a variation has not been failed in the Variation pipeline, some of the alleles associated with it may have been. 
	Variations having failed alleles are not themselves flagged as failed but we can query them to see if any associated alleles 
	have been flagged as failed.
</p>

<pre class="code">
	
foreach my $vf (@{$vfs}) {
	
	# Check whether the variation for this variation feature has failed alleles
	if ($vf->variation->has_failed_alleles()) {
		
		# Get all the alleles associated with the variation and check which ones have failed and why
		my %failed_alleles;
		foreach my $allele (@{$vf->variation->get_all_Alleles()}) {
		
			# Check if the allele is flagged as failed
			if ($allele->is_failed()) {
				
				# Get the reason why
				$failed_alleles{$allele->subsnp() . ":" . $allele->allele()} = $allele->failed_description();
			}
		}
		
		# Print the result
		print "Variation " . $vf->variation_name() . " has the following failed alleles:\n";
		map { print "\t" . $_ . " has been flagged as failed because " . $failed_alleles{$_} . "\n"; } keys(%failed_alleles);
	}
}
	
</pre>

<h2 id="annotation">Variation annotations</h2>

<p>
The Ensembl variation API provides some methods to retrieve phenotype data associated with the variations.
These data, stored into the Ensembl variation database, are imported from different sources (e.g. NHGRI GWAS catalog, OMIM, UniProt, Open Access GWAS Database, EGA, COSMIC, HGMD).</p>
The API allows you to get all the phenotypes associated with a given variation.
<pre class="code">
use strict;
use warnings;
use Bio::EnsEMBL::Registry;

my $registry = 'Bio::EnsEMBL::Registry';

$registry->load_registry_from_db(
    -host => 'ensembldb.ensembl.org',
    -user => 'anonymous'
);

# Fetch a variation object
my $var_adaptor = $registry->get_adaptor('human', 'variation', 'variation');
my $var = $var_adaptor->fetch_by_name('rs1421085');

# Fetch all the variation annotations associated with the variation
my $va_adaptor = $registry->get_adaptor('homo_sapiens', 'variation', 'variationannotation');
foreach my $va (@{$va_adaptor->fetch_all_by_Variation($var)}) {
	print "Variation ", $va->variation_names, " is associated with the phenotype '", $va->phenotype_description,
	      "' in the source ", $va->source_name;
			
	print " with a p-value of ",$va->p_value if (defined($va->p_value));
	
	print ".\n";
	
	next unless defined $va->associated_variant_risk_allele;
	my $risk_allele = (split /\-/, $va->associated_variant_risk_allele)[1];
	print "The risk allele is ", $risk_allele, ".\n";
}
</pre>

<p>It is also possible to retrieve all variations associated with a phenotype description and a source name.</p>

<pre class="code">
my $source_name = 'NHGRI_GWAS_catalog';
my $phenotype   = 'Cardiac hypertrophy';

my $va_adaptor = $registry->get_adaptor('homo_sapiens', 'variation', 'variationannotation');
 
foreach my $va (@{$va_adaptor->fetch_all_by_phenotype_description_source_name($phenotype,$source_name)}) {
	my $external_reference = $va->external_reference;
	$external_reference =~ s/\// ID: /;
	
	print "Variation ", $va->variation_names, " is associated with the phenotype '", $phenotype,
	      "' in the source ", $source_name," (", $external_reference,")\n";
}		
</pre>


<h2 id="variation_sets">
	Variation sets
</h2>

<p>
	Variation sets provide functionality for grouping sets of variation that share some property. For example, we have grouped the variations identified in the three different
	1000 genomes pilot studies into separate variation sets. The sets can be further subdivided into supersets and subsets to reflect hierarchical relationships between them. In the case
	of the 1000 genomes pilot sets, these are divided into subsets based on population. For example, the set representing variations identified in the first 1000 genomes pilot study is named 
	'1000 genomes - Low coverage' and has three subsets: '1000 genomes - Low coverage - CEU', '1000 genomes - Low coverage - CHB+JPT' and '1000 genomes - Low coverage - YRI'. 
</p>
<p>
	In the Ensembl Variation API, variation sets are handled by the module <a href="/info/docs/Pdoc/ensembl-variation/modules/Bio/EnsEMBL/Variation/VariationSet.html">VariationSet</a>, and the accompanying 
	adaptor module, <a href="/info/docs/Pdoc/ensembl-variation/modules/Bio/EnsEMBL/Variation/VariationSetAdaptor.html">VariationSetAdaptor</a>, that interfaces with the underlying database. A VariationSet has
	a name attribute, a brief description and also a short name attribute. In the example below, we will connect to a human variation database, get a VariationSetAdaptor, fetch all available variation sets and 
	print out their names and hierarchical relationships. 
</p>
<p>
	First, we get a connection and an adaptor:
</p>	
<pre class="code">
use strict;
use warnings;
use Bio::EnsEMBL::Registry;

my $registry = 'Bio::EnsEMBL::Registry';

# Load the registry from db
$registry->load_registry_from_db(
    -host => 'ensembldb.ensembl.org',
    -user => 'anonymous'
);

# Get a VariationSetAdaptor on the human variation database
my $vs_adaptor = $registry->get_adaptor('human','variation','variationset');

</pre>
<p>
	Next, we get the VariationSet objects from the adaptor. In order to display the hierarchical relationships between VariationSets, we fetch only the top level sets and for each set, recursively
	get the subsets. We print the name and short name attributes for each set and indicate the hierarchy by increasing indentation.
</p>
<pre class="code">

# Get all top-level variation sets
my $top_vss = $vs_adaptor->fetch_all_top_VariationSets();

# Loop over the top level variation sets and recursively print the subsets
foreach my $top_vs (@{$top_vss}) {
	print_set($top_vs);
}

# We define a function that will help us recurse over the set hierarchy and print the data   
sub print_set {
	my $set = shift;
	my $indent = shift || "";
	
	# Print the set attributes
	printf("\%s\%s (\%s)\n",$indent,$set->name(),$set->short_name());
	
	# Get the subsets that have the current set as immediate parent
	my $subsets = $set->get_all_sub_VariationSets(1);
	
	# Call the print subroutine for each of the subsets with an increased indentation
	foreach my $subset (@{$subsets}) {
		print_set($subset,$indent . "  ");
	}
}
</pre>
<p>
	Running the code in the example above on the e!63 human variation database produces a table similar to the one on the <a href="/info/docs/variation/index.html#variation_sets">About Variation Data</a> page.
</p>
<p>
	In order to get objects for the variations assigned to a variation set, we use the get_Variation_Iterator method. Note that rather than returning a reference to a list of all variation objects, this 
	returns an <a href="/info/docs/Pdoc/ensembl/modules/Bio/EnsEMBL/Utils/Iterator.html">Iterator</a> object. The Iterator allows you to iterate over large numbers of objects without trying to fit them all into
	memory at once which could otherwise easily cause your script to crash. The main methods we will use on the iterator are the has_next() and next() methods. In the example below, we fetch a variation set that contains  
	variations that have been linked to phenotypes and print the first 10 examples. Note that getting variations from a variation set that has subsets below it automatically returns the variations from the subsets.  
</p>
<pre class="code">

  # Get the variation set for the phenotype-associated variants.
  my $vs = $vs_adaptor->fetch_by_short_name('ph_variants');
  
  printf("\%s (\%s):\n\t\%s\n",$vs->name(),$vs->short_name(),$vs->description());
  
  my $limit = 10;
  my $fetched = 0;
  my $it = $vs->get_Variation_Iterator();
  
  # Get the first 10 examples and print some data from them
  while ($fetched < $limit && $it->has_next()) {
  	
  	# Print the name of the variation
  	my $var = $it->next();
  	printf("\t\%s has been found to be associated with:\n",$var->name());
  	
  	# Get the VariationAnnotation objects for the variation
  	my $annotations = $var->get_all_VariationAnnotations();
  	
  	# Loop over the annotations and print the phenotypes
  	foreach my $annotation (@{$annotations}) {
  		printf("\t\t\%s\t\%s\t\%s\n",$annotation->phenotype_description(),(defined($annotation->p_value) ? sprintf("(\%s, \%s study)",$annotation->p_value(),$annotation->study_type()) : ""),$annotation->study_name());
  	}
  	
  	$fetched++;
  }
</pre>
<p>
	You can also use Slices to retrieve VariationFeatures belonging to a desired variation set in a particular genomic region. 
	In the example below, we fetch all VariationFeatures discovered by the third 1000 genomes pilot study on the RIC8A gene.
</p>
<pre class="code">
	# Get the variation set object
	$vs = $vs_adaptor->fetch_by_short_name('1kg_hce');
	
	# Get a gene adaptor and the gene object for the RIC8A gene
	my $gene_adaptor = $registry->get_adaptor('human','core','gene');
	my $gene = $gene_adaptor->fetch_by_display_label('RIC8A');
	
	# Get the variation features on the slice belonging to the variation set
	my $vfs = $vs->get_all_VariationFeatures_by_Slice($gene->feature_Slice());
	
	# Loop over the variation features and print the variation using HGVS notation relative to the canonical transcript
	foreach my $vf (@{$vfs}) {
		my $tvs = $vf->get_all_TranscriptVariations([$gene->canonical_transcript()]);
		my @hgvs_coding = values(%{$tvs->[0]->hgvs_coding()});
		my @hgvs_protein = values(%{$tvs->[0]->hgvs_protein()});
		printf("\%s\t\%s\t\%s\n",$vf->variation_name(),join(",",@hgvs_coding),join(",",@hgvs_protein));
	}
</pre>

<h2 id="structural">Structural variations</h2>

<p>
The Ensembl variation database also stores information about structural variations. These data are imported from the DGVa (Database of Genomic Variants archive). Structural variants are remapped to the current genome assembly using the $slice->project() method from the Ensembl Core API, allowing for one gap in the resultant mapping.</p>

<pre class="code">
use strict;
use warnings;

use Bio::EnsEMBL::Registry;

my $reg = 'Bio::EnsEMBL::Registry';
my $host= 'ensembldb.ensembl.org';
my $user= 'anonymous';

$reg-&gt;load_registry_from_db(
	-host =&gt; $host,
    -user =&gt; $user
);

# get exon adaptor from core
my $sa = $reg-&gt;get_adaptor("human", "core", "slice");

my $slice = $sa-&gt;fetch_by_region('chromosome', 5, 1, 1000000);

# get all structural variations on the slice
my $svs = $slice-&gt;get_all_StructuralVariations();

foreach my $sv(@$svs) {
	print $sv-&gt;variation_name, " ", $sv-&gt;seq_region_name, ":", $sv-&gt;seq_region_start, "-", $sv-&gt;seq_region_end, " ", $sv-&gt;class, "\n";
}
</pre>


<h2 id="ld">LD calculation</h2>

<p>
In order to be able to use the LD calculation, you need to compile the C source code and install a module, called IPC::Run. There is more information
on how to do this in <a href="http://cvs.sanger.ac.uk/cgi-bin/viewvc.cgi/ensembl-variation/C_code/README.txt?root=ensembl&amp;view=markup" rel="external"> Use LD calculation </a>
In the example below, it calculates the LD in a region in human chromosome 6 for a HAPMAP population, but only prints when there is a high LD
</p>

<pre class="code">
use strict;
use warnings;
use Bio::EnsEMBL::Registry;

my $registry = 'Bio::EnsEMBL::Registry';

$registry-&gt;load_registry_from_db(
    -host =&gt; 'ensembldb.ensembl.org',
    -user =&gt; 'anonymous'
);

my $chr = 6;  #defining the region in chromosome 6
my $start = 25_834_000;
my $end = 25_854_000;
my $population_name = 'CSHL-HAPMAP:HapMap-CEU'; #we only want LD in this population

my $slice_adaptor = $registry-&gt;get_adaptor('human', 'core', 'slice'); #get adaptor for Slice object
my $slice = $slice_adaptor-&gt;fetch_by_region('chromosome',$chr,$start,$end); #get slice of the region


my $population_adaptor = $registry-&gt;get_adaptor('human', 'variation', 'population'); #get adaptor for Population object
my $population = $population_adaptor-&gt;fetch_by_name($population_name); #get population object from database

my $ldFeatureContainerAdaptor = $registry-&gt;get_adaptor('human', 'variation', 'ldfeaturecontainer'); #get adaptor for LDFeatureContainer object
my $ldFeatureContainer = $ldFeatureContainerAdaptor-&gt;fetch_by_Slice($slice,$population); #retrieve all LD values in the region

foreach my $r_square (@{$ldFeatureContainer-&gt;get_all_r_square_values}){
  if ($r_square-&gt;{r2} &gt; 0.8){ #only print high LD, where high is defined as r2 &gt; 0.8
    print "High LD between variations ", $r_square-&gt;{variation1}-&gt;variation_name,"-", $r_square-&gt;{variation2}-&gt;variation_name, "\n";
  }
}
</pre>

<p>
Please note the following warning <code> MSG: variation features have no pairwise ld information </code> is returned when there is no data in the LDFeatureContainer structure for the specified pair of VariationFeature objects. Here are some reasons why this may happen:
</p>
<ul>
<li>the LDFeatureContainer does not span the region contained by one or both VariationFeature objects specified</li>
<li>there are no genotypes for one or both variations, meaning no LD can be calculated</li>
<li>one or both variations is non-variant in the specified population (i.e. has a minor allele frequency of 0)</li>
<li>the estimated r<sup>2</sup> value is lower than the cut-off threshold in the calculation software (the threshold is 0.05)</li>
</ul>
<p> Looking at other associated data will help to narrow down the reason. If there are variants in the region spanned by the LDFeatureContainer 
with genotypes with a minor allele frequency greater than zero, then assume the r<sup>2</sup> is < 0.05, which essentially means no correlation. </p>

<h2 id="strains">Specific strain information</h2>

<p>
With the apparition of the new technologies, one of the new functionalities that the variation API has is the possibility to
work with your specific strain as if it was the reference one, and compare it against others. In the example, we create a StrainSlice
object for a region in Craig Venter's sequence and compare it against the reference sequence.
</p>

<pre class="code">
use strict;
use warnings;

use Bio::EnsEMBL::Registry;

my $reg = 'Bio::EnsEMBL::Registry';
my $host= 'ensembldb.ensembl.org';
my $user= 'anonymous';

$reg-&gt;load_registry_from_db(
	-host =&gt; $host,
    -user =&gt; $user
);

# get exon adaptor from core
my $sa = $reg-&gt;get_adaptor("human", "core", "slice");

my $slice = $sa-&gt;fetch_by_region('chromosome', 8, 9213000, 9216000);

# get strainSlice from the slice
my $venter = $slice-&gt;get_by_strain("Venter");

my @differences = @{$venter-&gt;get_all_AlleleFeatures_Slice()};

foreach my $diff (@differences){
  print "Locus ", $diff-&gt;seq_region_start, "-", $diff-&gt;seq_region_end, ", Venter's alleles: ",$diff-&gt;allele_string, "\n";
}
</pre>

<h2 id="help">Further help</h2>

<p>
For additional information or help mail the <a href="mailto:ensemb-dev&#64;ebi.ac.uk">ensembl-dev</a> mailing list.
You will need to subscribe to this mailing list to use it.
More information on subscribing to any Ensembl mailing list is available from the 
<a href="http://www.ensembl.org/info/about/contact/">Ensembl Contacts</a> page.
</p>

</body>
</html>
