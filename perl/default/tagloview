#!/usr/local/bin/perl

package tag_response;
use strict;
use EnsWeb;
use EnsEMBL::HTML::Page;
use CGI qw/:standard :form :netscape3/;
use Bio::EnsEMBL::ExternalData::Haplotype::Select;
use Bio::EnsEMBL::ExternalData::Haplotype::Tag;
use EnsEMBL::Web::Output::HTML;
use Data::Dumper;

my $q = new CGI;
my $r =Apache->request();
my $Output =  EnsEMBL::Web::Output::HTML->new;

my $DEBUG=1; 
my $pre_snp_id_list    = $q->param('snp_id_list');
my $hap_id             = $q->param('hap_id');
my $pre_hap_block      = $q->param('hap_block');
my $pre_pop_info       = $q->param('pop_info');
my $pre_selected_fam   = $q->param('selected_fam');
my $pre_freq_fam       = $q->param('freq_fam');



$pre_freq_fam >1 ? 1 : $pre_freq_fam ;

$pre_pop_info =~ s/^\s+//;
$pre_pop_info =~ s/\s+$//;

my $snp_id_list    = [split /\W+/, $pre_snp_id_list]; 
my $hap_block      = [split /[^\w-]+/, $pre_hap_block];
my $selected_fam   = [split /\W+/, $pre_selected_fam];
my $pop_info    = undef;
my $tmp         = [split /\n/,  $pre_pop_info];

foreach my $i (0..$#$tmp){
    $tmp->[$i] =~ s/^\s+//;
    $tmp->[$i] =~ s/\s+$//;
    $pop_info->[$i] = [split /\t|\s+/, $tmp->[$i]];
}

print header(),
      ensembl_page_header( 'initfocus'=>1 );
print ensembl_search_table('', "SNP");

unless (scalar(@{$selected_fam}) > 1) {
	 &ensembl_warning(
        "No Haplotypes Selected",
        qq(You must specify at least two haplotypes.));
	exit;
}

_hap_results($snp_id_list, $hap_block, $selected_fam, $pop_info);

print ensembl_page_footer();
&ensembl_exit();


########################################################

sub _hap_results {
    my ($snp_id_list, $pre_hap_block, $selected_fam, $pre_pop_info) = @_;

##########################################
# select just the families we need 
##########################################
my @hap_block = map $pre_hap_block->[$_], @$selected_fam ;
my @pop_info  = map $pre_pop_info->[$_], @$selected_fam ;

my $hap = Bio::EnsEMBL::ExternalData::Haplotype::Select->new( \@hap_block, $snp_id_list, \@pop_info);
my $ht_set        = $hap->ht_set;

my $tag = Bio::EnsEMBL::ExternalData::Haplotype::Tag->new( $ht_set );

	$Output->generic_table_title('Haplotype Redundancy Report');
	$Output->print_two_col_table(
		'Haplotype', "<b>".$q->param('hap_id')."</b>",
		'Haplotype Summary', &_hap_report($hap, $tag),
	);
	$Output->generic_table_title('Haplotype SNP Cluster');
	$Output->print_spreadsheet_table(&_snp_report($hap, $tag));
	$Output->print_spreadsheet_table(&_print_haplotype($hap, $tag));
}

sub _snp_report{
my $hap = shift;
my $tag = shift;
my $ht_type       = $hap->ht_type;
my $input_block   = $hap->input_block;
my $snp_ids       = $hap->snp_ids;
my $pop_freq      = $hap->pop_freq;
my $deg_snp       = $hap->deg_snp;
my $silent_snp    = $hap->silent_snp;
my $useful_snp    = $hap->useful_snp;
my $snp_type_code = $hap->snp_type_code;
my $snp_and_code  = $hap->snp_and_code;
my $split_hap     = $hap->split_hap;
my $tag_list   = $tag->tag_list;
my $tag_length = $tag->tag_length;
#######################################
# generate colour code for the values
#######################################
my $colour_code= {};
# red for degeneration indicating: Better not to use this family
$colour_code->{'-1'} = "#FF0000";
# white for silent, means that SNP does not contribute to the final result
$colour_code->{'0'}  = "#FFFFFF";

foreach my $i (0..$#$ht_type){
   my $tmp_colour = _colour_code();
   $colour_code->{$ht_type->[$i]} = $tmp_colour->[$i];
}

my $output =[];

foreach  my $i (0..$#$snp_ids){
    #############################
    #### check usefull snp
    #############################
    my $tmp_snp_type = "";
    my $tmp_snp_type_code ="";
   if (my $pos = _is_there($useful_snp,$snp_ids->[$i])){
       $tmp_snp_type = "INFORMATIVE";
       #######################################
       #### if is informative get it snp_type_code
       #######################################
       $tmp_snp_type_code = $snp_type_code->[$pos-1]; 
    }
    elsif (_is_there($deg_snp,$snp_ids->[$i])){
       $tmp_snp_type = "AMBIGUOUS";
       #######################################
       ##### degeneration is -1 
       #######################################
       $tmp_snp_type_code = -1; 
    }
    elsif (_is_there($silent_snp,$snp_ids->[$i])){
       $tmp_snp_type = "NON INFORMATIVE";
       #######################################
       ##### silent means 0 
       #######################################
       $tmp_snp_type_code = 0; 
    }
    else {
       $tmp_snp_type = "ERROR";
    }
	my $snp_id = $snp_ids->[$i];

    push @$output, { 'pos' => $i+1, 'snp' => qq(<A HREF="/$ENV{'ENSEMBL_SPECIES'}/snpview?snp=$snp_id"> $snp_id</A
><br>), 'type' => $tmp_snp_type, 'tag_val' => $tmp_snp_type_code};
}

# cluster snp's by type
my $snp_hash = {};
my $snp_group = 'A';
foreach my $i (0..$#$output){
    my $tmp = $output->[$i]->{'snp'};
    push @{$snp_hash->{$output->[$i]->{'tag_val'}}}, $tmp;
}

	my @title_hash;
	my %snp_group_hash ;

foreach my $i(0..$#$tag_list){
	
    my $col_widths = int(65 / scalar(@$tag_list));
	my $cluster_title = qq(Cluster ).($i+1);
	push @title_hash, {'key' => "cluster$i", 'title' => $cluster_title , 'align' => 'center', 'width' => "$col_widths%%"};
	my $tag_value = [];
    foreach my $j(0..$#{$tag_list->[$i]}){
        my $key = $ht_type->[$tag_list->[$i][$j]];
		foreach (@$output){
			if ($_->{'tag_val'} == $key){								
            	my $cc       = $colour_code->{$key};            	           	
				$snp_group_hash{$key} ||= $snp_group++;
				$_->{"cluster$i"} = "<span style='background-color :"
                     .$cc.";'>".
                     $snp_group_hash{$key}."</span>";
				}
				
		}
    }
    #get tag list
    foreach my $j (0..$#{$tag_list->[$i]}){
        my $cc = $ht_type->[$tag_list->[$i][$j]];
        push(@$tag_value, $cc);
    }
	$hap->{'_tag_value_'} = $tag_value;
}

###spreadsheet###
 my $titles = [ {'key' => 'pos', 'title' => 'Position', 'align' => 'center', 'width' => '5%%' },
                    {'key' => 'snp', 'title' => 'SNP ID', 'align' => 'center', 'width' => '10%%'},
                    {'key' => 'type', 'title' => 'SNP type', 'align' => 'center', 'width' => '20%%'},
                    @title_hash];

return ($titles, $output, {'rows' => [qw(background1 background3)]} );

}

sub _print_snp{
    my $value = shift;
    foreach (@{$value}){
        # split the value
        my $tmp = [split /\W+/, $_];
        print qq(<A HREF="/$ENV{'ENSEMBL_SPECIES'}/snpview?snp=$tmp->[0]"> $_</A
><br>);
    }
}

sub _hap_report{
    my $hap = shift;
    my $tag = shift;
    my $hap_length    = $hap->hap_length;
    my $deg_snp_nu    = @{$hap->deg_snp};
    my $silent_snp_nu = @{$hap->silent_snp};
    my $useful_snp_nu = @{$hap->useful_snp};
    my $ht_length     = @{$hap->ht_type}; 
    my $deg_fam       = $hap->deg_fam;
    my $tag_list   = $tag->tag_list;
    my $tag_length = $tag->tag_length;
    my $hap_tag_ratio  = $tag_length/$hap_length;
    my $hap_ht_ratio   = $ht_length/$hap_length;
    my $number_of_tags = @{$tag_list};

    my $html .= qq(
		<table class="hidden"><tr>
        <td><b>Total number of SNPs</b></td><td>&nbsp;= $hap_length&nbsp;</td>
          </tr><tr>
        <td><b>No. of tag groups</b></td><td>&nbsp;= $ht_length&nbsp;</td>
           </tr><tr>
        <td><b>No. htSNP to resolve haplotype</b></td><td>&nbsp;= $tag_length&nbsp;</td>
           </tr><tr>
        <td><b>No. cluster combinations</b></td><td>&nbsp;= $number_of_tags&nbsp;</td>
           </tr>);
    if ($useful_snp_nu){
    $html .= qq(<tr>
        <td><b>Informative SNPs</b></td><td>&nbsp;= $useful_snp_nu&nbsp;</td>
           </tr>);
    }
    if ($deg_snp_nu){
    $html .= qq(<tr>
        <td><b>Non-Informative SNPs</b></td><td>&nbsp;= $deg_snp_nu&nbsp;</td>
           </tr>);
    }
    if ($silent_snp_nu){
    $html .= qq(<tr>
        <td><b>Ambiguous SNPs</b></td><td>&nbsp;= $silent_snp_nu&nbsp;</td>
           </tr>);
    }
    $html .= qq(<tr>
        <td><b>Tag groups/total SNP ratio</b></td><td>&nbsp;= $hap_ht_ratio&nbsp;</td>
           </tr><tr>
        <td><b>Tag SNP/Total SNP ratio</b></td><td>&nbsp;= $hap_tag_ratio&nbsp;</td>
           </tr></table>\n\n);
    my $redundance = 0;
    foreach my $family (keys %$deg_fam) {
        if (scalar @{ $deg_fam->{$family} }>1){
            $redundance =1;
            last;
        }
    }
    if ($redundance){
       $html .=  qq(Note:\n <br />Some haplotype share the same pattern
             and have been clustered.<br /><table border=1><tr><td>Haplotype selected</td><td>Pattern match</td></tr>);
        foreach my $family (keys %$deg_fam) {
            if (scalar @{ $deg_fam->{$family} }>1){
                $html .= "<tr>";
                $html .= "<td>"
                     .($family+1)
                     ."</td><td>";
                foreach my $k (0..$#{$deg_fam->{$family}}){
                    $html .= ($deg_fam->{$family}->[$k]+1);
                    $html .= "\t";
                }
                $html .= "</td>";
                $html .= "</tr>";
            }
        }
    }
	$html .= "</table>";
	return $html;
}

# print the haplotype and colour the bases tag
sub _print_haplotype{
    my $hap         = shift;
    my $tag			= shift;
	my $tag_list    = $tag->tag_list;
    my $snp_and_code  = $hap->snp_and_code;
    my $split_hap     = $hap->split_hap;
    my $pop_freq      = $hap->pop_freq;
	my $ht_type 		= $hap->ht_type;
	my $data;
my $colour_code= {};
# red for degeneration indicating: Better not to use this family
$colour_code->{'-1'} = "#FF0000";
# white for silent, means that SNP does not contribute to the final result
$colour_code->{'0'}  = "#FFFFFF";

foreach my $i (0..$#$ht_type){
   my $tmp_colour = _colour_code();
   $colour_code->{$ht_type->[$i]} = $tmp_colour->[$i];
}
	my $titles = [ {'key' => 'cluster', 'title' => 'Cluster', 'align' => 'center', 'width' => '5%%' },
                    {'key' => 'hap_id', 'title' => 'Haplotype ID', 'align' => 'center', 'width' => '25%%'},
					{'key' => 'pop_freq', 'title' => 'Population Frequency', 'align' => 'center', 'width' => '20%%'},
                    {'key' => 'markup', 'title' => 'Haplotype type', 'align' => 'center', 'width' => '50%%'}];
	my $data;
foreach my $i(0..$#$tag_list){
	
	my $tag_value = [];
    my $cluster = qq(Cluster ).($i+1);
	my @haplotype_id;
	my @population_freq;
	my @seq_markup;
    foreach my $j(0..$#{$tag_list->[$i]}){
        my $key = $ht_type->[$tag_list->[$i][$j]];		
    }
    #get tag list
    foreach my $j (0..$#{$tag_list->[$i]}){
        my $cc = $ht_type->[$tag_list->[$i][$j]];
        push(@$tag_value, $cc);
    }	
    foreach my $k (0..$#$split_hap){
        # print ID and frequency        
		my $markup;
		my ($hap_id, $pop_freq) = @{$pop_freq->[$k]};		
		push @haplotype_id , $hap_id;
		push @population_freq , $pop_freq;
        foreach my $l (0..$#{$split_hap->[$k]}){
            my $base     = $split_hap->[$k]->[$l];
            my $snp_id   = $snp_and_code->[$l]->[0];
            my $snp_code = $snp_and_code->[$l]->[1];
            my $cc       = $colour_code->{$snp_code};
            if(_is_there($tag_value, $snp_code)){
                 $markup .= "<span style='background-color :"
                     .$cc.";'>"
                     .$base
                     ."</span>";
            }
            else{
                 $markup .= $base;
            }
         
		} 	
		push @seq_markup, $markup;	  
    }
	push @$data , {'cluster' => $cluster, 'hap_id' => join('<br />', @haplotype_id), 'pop_freq' => join('<br />', @population_freq), 'markup' => join('<br />', @seq_markup)."<br /><br />"}
}
return ($titles, $data, {'rows' => [qw(background1 background3)]});
}

# return one more to avoid zero as false
sub _is_there{
    my($arr,$value)=@_;
    foreach my $i (0..$#$arr){
        if ($arr->[$i] eq $value){
            # return one more to avoid zero as false
            return $i+1;
        }
    }
}

# list of colour codes
# if you need more you can add values to this list.
# The codes has been selected to return an nice output.
sub _colour_code{
    my $colour_code = 
        [qw(#FFFF00
            #33CCFF
            #33FFCC
            #CC33FF
            #CCFF33
            #FFCC33
            #FF33CC
            #AACCFF
            #AAFFCC
            #CCAAFF
            #CCFFAA
            #FFCCAA
            #FFAACC
            #CC66AA
            #66CCAA
            #66AACC)];
    return $colour_code;
};

use Bio::EnsEMBL::Registry; Bio::EnsEMBL::Registry->disconnect_all();1;
